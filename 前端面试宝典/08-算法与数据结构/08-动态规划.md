# 动态规划

## 基本概念

动态规划（Dynamic Programming，简称DP）是一种通过将复杂问题分解为更简单的子问题来解决问题的算法思想。它适用于具有**重叠子问题**和**最优子结构**特性的问题。

### 核心特性

1. **最优子结构**：问题的最优解包含其子问题的最优解
2. **重叠子问题**：在求解过程中，同一个子问题会被重复计算多次
3. **状态转移**：通过状态转移方程，将大问题转化为小问题

### 动态规划解题步骤

1. 定义状态（确定dp数组的含义）
2. 找出状态转移方程
3. 确定初始条件和边界情况
4. 确定计算顺序（自底向上或自顶向下）
5. 实现代码并验证

### 动态规划与其他算法的区别

| 算法 | 核心思想 | 适用问题 | 子问题特点 |
|------|----------|----------|------------|
| 动态规划 | 状态转移 | 最优化问题 | 重叠子问题 |
| 分治法 | 分而治之 | 可分解问题 | 相互独立子问题 |
| 贪心算法 | 局部最优 | 具有贪心性质问题 | 不需要回溯验证 |
| 回溯法 | 试探与回溯 | 组合问题 | 需要遍历所有可能性 |

## 常见动态规划问题类型

### 1. 线性DP

#### 斐波那契数列

```javascript
/**
 * @description 计算斐波那契数列的第n个数
 * @param {number} n - 位置索引
 * @return {number} 斐波那契数
 */
function fibonacci(n) {
  if (n <= 1) return n;

  // 创建dp数组
  const dp = new Array(n + 1);

  // 设置初始状态
  dp[0] = 0;
  dp[1] = 1;

  // 状态转移
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

// 优化空间复杂度的版本
function fibonacciOptimized(n) {
  if (n <= 1) return n;

  let prev = 0;
  let curr = 1;

  for (let i = 2; i <= n; i++) {
    const next = prev + curr;
    prev = curr;
    curr = next;
  }

  return curr;
}

// 调用示例
console.log(fibonacci(6)); // 输出: 8
console.log(fibonacciOptimized(6)); // 输出: 8

// 执行过程分析 (n=6):
// 初始状态: dp[0]=0, dp[1]=1
// i=2: dp[2] = dp[1] + dp[0] = 1 + 0 = 1
// i=3: dp[3] = dp[2] + dp[1] = 1 + 1 = 2
// i=4: dp[4] = dp[3] + dp[2] = 2 + 1 = 3
// i=5: dp[5] = dp[4] + dp[3] = 3 + 2 = 5
// i=6: dp[6] = dp[5] + dp[4] = 5 + 3 = 8
// 返回 dp[6] = 8

// 空间优化版执行过程 (n=6):
// 初始状态: prev=0, curr=1
// i=2: next=0+1=1, prev=1, curr=1
// i=3: next=1+1=2, prev=1, curr=2
// i=4: next=1+2=3, prev=2, curr=3
// i=5: next=2+3=5, prev=3, curr=5
// i=6: next=3+5=8, prev=5, curr=8
// 返回 curr = 8

// 递归与动态规划性能对比
function fibRecursive(n) {
  if (n <= 1) return n;
  return fibRecursive(n - 1) + fibRecursive(n - 2);
}

function timeComparison(n) {
  console.time('递归');
  const result1 = fibRecursive(n);
  console.timeEnd('递归');

  console.time('动态规划');
  const result2 = fibonacci(n);
  console.timeEnd('动态规划');

  console.time('空间优化');
  const result3 = fibonacciOptimized(n);
  console.timeEnd('空间优化');

  console.log(`结果一致: ${result1 === result2 && result2 === result3}`);
}

// n=30的性能对比
timeComparison(30);
// 输出示例:
// 递归: 10.123ms
// 动态规划: 0.087ms
// 空间优化: 0.015ms
// 结果一致: true
```

#### 最长递增子序列

```javascript
/**
 * @description 计算最长递增子序列的长度
 * @param {number[]} nums - 输入数组
 * @return {number} 最长递增子序列的长度
 */
function lengthOfLIS(nums) {
  if (!nums || nums.length === 0) return 0;

  const n = nums.length;
  // dp[i]表示以nums[i]结尾的最长递增子序列的长度
  const dp = new Array(n).fill(1);

  let maxLength = 1;

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    maxLength = Math.max(maxLength, dp[i]);
  }

  return maxLength;
}

/**
 * @description 获取最长递增子序列（不仅长度，还有具体序列）
 * @param {number[]} nums - 输入数组
 * @return {number[]} 最长递增子序列
 */
function getLIS(nums) {
  if (!nums || nums.length === 0) return [];

  const n = nums.length;
  const dp = new Array(n).fill(1);
  const prev = new Array(n).fill(-1);  // 记录前驱节点

  let maxLength = 1;
  let endIndex = 0;  // 最长递增子序列的结束索引

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j] && dp[j] + 1 > dp[i]) {
        dp[i] = dp[j] + 1;
        prev[i] = j;  // 记录前驱
      }
    }

    if (dp[i] > maxLength) {
      maxLength = dp[i];
      endIndex = i;
    }
  }

  // 重建最长递增子序列
  const result = [];
  while (endIndex !== -1) {
    result.unshift(nums[endIndex]);
    endIndex = prev[endIndex];
  }

  return result;
}

// 使用二分查找优化的O(n log n)解法
function lengthOfLISOptimized(nums) {
  if (!nums || nums.length === 0) return 0;

  const n = nums.length;
  // tails[i]表示长度为i+1的所有递增子序列的最小结尾元素
  const tails = [];

  for (let num of nums) {
    // 使用二分查找找到num应该放置的位置
    let left = 0, right = tails.length;
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (tails[mid] < num) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    // 如果找到了比num大的最小元素位置，替换它
    // 如果没找到，添加到尾部
    tails[left] = num;
  }

  return tails.length;
}

// 调用示例
const nums = [10, 9, 2, 5, 3, 7, 101, 18];
console.log(`最长递增子序列长度: ${lengthOfLIS(nums)}`);
// 输出: 最长递增子序列长度: 4

console.log(`最长递增子序列: ${getLIS(nums)}`);
// 输出: 最长递增子序列: 2,3,7,18 或 2,3,7,101

console.log(`优化版最长递增子序列长度: ${lengthOfLISOptimized(nums)}`);
// 输出: 优化版最长递增子序列长度: 4

// 执行过程分析 (以nums = [10, 9, 2, 5, 3, 7, 101, 18]为例):
// 初始状态: dp = [1, 1, 1, 1, 1, 1, 1, 1]
// i=1 (9): 没有比9小的元素，dp[1] = 1
// i=2 (2): 没有比2小的元素，dp[2] = 1
// i=3 (5): 比对j=2 (2) < 5，dp[3] = max(1, 1+1) = 2
// i=4 (3): 比对j=2 (2) < 3，dp[4] = max(1, 1+1) = 2
// i=5 (7): 比对j=2,3,4，dp[5] = max(1, 1+1, 2+1, 2+1) = 3
// i=6 (101): 比对所有小于101的元素，dp[6] = 4
// i=7 (18): 比对所有小于18的元素，dp[7] = 4
// 最大值为4

// 优化版执行过程:
// tails初始为[]
// num=10: tails=[10]
// num=9: tails=[9]
// num=2: tails=[2]
// num=5: tails=[2,5]
// num=3: tails=[2,3]
// num=7: tails=[2,3,7]
// num=101: tails=[2,3,7,101]
// num=18: tails=[2,3,7,18]
// 最终长度为4

// 性能对比
function comparePerformance() {
  // 生成大型输入
  const largeInput = Array.from({ length: 5000 }, () => Math.floor(Math.random() * 10000));

  console.time('O(n²)解法');
  const result1 = lengthOfLIS(largeInput);
  console.timeEnd('O(n²)解法');

  console.time('O(n log n)解法');
  const result2 = lengthOfLISOptimized(largeInput);
  console.timeEnd('O(n log n)解法');

  console.log(`结果一致: ${result1 === result2}`);
}

comparePerformance();
// 输出示例:
// O(n²)解法: 150.345ms
// O(n log n)解法: 2.413ms
// 结果一致: true
```

#### 最大子数组和

```javascript
/**
 * @description 计算最大子数组和
 * @param {number[]} nums - 输入数组
 * @return {number} 最大子数组和
 */
function maxSubArray(nums) {
  if (!nums || nums.length === 0) return 0;

  const n = nums.length;
  // dp[i]表示以nums[i]结尾的最大子数组和
  const dp = new Array(n);
  dp[0] = nums[0];

  let maxSum = dp[0];

  for (let i = 1; i < n; i++) {
    // 状态转移方程：dp[i] = max(dp[i-1] + nums[i], nums[i])
    dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
    maxSum = Math.max(maxSum, dp[i]);
  }

  return maxSum;
}

// 空间优化版本
function maxSubArrayOptimized(nums) {
  if (!nums || nums.length === 0) return 0;

  let maxSum = nums[0];
  let currentSum = nums[0];

  for (let i = 1; i < nums.length; i++) {
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
  }

  return maxSum;
}

// 获取最大子数组的具体范围
function maxSubArrayWithRange(nums) {
  if (!nums || nums.length === 0) return { maxSum: 0, start: -1, end: -1 };

  let maxSum = nums[0];
  let currentSum = nums[0];
  let start = 0;
  let end = 0;
  let tempStart = 0;

  for (let i = 1; i < nums.length; i++) {
    if (currentSum + nums[i] > nums[i]) {
      currentSum += nums[i];
    } else {
      currentSum = nums[i];
      tempStart = i;
    }

    if (currentSum > maxSum) {
      maxSum = currentSum;
      start = tempStart;
      end = i;
    }
  }

  return { maxSum, start, end };
}

// 调用示例
const array = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
console.log(`最大子数组和: ${maxSubArray(array)}`);
// 输出: 最大子数组和: 6

console.log(`空间优化版最大子数组和: ${maxSubArrayOptimized(array)}`);
// 输出: 空间优化版最大子数组和: 6

const result = maxSubArrayWithRange(array);
console.log(`最大子数组: 和=${result.maxSum}, 范围=[${result.start},${result.end}], 子数组=[${array.slice(result.start, result.end + 1)}]`);
// 输出: 最大子数组: 和=6, 范围=[3,6], 子数组=[4,-1,2,1]

// 执行过程分析 (以[-2, 1, -3, 4, -1, 2, 1, -5, 4]为例):
// dp[0] = -2
// i=1: dp[1] = max(dp[0] + 1, 1) = max(-2 + 1, 1) = 1
// i=2: dp[2] = max(dp[1] + -3, -3) = max(1 + -3, -3) = -2
// i=3: dp[3] = max(dp[2] + 4, 4) = max(-2 + 4, 4) = 4
// i=4: dp[4] = max(dp[3] + -1, -1) = max(4 + -1, -1) = 3
// i=5: dp[5] = max(dp[4] + 2, 2) = max(3 + 2, 2) = 5
// i=6: dp[6] = max(dp[5] + 1, 1) = max(5 + 1, 1) = 6 (最大)
// i=7: dp[7] = max(dp[6] + -5, -5) = max(6 + -5, -5) = 1
// i=8: dp[8] = max(dp[7] + 4, 4) = max(1 + 4, 4) = 5
// 最大值为6

// 前端实际应用：性能数据分析
function analyzePerformanceData(responseTimeSeries) {
  // 找出响应时间最稳定的时间段
  const changes = [];
  for (let i = 1; i < responseTimeSeries.length; i++) {
    changes.push(responseTimeSeries[i] - responseTimeSeries[i-1]);
  }

  // 变化越小越稳定，所以我们求负变化的最大子数组
  const negatedChanges = changes.map(val => -Math.abs(val));
  const result = maxSubArrayWithRange(negatedChanges);

  return {
    // 将索引调整为原始数组
    stableRangeStart: result.start + 1,
    stableRangeEnd: result.end + 1,
    stabilityScore: -result.maxSum // 转回正值表示稳定性
  };
}

// 模拟网站响应时间数据
const responseTimes = [120, 125, 130, 135, 133, 132, 137, 150, 180, 190, 185, 183, 182, 180];
const stability = analyzePerformanceData(responseTimes);
console.log(`最稳定的时间段: 从第${stability.stableRangeStart}个到第${stability.stableRangeEnd}个数据点`);
console.log(`该时间段的波动: ${responseTimes.slice(stability.stableRangeStart, stability.stableRangeEnd + 1)}`);
console.log(`稳定性评分: ${stability.stabilityScore}`);
// 可能的输出:
// 最稳定的时间段: 从第2个到第6个数据点
// 该时间段的波动: [125, 130, 135, 133, 132]
// 稳定性评分: 3.5
```

### 2. 背包问题

#### 0-1背包问题

```javascript
/**
 * @description 0-1背包问题
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number} capacity - 背包容量
 * @return {number} 最大价值
 */
function knapsack(weights, values, capacity) {
  const n = weights.length;
  // dp[i][j]表示前i个物品，背包容量为j时的最大价值
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= capacity; j++) {
      if (weights[i - 1] > j) {
        // 当前物品重量大于背包容量，不能放入
        dp[i][j] = dp[i - 1][j];
      } else {
        // 可以放入，取放入或不放入的最大值
        dp[i][j] = Math.max(
          dp[i - 1][j],  // 不放入
          dp[i - 1][j - weights[i - 1]] + values[i - 1]  // 放入
        );
      }
    }
  }

  return dp[n][capacity];
}

/**
 * @description 0-1背包问题空间优化版
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number} capacity - 背包容量
 * @return {number} 最大价值
 */
function knapsackOptimized(weights, values, capacity) {
  const n = weights.length;
  // 一维dp数组，dp[j]表示容量为j的背包能达到的最大价值
  const dp = Array(capacity + 1).fill(0);

  for (let i = 0; i < n; i++) {
    // 注意：必须从大到小遍历！否则物品会被重复放入
    for (let j = capacity; j >= weights[i]; j--) {
      dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
    }
  }

  return dp[capacity];
}

/**
 * @description 获取0-1背包问题的解决方案（哪些物品被选中）
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number} capacity - 背包容量
 * @return {Object} 包含最大价值和选择的物品
 */
function knapsackWithItems(weights, values, capacity) {
  const n = weights.length;
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  // 填充dp表
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= capacity; j++) {
      if (weights[i - 1] > j) {
        dp[i][j] = dp[i - 1][j];
      } else {
        dp[i][j] = Math.max(
          dp[i - 1][j],
          dp[i - 1][j - weights[i - 1]] + values[i - 1]
        );
      }
    }
  }

  // 回溯找出选择的物品
  const selected = [];
  let remainingCapacity = capacity;

  for (let i = n; i > 0; i--) {
    // 检查物品i是否被选中
    if (dp[i][remainingCapacity] !== dp[i - 1][remainingCapacity]) {
      selected.push(i - 1); // 选中物品索引
      remainingCapacity -= weights[i - 1];
    }
  }

  return {
    maxValue: dp[n][capacity],
    selectedItems: selected.reverse() // 按原始顺序排列
  };
}

// 调用示例
const weights = [2, 3, 4, 5];
const values = [3, 4, 5, 6];
const capacity = 8;

console.log(`0-1背包最大价值: ${knapsack(weights, values, capacity)}`);
// 输出: 0-1背包最大价值: 10

console.log(`空间优化版最大价值: ${knapsackOptimized(weights, values, capacity)}`);
// 输出: 空间优化版最大价值: 10

const solution = knapsackWithItems(weights, values, capacity);
console.log(`最大价值: ${solution.maxValue}, 选中物品: [${solution.selectedItems}]`);
// 输出: 最大价值: 10, 选中物品: [0,1,2]

// 执行过程分析:
// 初始状态: dp[0][j] = 0 (0个物品), dp[i][0] = 0 (容量为0)
// i=1, 物品[0]重量=2, 价值=3:
//   j=1: weights[0] > j, dp[1][1] = dp[0][1] = 0
//   j=2: dp[1][2] = max(dp[0][2], dp[0][0] + values[0]) = max(0, 0 + 3) = 3
//   j=3~8: dp[1][j] = max(dp[0][j], dp[0][j-2] + 3) = 3
// i=2, 物品[1]重量=3, 价值=4:
//   j=1,2: weights[1] > j, dp[2][j] = dp[1][j]
//   j=3: dp[2][3] = max(dp[1][3], dp[1][0] + values[1]) = max(3, 0 + 4) = 4
//   j=4: dp[2][4] = max(dp[1][4], dp[1][1] + values[1]) = max(3, 0 + 4) = 4
//   j=5: dp[2][5] = max(dp[1][5], dp[1][2] + values[1]) = max(3, 3 + 4) = 7
//   j=6~8: dp[2][j] = 7
// i=3, 物品[2]重量=4, 价值=5:
//   j=1,2,3: weights[2] > j, dp[3][j] = dp[2][j]
//   j=4: dp[3][4] = max(dp[2][4], dp[2][0] + values[2]) = max(4, 0 + 5) = 5
//   j=5: dp[3][5] = max(dp[2][5], dp[2][1] + values[2]) = max(7, 0 + 5) = 7
//   j=6: dp[3][6] = max(dp[2][6], dp[2][2] + values[2]) = max(7, 3 + 5) = 8
//   j=7: dp[3][7] = max(dp[2][7], dp[2][3] + values[2]) = max(7, 4 + 5) = 9
//   j=8: dp[3][8] = max(dp[2][8], dp[2][4] + values[2]) = max(7, 4 + 5) = 9
// i=4, 物品[3]重量=5, 价值=6:
//   j=1,2,3,4: weights[3] > j, dp[4][j] = dp[3][j]
//   j=5: dp[4][5] = max(dp[3][5], dp[3][0] + values[3]) = max(7, 0 + 6) = 7
//   j=6: dp[4][6] = max(dp[3][6], dp[3][1] + values[3]) = max(8, 0 + 6) = 8
//   j=7: dp[4][7] = max(dp[3][7], dp[3][2] + values[3]) = max(9, 3 + 6) = 9
//   j=8: dp[4][8] = max(dp[3][8], dp[3][3] + values[3]) = max(9, 4 + 6) = 10
// 最终结果: dp[4][8] = 10

// 前端实际应用：资源加载优化
function optimizeResourceLoading(resources, bandwidthLimit) {
  // resources: 资源对象数组，每个包含 {size: 资源大小KB, importance: 重要性评分}
  // bandwidthLimit: 带宽限制KB

  const weights = resources.map(res => res.size);
  const values = resources.map(res => res.importance);

  const result = knapsackWithItems(weights, values, bandwidthLimit);

  const criticalResources = result.selectedItems.map(idx => resources[idx]);
  const remainingResources = resources.filter((_, idx) => !result.selectedItems.includes(idx));

  return {
    criticalResources,   // 应当优先加载的资源
    remainingResources,  // 可延迟加载的资源
    totalImportance: result.maxValue,
    totalSize: result.selectedItems.reduce((sum, idx) => sum + resources[idx].size, 0)
  };
}

// 模拟网站资源
const webResources = [
  { name: "核心JS", size: 120, importance: 10 },
  { name: "CSS样式", size: 85, importance: 8 },
  { name: "产品图片", size: 350, importance: 6 },
  { name: "字体资源", size: 95, importance: 4 },
  { name: "分析脚本", size: 70, importance: 2 },
  { name: "视频资源", size: 1200, importance: 5 }
];

const loadingPlan = optimizeResourceLoading(webResources, 300);
console.log("首屏加载资源:");
loadingPlan.criticalResources.forEach(res => {
  console.log(`- ${res.name}: ${res.size}KB (重要性: ${res.importance})`);
});
console.log(`总加载大小: ${loadingPlan.totalSize}KB / 300KB`);
console.log(`重要性总分: ${loadingPlan.totalImportance}`);
console.log("延迟加载资源:");
loadingPlan.remainingResources.forEach(res => {
  console.log(`- ${res.name}: ${res.size}KB`);
});

// 示例输出:
// 首屏加载资源:
// - 核心JS: 120KB (重要性: 10)
// - CSS样式: 85KB (重要性: 8)
// - 字体资源: 95KB (重要性: 4)
// 总加载大小: 300KB / 300KB
// 重要性总分: 22
// 延迟加载资源:
// - 产品图片: 350KB
```

#### 完全背包问题

```javascript
/**
 * @description 完全背包问题（每种物品可以选择无限次）
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number} capacity - 背包容量
 * @return {number} 最大价值
 */
function completePack(weights, values, capacity) {
  const n = weights.length;
  // dp[j]表示背包容量为j时的最大价值
  const dp = Array(capacity + 1).fill(0);

  for (let i = 0; i < n; i++) {
    for (let j = weights[i]; j <= capacity; j++) {
      // 注意：这里内层循环从小到大遍历，而0-1背包需要从大到小遍历
      dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
    }
  }

  return dp[capacity];
}

/**
 * @description 完全背包问题 - 获取选择方案
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number} capacity - 背包容量
 * @return {Object} 包含最大价值和选择的物品
 */
function completePackWithItems(weights, values, capacity) {
  const n = weights.length;
  const dp = Array(capacity + 1).fill(0);
  // 记录每个容量下选择的物品
  const selected = Array(capacity + 1).fill().map(() => []);

  for (let j = 0; j <= capacity; j++) {
    selected[j] = Array(n).fill(0);
  }

  for (let i = 0; i < n; i++) {
    for (let j = weights[i]; j <= capacity; j++) {
      const newValue = dp[j - weights[i]] + values[i];
      if (newValue > dp[j]) {
        dp[j] = newValue;
        // 复制之前的选择
        selected[j] = [...selected[j - weights[i]]];
        // 添加当前物品
        selected[j][i]++;
      }
    }
  }

  // 转换为更易读的格式
  const selectedItems = [];
  for (let i = 0; i < n; i++) {
    if (selected[capacity][i] > 0) {
      selectedItems.push({
        itemIndex: i,
        count: selected[capacity][i]
      });
    }
  }

  return {
    maxValue: dp[capacity],
    selectedItems
  };
}

// 二维版本的完全背包（更易于理解）
function completePackWithTable(weights, values, capacity) {
  const n = weights.length;
  // dp[i][j]表示考虑前i个物品，容量为j时的最大价值
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let j = 0; j <= capacity; j++) {
      // 不选择第i个物品
      dp[i][j] = dp[i-1][j];

      // 选择k个第i个物品
      for (let k = 1; k * weights[i-1] <= j; k++) {
        dp[i][j] = Math.max(
          dp[i][j],
          dp[i-1][j - k * weights[i-1]] + k * values[i-1]
        );
      }
    }
  }

  return dp[n][capacity];
}

// 调用示例
const coins = [1, 2, 5];
const coinValues = [1, 2, 5]; // 价值等于面值
const targetAmount = 11;

console.log(`完全背包最大价值: ${completePack(coins, coinValues, targetAmount)}`);
// 输出: 完全背包最大价值: 11

console.log(`二维版本完全背包: ${completePackWithTable(coins, coinValues, targetAmount)}`);
// 输出: 二维版本完全背包: 11

const coinResult = completePackWithItems(coins, coinValues, targetAmount);
console.log("最优解:");
coinResult.selectedItems.forEach(item => {
  console.log(`- 选择硬币${coins[item.itemIndex]}面值: ${item.count}个`);
});
// 输出:
// 最优解:
// - 选择硬币5面值: 1个
// - 选择硬币2面值: 3个

// 执行过程分析 (以硬币问题为例，求凑成11的最优方式):
// 初始状态: dp[0...11] = [0,0,0,0,0,0,0,0,0,0,0,0]
// i=0, 硬币面值=1:
//   dp[1] = max(dp[1], dp[0] + 1) = max(0, 0 + 1) = 1
//   dp[2] = max(dp[2], dp[1] + 1) = max(0, 1 + 1) = 2
//   ...
//   dp[11] = max(dp[11], dp[10] + 1) = max(0, 10 + 1) = 11
// 现在: dp = [0,1,2,3,4,5,6,7,8,9,10,11]
// i=1, 硬币面值=2:
//   dp[2] = max(dp[2], dp[0] + 2) = max(2, 0 + 2) = 2
//   dp[3] = max(dp[3], dp[1] + 2) = max(3, 1 + 2) = 3
//   dp[4] = max(dp[4], dp[2] + 2) = max(4, 2 + 2) = 4
//   ...
//   dp[11] = max(dp[11], dp[9] + 2) = max(11, 9 + 2) = 11
// 现在: dp = [0,1,2,3,4,5,6,7,8,9,10,11]
// i=2, 硬币面值=5:
//   dp[5] = max(dp[5], dp[0] + 5) = max(5, 0 + 5) = 5
//   dp[6] = max(dp[6], dp[1] + 5) = max(6, 1 + 5) = 6
//   ...
//   dp[10] = max(dp[10], dp[5] + 5) = max(10, 5 + 5) = 10
//   dp[11] = max(dp[11], dp[6] + 5) = max(11, 6 + 5) = 11
// 最终: dp[11] = 11

// 前端实际应用：功能组件组合问题
function optimizeComponentCombination(components, maxSize) {
  // components: 组件数组，每个包含 {size: 体积KB, value: 用户体验评分}
  // maxSize: 最大允许的体积总和

  const sizes = components.map(comp => comp.size);
  const values = components.map(comp => comp.value);

  const result = completePackWithItems(sizes, values, maxSize);

  // 格式化结果
  return {
    maxValue: result.maxValue,
    components: result.selectedItems.map(item => ({
      component: components[item.itemIndex].name,
      count: item.count,
      totalSize: components[item.itemIndex].size * item.count,
      totalValue: components[item.itemIndex].value * item.count
    }))
  };
}

// 模拟UI组件库
const uiComponents = [
  { name: "基础按钮", size: 5, value: 8 },
  { name: "数据表格", size: 15, value: 25 },
  { name: "图表组件", size: 20, value: 30 },
  { name: "表单控件", size: 12, value: 20 },
  { name: "导航菜单", size: 10, value: 18 }
];

const uiPlan = optimizeComponentCombination(uiComponents, 50);
console.log(`最优UI组合 (总体验分: ${uiPlan.maxValue}):`);
uiPlan.components.forEach(comp => {
  console.log(`- ${comp.component} x${comp.count}: 体积${comp.totalSize}KB, 体验分${comp.totalValue}`);
});

// 示例输出:
// 最优UI组合 (总体验分: 85):
// - 数据表格 x1: 体积15KB, 体验分25
// - 图表组件 x2: 体积40KB, 体验分60
```

#### 多重背包问题

```javascript
/**
 * @description 多重背包问题（每种物品有指定的数量限制）
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number[]} counts - 物品数量限制数组
 * @param {number} capacity - 背包容量
 * @return {number} 最大价值
 */
function multiplePack(weights, values, counts, capacity) {
  const n = weights.length;
  const dp = Array(capacity + 1).fill(0);

  for (let i = 0; i < n; i++) {
    // 二进制优化：将counts[i]个物品拆分成二进制组，减少循环次数
    // 例如: 7个物品可以拆分成1,2,4个物品的组合
    let count = counts[i];
    for (let k = 1; count > 0; k *= 2) {
      const amount = Math.min(k, count);
      count -= amount;
      const combinedWeight = weights[i] * amount;
      const combinedValue = values[i] * amount;

      // 按0-1背包处理当前这组物品
      for (let j = capacity; j >= combinedWeight; j--) {
        dp[j] = Math.max(dp[j], dp[j - combinedWeight] + combinedValue);
      }
    }
  }

  return dp[capacity];
}

// 调用示例
const itemWeights = [2, 3, 5];
const itemValues = [3, 4, 5];
const itemCounts = [4, 3, 2]; // 每种物品的数量限制
const knapsackCapacity = 15;

console.log(`多重背包最大价值: ${multiplePack(itemWeights, itemValues, itemCounts, knapsackCapacity)}`);
// 输出: 多重背包最大价值: 21

// 执行过程分析 (简化版):
// i=0, 物品重量=2, 价值=3, 数量=4:
//   二进制拆分: [1,2,1] (共4个)
//   处理1个: weight=2, value=3
//     从j=15到j=2遍历，计算dp[j] = max(dp[j], dp[j-2] + 3)
//   处理2个: weight=4, value=6
//     从j=15到j=4遍历，计算dp[j] = max(dp[j], dp[j-4] + 6)
//   处理1个: weight=2, value=3
//     从j=15到j=2遍历，计算dp[j] = max(dp[j], dp[j-2] + 3)
// 更新后dp = [0,0,3,3,6,6,9,9,12,12,15,15,18,18,21,21]
// ... 继续处理其他物品

// 前端实际应用：广告资源分配问题
function optimizeAdAllocation(adTypes, budget) {
  // adTypes: 广告类型数组，包含 {cost: 单次花费, impact: 影响力, maxCount: 最大投放次数}
  // budget: 总预算

  const costs = adTypes.map(ad => ad.cost);
  const impacts = adTypes.map(ad => ad.impact);
  const maxCounts = adTypes.map(ad => ad.maxCount);

  const maxImpact = multiplePack(costs, impacts, maxCounts, budget);

  // 通过回溯找出最优方案 (此处简化，实际应再实现一个带回溯的版本)
  return {
    maxImpact,
    message: `最大影响力: ${maxImpact}，具体分配方案需进一步计算`
  };
}

// 模拟广告投放选项
const adOptions = [
  { type: "搜索广告", cost: 100, impact: 150, maxCount: 5 },
  { type: "展示广告", cost: 50, impact: 70, maxCount: 10 },
  { type: "社交媒体", cost: 80, impact: 120, maxCount: 7 },
  { type: "邮件营销", cost: 30, impact: 40, maxCount: 15 }
];

const adPlan = optimizeAdAllocation(adOptions, 500);
console.log(adPlan.message);
// 输出: 最大影响力: 740，具体分配方案需进一步计算
```

### 3. 区间DP

区间DP是处理区间问题的动态规划方法，通常定义状态dp[i][j]表示区间[i,j]上的最优解。

#### 最长回文子串

```javascript
/**
 * @description 寻找字符串中的最长回文子串
 * @param {string} s - 输入字符串
 * @return {string} 最长回文子串
 */
function longestPalindrome(s) {
  if (!s || s.length < 2) return s;

  const n = s.length;
  // dp[i][j]表示s[i...j]是否为回文串
  const dp = Array(n).fill().map(() => Array(n).fill(false));

  let start = 0;
  let maxLength = 1;

  // 所有单个字符都是回文
  for (let i = 0; i < n; i++) {
    dp[i][i] = true;
  }

  // 检查长度为2的子串
  for (let i = 0; i < n - 1; i++) {
    if (s[i] === s[i + 1]) {
      dp[i][i + 1] = true;
      start = i;
      maxLength = 2;
    }
  }

  // 检查长度大于2的子串
  for (let len = 3; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1;
      if (s[i] === s[j] && dp[i + 1][j - 1]) {
        dp[i][j] = true;
        start = i;
        maxLength = len;
      }
    }
  }

  return s.substring(start, start + maxLength);
}

/**
 * @description 使用中心扩展法寻找最长回文子串（优化空间复杂度）
 * @param {string} s - 输入字符串
 * @return {string} 最长回文子串
 */
function longestPalindromeExpand(s) {
  if (!s || s.length < 2) return s;

  let start = 0, maxLength = 1;

  // 从中心向两边扩展
  function expandAroundCenter(left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      const currentLength = right - left + 1;
      if (currentLength > maxLength) {
        maxLength = currentLength;
        start = left;
      }
      left--;
      right++;
    }
  }

  for (let i = 0; i < s.length; i++) {
    // 以单个字符为中心
    expandAroundCenter(i, i);
    // 以两个字符之间为中心
    expandAroundCenter(i, i + 1);
  }

  return s.substring(start, start + maxLength);
}

// 调用示例
const str1 = "babad";
const str2 = "cbbd";

console.log(`输入: "${str1}", 最长回文子串: "${longestPalindrome(str1)}"`);
// 输出: 输入: "babad", 最长回文子串: "bab" (或 "aba")

console.log(`输入: "${str2}", 最长回文子串: "${longestPalindrome(str2)}"`);
// 输出: 输入: "cbbd", 最长回文子串: "bb"

console.log(`中心扩展法 - 输入: "${str1}", 结果: "${longestPalindromeExpand(str1)}"`);
// 输出: 中心扩展法 - 输入: "babad", 结果: "bab" (或 "aba")

// 执行过程分析 (以"babad"为例):
// 初始化所有长度为1的子串为回文: dp[i][i] = true
// 检查长度为2的子串:
//   dp[0][1]: "ba" 不是回文
//   dp[1][2]: "ab" 不是回文
//   dp[2][3]: "ba" 不是回文
//   dp[3][4]: "ad" 不是回文
// 检查长度为3的子串:
//   dp[0][2]: "bab", 检查s[0]==s[2] && dp[1][1], 即'b'=='b' && true，所以是回文
//     更新start=0, maxLength=3
//   dp[1][3]: "aba", 检查s[1]==s[3] && dp[2][2], 即'a'=='a' && true，所以是回文
//     更新start=1, maxLength=3
//   dp[2][4]: "bad", 不是回文
// 检查长度为4的子串:
//   dp[0][3]: "baba", 不是回文
//   dp[1][4]: "abad", 不是回文
// 检查长度为5的子串:
//   dp[0][4]: "babad", 不是回文
// 最终结果: "bab" (从索引0开始长度为3的子串)

// 性能对比
function comparePerformance() {
  // 生成一个长回文串
  const generatePalindrome = (size) => {
    const half = 'a'.repeat(Math.floor(size / 2));
    const mid = size % 2 === 1 ? 'c' : '';
    return half + mid + half.split('').reverse().join('');
  };

  const testString = generatePalindrome(1000);

  console.time('动态规划');
  longestPalindrome(testString);
  console.timeEnd('动态规划');

  console.time('中心扩展');
  longestPalindromeExpand(testString);
  console.timeEnd('中心扩展');
}

comparePerformance();
// 输出示例:
// 动态规划: 120.235ms
// 中心扩展: 30.456ms

// 前端实际应用：UI主题设计中的对称检查
function findSymmetricDesignPattern(layoutPattern) {
  // 检查设计模式是否具有对称美感
  const symmetricSection = longestPalindromeExpand(layoutPattern);

  if (symmetricSection.length >= layoutPattern.length * 0.5) {
    return {
      isSymmetric: true,
      symmetricPattern: symmetricSection,
      symmetryScore: symmetricSection.length / layoutPattern.length
    };
  } else {
    return {
      isSymmetric: false,
      longestSymmetricSection: symmetricSection,
      symmetryScore: symmetricSection.length / layoutPattern.length
    };
  }
}

// 设计布局编码 (A=区块, B=按钮, C=卡片, T=文本)
const designA = "ABCCBA";  // 对称
const designB = "ABTCBT";  // 不完全对称

console.log(`设计A对称性: ${JSON.stringify(findSymmetricDesignPattern(designA))}`);
console.log(`设计B对称性: ${JSON.stringify(findSymmetricDesignPattern(designB))}`);

// 示例输出:
// 设计A对称性: {"isSymmetric":true,"symmetricPattern":"ABCCBA","symmetryScore":1}
// 设计B对称性: {"isSymmetric":false,"longestSymmetricSection":"TCT","symmetryScore":0.5}
```

#### 矩阵链乘法

```javascript
/**
 * @description 矩阵链乘法问题 - 寻找最优的矩阵乘法顺序
 * @param {number[]} dimensions - 矩阵维度数组，dimensions[i-1]×dimensions[i]表示第i个矩阵的维度
 * @return {number} 最少的乘法运算次数
 */
function matrixChainMultiplication(dimensions) {
  const n = dimensions.length - 1; // 矩阵的数量

  // dp[i][j]表示从第i个矩阵到第j个矩阵的最小乘法次数
  const dp = Array(n).fill().map(() => Array(n).fill(0));
  // 记录最优划分点，用于重建方案
  const split = Array(n).fill().map(() => Array(n).fill(0));

  // 计算不同长度的矩阵链
  for (let len = 2; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1;
      dp[i][j] = Infinity;

      // 尝试在不同位置切分矩阵链
      for (let k = i; k < j; k++) {
        // 当前划分的代价: (A_i...A_k) × (A_{k+1}...A_j)
        const cost = dp[i][k] + dp[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1];
        if (cost < dp[i][j]) {
          dp[i][j] = cost;
          split[i][j] = k; // 记录最优划分点
        }
      }
    }
  }

  // 重建最优方案
  function printOptimalParenthesization(i, j) {
    if (i === j) {
      return `A${i+1}`;
    } else {
      return `(${printOptimalParenthesization(i, split[i][j])} × ${printOptimalParenthesization(split[i][j] + 1, j)})`;
    }
  }

  return {
    minOperations: dp[0][n-1],
    optimalParenthesization: printOptimalParenthesization(0, n-1)
  };
}

// 调用示例
const matrixDimensions = [30, 35, 15, 5, 10, 20, 25];
// 表示6个矩阵：A1(30×35), A2(35×15), A3(15×5), A4(5×10), A5(10×20), A6(20×25)

const matrixResult = matrixChainMultiplication(matrixDimensions);
console.log(`最少乘法次数: ${matrixResult.minOperations}`);
// 输出: 最少乘法次数: 15125

console.log(`最优括号化方案: ${matrixResult.optimalParenthesization}`);
// 输出类似: 最优括号化方案: ((A1 × (A2 × A3)) × ((A4 × A5) × A6))

// 执行过程分析 (简化版):
// 初始化dp[i][i] = 0（单个矩阵不需要乘法）
// 计算长度为2的链:
//   dp[0][1]: A1×A2 = 30×35×15 = 15750
//   dp[1][2]: A2×A3 = 35×15×5 = 2625
//   ...
// 计算长度为3的链:
//   dp[0][2]:
//     k=0: dp[0][0] + dp[1][2] + 30×35×5 = 0 + 2625 + 5250 = 7875
//     k=1: dp[0][1] + dp[2][2] + 30×15×5 = 15750 + 0 + 2250 = 18000
//     取最小值7875，split[0][2] = 0
//   ...
// 继续计算更长的链...
// 最终dp[0][5]是最少乘法次数

// 前端实际应用：数据处理管道优化
function optimizeDataProcessingPipeline(processors, dataFlows) {
  // processors: 处理器数组，表示每个处理阶段
  // dataFlows: 数据流量数组，dataFlows[i]表示第i个处理器的输入规模

  const result = matrixChainMultiplication(dataFlows);

  return {
    minProcessingCost: result.minOperations,
    optimalOrder: result.optimalParenthesization,
    explanation: `按照最优处理顺序可将计算成本从${calculateNaiveCost(dataFlows)}降至${result.minOperations}`
  };
}

// 计算朴素顺序处理的成本 (从左到右)
function calculateNaiveCost(dimensions) {
  let cost = 0;
  for (let i = 0; i < dimensions.length - 2; i++) {
    cost += dimensions[i] * dimensions[i+1] * dimensions[dimensions.length-1];
  }
  return cost;
}

// 模拟数据处理流程
const processingStages = [
  "数据过滤", "排序", "转换", "聚合", "格式化"
];
const dataVolumes = [1000, 800, 500, 200, 350, 100];

const pipelineOptimization = optimizeDataProcessingPipeline(processingStages, dataVolumes);
console.log(`数据处理优化结果: ${JSON.stringify(pipelineOptimization)}`);

// 示例输出:
// 数据处理优化结果: {"minProcessingCost":56000000,"optimalOrder":"((A1 × A2) × ((A3 × A4) × A5))","explanation":"按照最优处理顺序可将计算成本从148000000降至56000000"}
```

#### 最长回文子序列

```javascript
/**
 * @description 寻找最长回文子序列的长度
 * @param {string} s - 输入字符串
 * @return {number} 最长回文子序列的长度
 */
function longestPalindromeSubseq(s) {
  const n = s.length;
  // dp[i][j]表示s[i...j]中最长回文子序列的长度
  const dp = Array(n).fill().map(() => Array(n).fill(0));

  // 单个字符都是长度为1的回文
  for (let i = 0; i < n; i++) {
    dp[i][i] = 1;
  }

  // 计算长度大于1的子序列
  for (let len = 2; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1;
      if (s[i] === s[j]) {
        dp[i][j] = dp[i + 1][j - 1] + 2;
      } else {
        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
      }
    }
  }

  return dp[0][n - 1];
}

/**
 * @description 构建最长回文子序列
 * @param {string} s - 输入字符串
 * @return {string} 最长回文子序列
 */
function buildLongestPalindromeSubseq(s) {
  const n = s.length;
  const dp = Array(n).fill().map(() => Array(n).fill(0));

  for (let i = 0; i < n; i++) {
    dp[i][i] = 1;
  }

  for (let len = 2; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1;
      if (s[i] === s[j]) {
        dp[i][j] = dp[i + 1][j - 1] + 2;
      } else {
        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
      }
    }
  }

  // 根据dp表构建回文子序列
  let result = '';
  function buildSequence(i, j) {
    if (i > j) return;
    if (i === j) {
      result += s[i];
      return;
    }

    if (s[i] === s[j]) {
      result += s[i];
      buildSequence(i + 1, j - 1);
      result += s[j];
    } else if (dp[i + 1][j] >= dp[i][j - 1]) {
      buildSequence(i + 1, j);
    } else {
      buildSequence(i, j - 1);
    }
  }

  buildSequence(0, n - 1);
  return result;
}

// 调用示例
const seq1 = "bbbab";
const seq2 = "cbbd";

console.log(`输入: "${seq1}", 最长回文子序列长度: ${longestPalindromeSubseq(seq1)}`);
// 输出: 输入: "bbbab", 最长回文子序列长度: 4

console.log(`输入: "${seq1}", 最长回文子序列: "${buildLongestPalindromeSubseq(seq1)}"`);
// 输出: 输入: "bbbab", 最长回文子序列: "bbbb"

console.log(`输入: "${seq2}", 最长回文子序列长度: ${longestPalindromeSubseq(seq2)}`);
// 输出: 输入: "cbbd", 最长回文子序列长度: 2

// 执行过程分析 (以"bbbab"为例):
// 初始化所有长度为1的子序列: dp[i][i] = 1
// 计算长度为2的子序列:
//   dp[0][1]: "bb", s[0]==s[1], dp[0][1] = dp[1][0] + 2 = 0 + 2 = 2
//   dp[1][2]: "bb", s[1]==s[2], dp[1][2] = dp[2][1] + 2 = 0 + 2 = 2
//   dp[2][3]: "ba", s[2]!=s[3], dp[2][3] = max(dp[3][3], dp[2][2]) = max(1, 1) = 1
//   dp[3][4]: "ab", s[3]!=s[4], dp[3][4] = max(dp[4][4], dp[3][3]) = max(1, 1) = 1
// 计算长度为3的子序列:
//   dp[0][2]: "bbb", s[0]==s[2], dp[0][2] = dp[1][1] + 2 = 1 + 2 = 3
//   dp[1][3]: "bba", s[1]!=s[3], dp[1][3] = max(dp[2][3], dp[1][2]) = max(1, 2) = 2
//   dp[2][4]: "bab", s[2]==s[4], dp[2][4] = dp[3][3] + 2 = 1 + 2 = 3
// 计算长度为4的子序列:
//   dp[0][3]: "bbba", s[0]!=s[3], dp[0][3] = max(dp[1][3], dp[0][2]) = max(2, 3) = 3
//   dp[1][4]: "bbab", s[1]==s[4], dp[1][4] = dp[2][3] + 2 = 1 + 2 = 3
// 计算长度为5的子序列:
//   dp[0][4]: "bbbab", s[0]==s[4], dp[0][4] = dp[1][3] + 2 = 2 + 2 = 4
// 最终结果: 4 (最长回文子序列为"bbbb")

// 前端实际应用：文档比较工具
function findCommonSymmetricStructure(docA, docB) {
  // 检查两个文档是否有相似的回文结构，可用于比较文档结构的对称性
  const combinedStructure = docA + "#" + docB.split('').reverse().join('');
  const lpsLength = longestPalindromeSubseq(combinedStructure);

  return {
    symmetricSimilarity: lpsLength / Math.min(docA.length, docB.length),
    explanation: `两个文档存在${lpsLength}个元素的对称结构`
  };
}

// 模拟文档结构编码
const docStructureA = "AHBCEHF";
const docStructureB = "FHECHBA";

console.log(`文档结构相似度: ${JSON.stringify(findCommonSymmetricStructure(docStructureA, docStructureB))}`);
// 示例输出:
// 文档结构相似度: {"symmetricSimilarity":0.8571428571428571,"explanation":"两个文档存在6个元素的对称结构"}
```

### 4. 状态压缩DP

```javascript
/**
 * @description 旅行商问题的动态规划解法（小规模）
 * @param {number[][]} graph - 城市间距离矩阵
 * @return {number} 最短路径长度
 */
function tsp(graph) {
  const n = graph.length;
  const ALL_VISITED = (1 << n) - 1;

  // dp[i][j]表示从起点0出发，当前在城市j，已经访问过的城市集合为i的最短路径长度
  const dp = Array(1 << n).fill().map(() => Array(n).fill(Infinity));

  // 初始状态：从城市0出发，已访问城市集合仅包含0
  dp[1][0] = 0;

  // 状态转移
  for (let mask = 1; mask < (1 << n); mask++) {
    for (let u = 0; u < n; u++) {
      // 如果城市u不在已访问集合中，跳过
      if (!(mask & (1 << u))) continue;

      // 前一个状态（去掉城市u）
      const prevMask = mask & ~(1 << u);

      // 如果是起点且不是唯一访问的城市，跳过
      if (u === 0 && prevMask !== 0) continue;

      // 遍历所有可能的前一个城市v
      for (let v = 0; v < n; v++) {
        if (mask & (1 << v) && u !== v) {
          dp[mask][u] = Math.min(dp[mask][u], dp[prevMask][v] + graph[v][u]);
        }
      }
    }
  }

  // 所有城市都访问过，最后回到起点0
  return dp[ALL_VISITED][0];
}
```

## 前端应用场景

### 1. 虚拟DOM的Diff算法

虚拟DOM的Diff算法中，寻找两个树的最小编辑距离可以使用动态规划思想。例如，React的协调算法在比较两棵树时，计算如何以最小的操作将一棵树转换为另一棵树。

```javascript
// 简化版DOM节点比较算法
function minEditDistance(oldNodes, newNodes) {
  const m = oldNodes.length;
  const n = newNodes.length;

  // dp[i][j]表示将oldNodes的前i个节点转换为newNodes的前j个节点所需的最小操作次数
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  // 初始化：删除所有旧节点或插入所有新节点
  for (let i = 1; i <= m; i++) dp[i][0] = i;
  for (let j = 1; j <= n; j++) dp[0][j] = j;

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (nodesEqual(oldNodes[i-1], newNodes[j-1])) {
        // 节点相同，不需要操作
        dp[i][j] = dp[i-1][j-1];
      } else {
        // 取最小操作：替换、删除、插入
        dp[i][j] = 1 + Math.min(
          dp[i-1][j],   // 删除
          dp[i][j-1],   // 插入
          dp[i-1][j-1]  // 替换
        );
      }
    }
  }

  return dp[m][n];
}
```

### 2. 前端路由的最短路径计算

在复杂的前端应用中，计算路由间的最短路径可以使用动态规划，特别是在需要考虑权重和约束条件的情况下。

```javascript
// 前端路由最短路径计算
function shortestRoutePath(routes, start, end, constraints) {
  const n = routes.length;

  // 构建邻接矩阵
  const graph = Array(n).fill().map(() => Array(n).fill(Infinity));
  for (let i = 0; i < n; i++) graph[i][i] = 0;

  // 填充路由连接关系
  for (const [from, to, weight] of constraints) {
    graph[from][to] = weight;
  }

  // Floyd-Warshall算法
  for (let k = 0; k < n; k++) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]);
      }
    }
  }

  return graph[start][end] === Infinity ? null : graph[start][end];
}
```

### 3. 前端缓存策略

LRU（最近最少使用）缓存是一种常用的缓存淘汰策略，它使用动态规划思想来优化缓存使用。

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.map = new Map();
  }

  get(key) {
    if (!this.map.has(key)) return -1;

    const value = this.map.get(key);
    // 更新访问顺序（删除后重新插入到末尾）
    this.map.delete(key);
    this.map.set(key, value);
    return value;
  }

  put(key, value) {
    // 如果已存在，先删除
    if (this.map.has(key)) {
      this.map.delete(key);
    }

    // 如果达到容量上限，删除最久未使用的项（Map的第一个条目）
    if (this.map.size >= this.capacity) {
      const oldestKey = this.map.keys().next().value;
      this.map.delete(oldestKey);
    }

    // 添加新项到末尾
    this.map.set(key, value);
  }
}
```

### 4. 图像处理算法

在前端进行图像处理时，例如图像平滑或边缘检测，可以使用动态规划来优化计算。

```javascript
// 图像平滑算法（3x3均值滤波）
function smoothImage(imageData, width, height) {
  const result = new Uint8ClampedArray(imageData.length);

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0, g = 0, b = 0, count = 0;

      // 3x3邻域
      for (let ny = Math.max(0, y-1); ny <= Math.min(height-1, y+1); ny++) {
        for (let nx = Math.max(0, x-1); nx <= Math.min(width-1, x+1); nx++) {
          const idx = (ny * width + nx) * 4;
          r += imageData[idx];
          g += imageData[idx + 1];
          b += imageData[idx + 2];
          count++;
        }
      }

      const resultIdx = (y * width + x) * 4;
      result[resultIdx] = r / count;
      result[resultIdx + 1] = g / count;
      result[resultIdx + 2] = b / count;
      result[resultIdx + 3] = imageData[(y * width + x) * 4 + 3]; // 保持原Alpha值
    }
  }

  return result;
}
```

## 时间复杂度分析

动态规划算法的时间复杂度通常取决于状态数量和计算每个状态所需的时间：

- 斐波那契数列：O(n)
- 最长递增子序列：O(n²)，可用二分查找优化到O(n log n)
- 0-1背包问题：O(n × capacity)
- 最长回文子串：O(n²)
- 矩阵链乘法：O(n³)
- 状态压缩DP（如旅行商问题）：O(2^n × n²)

## 面试常见问题

1. **如何判断一个问题是否可以使用动态规划求解？**

   **答案**：判断一个问题是否适合用动态规划求解，需要满足以下条件：

   - **最优子结构**：问题的最优解包含其子问题的最优解。例如，最短路径问题中，如果最短路径经过中间点k，那么从起点到k的路径和从k到终点的路径都必须是最短的。

   - **重叠子问题**：在求解过程中，同一个子问题会被多次计算。动态规划通过存储子问题的解来避免重复计算。例如，在计算斐波那契数列F(n)时，F(2)会在计算F(4)、F(5)等过程中被重复计算。

   - **无后效性**：一旦状态确定，未来的决策只与当前状态有关，而与之前的决策过程无关。

   - **问题可以被分解**：原问题可以被分解为子问题，且子问题的解可以递推出原问题的解。

   实践检验：尝试将问题定义为状态，看是否能写出状态转移方程。如果能够清晰地定义状态和状态转移方程，那么问题很可能适合用动态规划求解。

   示例：在"最长递增子序列"问题中，我们可以定义状态dp[i]为"以第i个元素结尾的最长递增子序列长度"，状态转移方程为dp[i] = max(dp[j] + 1)，其中j < i且nums[j] < nums[i]。这满足上述所有条件，因此适合使用动态规划。

2. **动态规划和分治算法的区别是什么？**

   **答案**：动态规划和分治算法都是将问题分解为子问题，但它们有几个关键区别：

   - **子问题的重叠性**：
     - 分治算法：子问题之间相互独立，不重叠。例如，归并排序将数组分为两半，每半独立排序。
     - 动态规划：子问题之间有重叠。例如，斐波那契数列中，F(n) = F(n-1) + F(n-2)，计算F(n-1)和F(n-2)时会重叠计算更小的值。

   - **解决方法**：
     - 分治算法：通常使用递归自顶向下解决，每次将问题分解为不相交的子问题。
     - 动态规划：可以自底向上迭代求解，使用表格存储中间结果，或者自顶向下递归+记忆化。

   - **效率考虑**：
     - 分治算法：当子问题没有重叠时更高效。
     - 动态规划：当存在大量重叠子问题时能显著提高效率。

   - **适用问题**：
     - 分治算法：适用于排序（归并排序、快速排序）、大数乘法等问题。
     - 动态规划：适用于最优化问题，如最短路径、背包问题、最长公共子序列等。

   示例对比：
   ```javascript
   // 分治算法：归并排序
   function mergeSort(arr) {
     if (arr.length <= 1) return arr;
     const mid = Math.floor(arr.length / 2);
     const left = mergeSort(arr.slice(0, mid));  // 子问题1
     const right = mergeSort(arr.slice(mid));    // 子问题2（与子问题1无重叠）
     return merge(left, right);
   }

   // 动态规划：斐波那契数列
   function fibonacci(n) {
     const dp = new Array(n + 1);
     dp[0] = 0;
     dp[1] = 1;
     for (let i = 2; i <= n; i++) {
       dp[i] = dp[i - 1] + dp[i - 2];  // 子问题重叠
     }
     return dp[n];
   }
   ```

3. **如何优化动态规划的空间复杂度？**

   **答案**：优化动态规划的空间复杂度通常有以下几种方法：

   - **滚动数组**：当当前状态只依赖于前面有限个状态时，可以只保留必要的状态。例如，对于斐波那契数列，只需保存前两个状态：

   ```javascript
   function fibonacci(n) {
     if (n <= 1) return n;
     let prev = 0, curr = 1;
     for (let i = 2; i <= n; i++) {
       const next = prev + curr;
       prev = curr;
       curr = next;
     }
     return curr;
   }
   ```

   - **状态压缩**：将二维dp数组压缩为一维。例如，0-1背包问题可以优化为：

   ```javascript
   function knapsackOptimized(weights, values, capacity) {
     const n = weights.length;
     const dp = Array(capacity + 1).fill(0);

     for (let i = 0; i < n; i++) {
       // 注意：必须从大到小遍历，避免一个物品被重复放入
       for (let j = capacity; j >= weights[i]; j--) {
         dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
       }
     }

     return dp[capacity];
   }
   ```

   - **原地更新**：有些问题可以直接在原输入数组上进行状态更新，省去额外空间。例如，路径和问题：

   ```javascript
   function minPathSum(grid) {
     const m = grid.length;
     const n = grid[0].length;

     // 原地更新第一行和第一列
     for (let i = 1; i < m; i++) {
       grid[i][0] += grid[i-1][0];
     }
     for (let j = 1; j < n; j++) {
       grid[0][j] += grid[0][j-1];
     }

     // 原地更新其余格子
     for (let i = 1; i < m; i++) {
       for (let j = 1; j < n; j++) {
         grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);
       }
     }

     return grid[m-1][n-1];
   }
   ```

   - **记忆化搜索**：对于状态庞大且大部分不需要计算的问题，可以使用自顶向下的递归+记忆化，只计算需要的状态：

   ```javascript
   function coinChangeMemorization(coins, amount) {
     // 记忆化数组
     const memo = Array(amount + 1).fill(-1);
     memo[0] = 0;

     function dp(remaining) {
       if (remaining < 0) return -1;
       if (memo[remaining] !== -1) return memo[remaining];

       let minCoins = Infinity;
       for (const coin of coins) {
         const result = dp(remaining - coin);
         if (result >= 0) {
           minCoins = Math.min(minCoins, result + 1);
         }
       }

       memo[remaining] = minCoins === Infinity ? -1 : minCoins;
       return memo[remaining];
     }

     return dp(amount);
   }
   ```

   空间优化的选择取决于具体问题的结构和依赖关系。分析状态之间的依赖，通常可以将空间复杂度从O(n²)降至O(n)，甚至常数空间O(1)。

4. **能否举例说明前端开发中实际应用动态规划的场景？**

   **答案**：动态规划在前端开发中有多种实际应用场景：

   - **文本相似度比较与自动纠错**：使用Levenshtein距离（编辑距离）算法可以实现拼写纠错、搜索推荐等功能。

   ```javascript
   // 编辑距离计算（可用于拼写检查、自动纠错）
   function levenshteinDistance(str1, str2) {
     const m = str1.length;
     const n = str2.length;
     const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

     // 初始化
     for (let i = 0; i <= m; i++) dp[i][0] = i;
     for (let j = 0; j <= n; j++) dp[0][j] = j;

     for (let i = 1; i <= m; i++) {
       for (let j = 1; j <= n; j++) {
         if (str1[i-1] === str2[j-1]) {
           dp[i][j] = dp[i-1][j-1];
         } else {
           dp[i][j] = 1 + Math.min(
             dp[i-1][j],   // 删除
             dp[i][j-1],   // 插入
             dp[i-1][j-1]  // 替换
           );
         }
       }
     }

     return dp[m][n];
   }

   // 应用：搜索建议
   function getSuggestions(query, dictionary, maxDistance = 2) {
     return dictionary.filter(word =>
       levenshteinDistance(query, word) <= maxDistance
     ).sort((a, b) =>
       levenshteinDistance(query, a) - levenshteinDistance(query, b)
     );
   }
   ```

   - **虚拟DOM的差异计算**：框架如React、Vue在比较新旧虚拟DOM时使用类似编辑距离的算法。

   ```javascript
   // 简化版React Reconciliation算法
   function diffVirtualDOM(oldNode, newNode) {
     // 如果节点类型变了，直接替换
     if (oldNode.type !== newNode.type) {
       return { type: 'REPLACE', newNode };
     }

     // 如果是文本节点且内容变了
     if (!oldNode.children && !newNode.children && oldNode.text !== newNode.text) {
       return { type: 'TEXT', text: newNode.text };
     }

     // 比较子节点（简化版）
     if (oldNode.children && newNode.children) {
       const patches = [];
       const maxLen = Math.max(oldNode.children.length, newNode.children.length);

       for (let i = 0; i < maxLen; i++) {
         if (i >= oldNode.children.length) {
           patches.push({ type: 'INSERT', index: i, node: newNode.children[i] });
         } else if (i >= newNode.children.length) {
           patches.push({ type: 'REMOVE', index: i });
         } else {
           const childPatch = diffVirtualDOM(oldNode.children[i], newNode.children[i]);
           if (childPatch) {
             patches.push({ type: 'PATCH', index: i, patch: childPatch });
           }
         }
       }

       return patches.length ? { type: 'CHILDREN', patches } : null;
     }

     return null; // 节点未变化
   }
   ```

   - **前端性能优化**：使用LRU（最近最少使用）缓存算法优化数据缓存，减少网络请求：

   ```javascript
   // LRU缓存实现（用于API响应缓存、组件渲染结果缓存等）
   class LRUCache {
     constructor(capacity) {
       this.capacity = capacity;
       this.cache = new Map();
     }

     get(key) {
       if (!this.cache.has(key)) return undefined;

       // 更新使用顺序
       const value = this.cache.get(key);
       this.cache.delete(key);
       this.cache.set(key, value);
       return value;
     }

     put(key, value) {
       if (this.cache.has(key)) {
         this.cache.delete(key);
       } else if (this.cache.size >= this.capacity) {
         // 删除最久未使用的项（Map的第一个条目）
         const oldestKey = this.cache.keys().next().value;
         this.cache.delete(oldestKey);
       }
       this.cache.set(key, value);
     }
   }

   // 使用示例：API响应缓存
   const apiCache = new LRUCache(100);

   async function fetchData(url, params) {
     const cacheKey = `${url}:${JSON.stringify(params)}`;

     // 检查缓存
     const cachedResult = apiCache.get(cacheKey);
     if (cachedResult) return cachedResult;

     // 获取数据
     const response = await fetch(url, { params });
     const data = await response.json();

     // 存入缓存
     apiCache.put(cacheKey, data);
     return data;
   }
   ```

   - **复杂动画效果计算**：例如，计算渐变路径动画的中间状态：

   ```javascript
   // 路径动画中间点计算
   function calculateAnimationPoints(startPoint, endPoint, steps) {
     const points = [];

     // 复杂路径的中间状态计算（使用曲线函数）
     for (let i = 0; i <= steps; i++) {
       const t = i / steps;
       const x = startPoint.x + (endPoint.x - startPoint.x) * easeInOutCubic(t);
       const y = startPoint.y + (endPoint.y - startPoint.y) * easeInOutCubic(t);
       points.push({ x, y });
     }

     return points;
   }

   // 缓动函数
   function easeInOutCubic(t) {
     return t < 0.5
       ? 4 * t * t * t
       : 1 - Math.pow(-2 * t + 2, 3) / 2;
   }
   ```

   这些例子展示了动态规划思想在前端实际场景中的应用，从文本处理、UI渲染到性能优化和动画计算，动态规划都能提供有效的解决方案。

5. **如何将递归解法转换为动态规划解法？**

   **答案**：将递归解法转换为动态规划解法通常有以下步骤：

   1. **识别状态和状态转移方程**：
      - 分析递归函数的参数，确定状态的定义
      - 明确递归的终止条件，对应动态规划的基础情况
      - 提取递归调用中的状态转移逻辑，转化为状态转移方程

   2. **确定计算顺序**：
      - 分析状态间的依赖关系，确定自底向上的计算顺序
      - 通常递归是自顶向下的，而动态规划一般采用自底向上的迭代方式

   3. **使用数组存储中间结果**：
      - 创建dp数组存储每个状态的结果
      - 确定dp数组的维度（通常与递归函数的参数数量相关）

   4. **优化空间复杂度**：
      - 分析状态转移过程中的依赖关系
      - 如果当前状态只依赖于有限的之前状态，可以使用滚动数组或直接降维

   示例：将递归解法的斐波那契数列转换为动态规划解法

   ```javascript
   // 递归解法
   function fibRecursive(n) {
     // 终止条件
     if (n <= 1) return n;
     // 递归调用
     return fibRecursive(n - 1) + fibRecursive(n - 2);
   }

   // 转换步骤1：使用记忆化优化递归（自顶向下的动态规划）
   function fibMemoization(n) {
     const memo = {};

     function fib(n) {
       // 已经计算过
       if (n in memo) return memo[n];
       // 终止条件
       if (n <= 1) return n;
       // 计算并存储结果
       memo[n] = fib(n - 1) + fib(n - 2);
       return memo[n];
     }

     return fib(n);
   }

   // 转换步骤2：完全迭代方式（自底向上的动态规划）
   function fibDP(n) {
     if (n <= 1) return n;

     // 创建dp数组
     const dp = new Array(n + 1);

     // 设置基础情况
     dp[0] = 0;
     dp[1] = 1;

     // 自底向上填充dp数组
     for (let i = 2; i <= n; i++) {
       dp[i] = dp[i - 1] + dp[i - 2];
     }

     return dp[n];
   }

   // 转换步骤3：空间优化
   function fibDPOptimized(n) {
     if (n <= 1) return n;

     let prev = 0, curr = 1;

     // 只保留必要的状态
     for (let i = 2; i <= n; i++) {
       const next = prev + curr;
       prev = curr;
       curr = next;
     }

     return curr;
   }
   ```

   递归到动态规划的转换不仅提高了效率，还消除了递归可能导致的栈溢出问题。这个过程需要深入理解状态的定义和转移关系，是掌握动态规划的关键步骤。

## 高级动态规划技巧

### 1. 状态定义技巧

选择合适的状态定义是解决动态规划问题的关键。状态定义应该满足：
- 能够表示子问题的解
- 能够从更小的子问题推导出来
- 最终能够得到原问题的解

举例：在"打家劫舍"问题中，可以定义：
```javascript
// dp[i] = 从前i个房屋能偷到的最大金额
function rob(nums) {
  if (!nums.length) return 0;

  const dp = new Array(nums.length + 1);
  dp[0] = 0;
  dp[1] = nums[0];

  for (let i = 2; i <= nums.length; i++) {
    dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
  }

  return dp[nums.length];
}
```

### 2. 维度转换技巧

有时增加状态维度可以简化问题，虽然看起来增加了复杂度，但实际上可能使问题更容易解决：

```javascript
// 股票买卖问题（最多交易k次）
function maxProfit(k, prices) {
  if (!prices.length) return 0;

  const n = prices.length;

  // 当k大于n/2时，问题退化为不限交易次数
  if (k >= Math.floor(n / 2)) {
    let profit = 0;
    for (let i = 1; i < n; i++) {
      if (prices[i] > prices[i-1]) {
        profit += prices[i] - prices[i-1];
      }
    }
    return profit;
  }

  // dp[i][j][0] = 第i天，最多进行j次交易，不持有股票的最大利润
  // dp[i][j][1] = 第i天，最多进行j次交易，持有股票的最大利润
  const dp = Array(n).fill().map(() =>
    Array(k+1).fill().map(() => Array(2).fill(0))
  );

  // 初始化
  for (let j = 0; j <= k; j++) {
    dp[0][j][0] = 0;
    dp[0][j][1] = -prices[0];
  }

  // 填充dp表格
  for (let i = 1; i < n; i++) {
    for (let j = 1; j <= k; j++) {
      // 不持有股票：前一天不持有或前一天持有今天卖出
      dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);
      // 持有股票：前一天持有或前一天不持有今天买入（此时消耗一次交易机会）
      dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i]);
    }
  }

  return dp[n-1][k][0];
}
```

### 3. 前缀和技巧

前缀和是动态规划中常用的优化技巧，可以将某些查询操作的时间复杂度从O(n)降至O(1)：

```javascript
// 区间和查询
function sumRange(nums) {
  const prefixSum = [0];

  // 计算前缀和
  for (let i = 0; i < nums.length; i++) {
    prefixSum[i + 1] = prefixSum[i] + nums[i];
  }

  // 查询函数：O(1)时间复杂度
  return function query(left, right) {
    return prefixSum[right + 1] - prefixSum[left];
  };
}

// 应用：给定一个整数数组和一个整数k，找到该数组中和为k的连续子数组的个数
function subarraySum(nums, k) {
  const prefixSumCount = new Map();
  prefixSumCount.set(0, 1);  // 初始前缀和为0出现1次

  let count = 0;
  let sum = 0;

  for (const num of nums) {
    sum += num;
    // 如果sum-k的前缀和存在，说明存在和为k的子数组
    if (prefixSumCount.has(sum - k)) {
      count += prefixSumCount.get(sum - k);
    }
    // 更新前缀和计数
    prefixSumCount.set(sum, (prefixSumCount.get(sum) || 0) + 1);
  }

  return count;
}
```

## 总结与面试技巧

### 解题模板

在面试中遇到动态规划问题时，可以按照以下步骤思考：

1. **确认是否适合用动态规划**：检查是否具有最优子结构和重叠子问题的特性。

2. **定义状态**：明确dp数组中每个元素的含义，尽量使状态定义简洁明了。

3. **找出状态转移方程**：确定如何从已知状态推导出新状态，这通常是解题的关键。

4. **确定基础情况**：确定初始状态和边界条件。

5. **确定计算顺序**：明确状态依赖关系，确保计算顺序正确。

6. **优化空间复杂度**：如果可能，尝试减少额外空间的使用。

7. **验证解法**：用简单的示例验证算法的正确性。

### 面试回答建议

- **思路清晰**：按照上述步骤逐步讲解思路，展示对问题的分析能力。

- **沟通**：在编写代码前，与面试官沟通状态定义和转移方程，确保方向正确。

- **时空复杂度分析**：主动分析算法的时间和空间复杂度，并思考优化方案。

- **处理边界情况**：注意讨论特殊情况和边界条件的处理方式。

- **代码风格**：编写简洁、易读的代码，适当添加注释说明关键步骤。

动态规划是算法面试中的重要主题，熟练掌握其核心思想和常见应用场景可以在面试中取得优势。通过不断练习各类经典问题，可以建立解决动态规划问题的直觉和模式识别能力。