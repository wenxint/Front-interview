# 查找算法

查找算法是计算机科学中的基础算法，用于在数据集合中查找特定元素。在前端开发中，掌握高效的查找算法可以优化数据处理、DOM操作和状态管理等方面的性能。

## 1. 二分查找

### 1.1 基本概念

二分查找（Binary Search）是一种高效的查找算法，适用于**已排序**的数组。其基本思想是将目标值与数组中间元素比较，通过不断缩小查找范围来定位目标元素。

### 1.2 算法步骤

1. 将待查找区间初始化为整个数组
2. 找到区间的中间元素
3. 将目标值与中间元素比较
   - 如果目标值等于中间元素，查找成功
   - 如果目标值小于中间元素，在左半部分继续查找
   - 如果目标值大于中间元素，在右半部分继续查找
4. 重复步骤2-3直到找到目标值或区间为空

### 1.3 代码实现

```javascript
/**
 * 二分查找 - 迭代版本
 * @param {number[]} arr 已排序的数组
 * @param {number} target 目标值
 * @return {number} 目标值的索引，未找到返回-1
 */
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    // 计算中间索引 (避免整数溢出)
    const mid = left + Math.floor((right - left) / 2);

    // 找到目标值
    if (arr[mid] === target) {
      return mid;
    }

    // 在左半部分继续查找
    if (arr[mid] > target) {
      right = mid - 1;
    }
    // 在右半部分继续查找
    else {
      left = mid + 1;
    }
  }

  // 未找到目标值
  return -1;
}

/**
 * 二分查找 - 递归版本
 * @param {number[]} arr 已排序的数组
 * @param {number} target 目标值
 * @param {number} left 左边界索引
 * @param {number} right 右边界索引
 * @return {number} 目标值的索引，未找到返回-1
 */
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  // 基本情况：未找到目标值
  if (left > right) {
    return -1;
  }

  const mid = left + Math.floor((right - left) / 2);

  // 找到目标值
  if (arr[mid] === target) {
    return mid;
  }

  // 递归查找
  if (arr[mid] > target) {
    return binarySearchRecursive(arr, target, left, mid - 1);
  } else {
    return binarySearchRecursive(arr, target, mid + 1, right);
  }
}

// 调用示例
const sortedArray = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
console.log(binarySearch(sortedArray, 7));  // 输出: 3
console.log(binarySearch(sortedArray, 6));  // 输出: -1
console.log(binarySearchRecursive(sortedArray, 15));  // 输出: 7
console.log(binarySearchRecursive(sortedArray, 20));  // 输出: -1

// 执行过程分析 (以查找值7为例):
// 初始状态: left=0, right=9, 数组长度=10
// 第一次迭代: mid=4, arr[mid]=9 > 7, 在左半部分查找, right=3
// 第二次迭代: mid=1, arr[mid]=3 < 7, 在右半部分查找, left=2
// 第三次迭代: mid=2, arr[mid]=5 < 7, 在右半部分查找, left=3
// 第四次迭代: mid=3, arr[mid]=7 == 7, 找到目标值, 返回索引3
```

### 1.4 时间复杂度和空间复杂度

- **时间复杂度**：O(log n) - 每次比较后，查找范围缩小一半
- **空间复杂度**：
  - 迭代版本：O(1) - 仅使用常数额外空间
  - 递归版本：O(log n) - 由于递归调用栈的开销

**性能对比**：
```javascript
// 二分查找与线性查找性能对比
function performanceComparison(size) {
  // 创建有序数组
  const sortedArray = Array.from({ length: size }, (_, i) => i);
  // 选择一个不存在的目标值
  const target = size + 1;

  console.time('线性查找');
  let found = false;
  for (let i = 0; i < sortedArray.length; i++) {
    if (sortedArray[i] === target) {
      found = true;
      break;
    }
  }
  console.timeEnd('线性查找');

  console.time('二分查找');
  binarySearch(sortedArray, target);
  console.timeEnd('二分查找');
}

// 小规模数据
performanceComparison(1000);
// 中等规模数据
performanceComparison(10000);
// 大规模数据
performanceComparison(1000000);

// 输出示例 (结果可能因设备而异):
// 小规模数据(1000):
// 线性查找: 0.123ms
// 二分查找: 0.021ms
// 中等规模数据(10000):
// 线性查找: 0.346ms
// 二分查找: 0.028ms
// 大规模数据(1000000):
// 线性查找: 13.751ms
// 二分查找: 0.036ms
```

### 1.5 二分查找变种

#### 寻找第一个等于目标值的元素

```javascript
/**
 * 查找第一个等于目标值的元素
 * @param {number[]} arr 已排序的数组
 * @param {number} target 目标值
 * @return {number} 第一个等于目标值的元素索引，未找到返回-1
 */
function findFirstEqual(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);

    if (arr[mid] >= target) {
      right = mid - 1;
      if (arr[mid] === target) {
        result = mid;
      }
    } else {
      left = mid + 1;
    }
  }

  return result;
}

// 调用示例
const arrayWithDuplicates = [1, 2, 3, 3, 3, 4, 5];
console.log(findFirstEqual(arrayWithDuplicates, 3));  // 输出: 2
console.log(findFirstEqual(arrayWithDuplicates, 6));  // 输出: -1

// 执行过程分析 (查找值3的第一个位置):
// 初始状态: left=0, right=6
// 第一次迭代: mid=3, arr[mid]=3 == 3, 记录result=3, right=2
// 第二次迭代: mid=1, arr[mid]=2 < 3, left=2
// 第三次迭代: mid=2, arr[mid]=3 == 3, 记录result=2, right=1
// 循环结束, 返回result=2
```

#### 寻找最后一个等于目标值的元素

```javascript
/**
 * 查找最后一个等于目标值的元素
 * @param {number[]} arr 已排序的数组
 * @param {number} target 目标值
 * @return {number} 最后一个等于目标值的元素索引，未找到返回-1
 */
function findLastEqual(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);

    if (arr[mid] <= target) {
      left = mid + 1;
      if (arr[mid] === target) {
        result = mid;
      }
    } else {
      right = mid - 1;
    }
  }

  return result;
}

// 调用示例
console.log(findLastEqual(arrayWithDuplicates, 3));  // 输出: 4
console.log(findLastEqual(arrayWithDuplicates, 6));  // 输出: -1

// 执行过程分析 (查找值3的最后一个位置):
// 初始状态: left=0, right=6
// 第一次迭代: mid=3, arr[mid]=3 == 3, 记录result=3, left=4
// 第二次迭代: mid=5, arr[mid]=4 > 3, right=4
// 第三次迭代: mid=4, arr[mid]=3 == 3, 记录result=4, left=5
// 第四次迭代: mid=5, arr[mid]=4 > 3, right=4
// 循环结束, 返回result=4
```

#### 寻找第一个大于等于目标值的元素

```javascript
/**
 * 查找第一个大于等于目标值的元素
 * @param {number[]} arr 已排序的数组
 * @param {number} target 目标值
 * @return {number} 第一个大于等于目标值的元素索引，若所有元素都小于target，返回数组长度
 */
function findFirstGreaterOrEqual(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = arr.length; // 若所有元素都小于target，返回数组长度

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);

    if (arr[mid] >= target) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return result;
}

// 调用示例
console.log(findFirstGreaterOrEqual(sortedArray, 8));  // 输出: 4 (arr[4] = 9)
console.log(findFirstGreaterOrEqual(sortedArray, 20)); // 输出: 10 (所有元素都小于20)

// 执行过程分析 (查找第一个大于等于8的位置):
// 初始状态: left=0, right=9, 数组=[1,3,5,7,9,11,13,15,17,19]
// 第一次迭代: mid=4, arr[mid]=9 >= 8, 记录result=4, right=3
// 第二次迭代: mid=1, arr[mid]=3 < 8, left=2
// 第三次迭代: mid=2, arr[mid]=5 < 8, left=3
// 第四次迭代: mid=3, arr[mid]=7 < 8, left=4
// 循环结束, 返回result=4
```

### 1.6 前端实际应用场景

1. **虚拟列表优化**：在处理大型数据列表时，使用二分查找快速定位可视区域的起始和结束索引。

```javascript
/**
 * 在虚拟列表中查找第一个可见项的索引
 * @param {number} scrollTop 滚动位置
 * @param {number} itemHeight 每项高度
 * @param {number} itemCount 总项数
 * @return {number} 第一个可见项的索引
 */
function findFirstVisibleIndex(scrollTop, itemHeight, itemCount) {
  let left = 0;
  let right = itemCount - 1;
  let result = 0;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);
    const itemTop = mid * itemHeight;

    if (itemTop >= scrollTop) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return result;
}

// 调用示例
const scrollPosition = 3500;
const rowHeight = 50;
const totalRows = 10000;

console.log(findFirstVisibleIndex(scrollPosition, rowHeight, totalRows));
// 输出: 70 (从第70项开始显示)

// 实际应用示例:
class VirtualListOptimizer {
  constructor(container, rowHeight, totalItems) {
    this.container = container;
    this.rowHeight = rowHeight;
    this.totalItems = totalItems;
    this.visibleCount = Math.ceil(container.clientHeight / rowHeight) + 2; // 额外渲染2项防止滚动时出现空白
  }

  getVisibleRange(scrollTop) {
    const start = findFirstVisibleIndex(scrollTop, this.rowHeight, this.totalItems);
    const end = Math.min(start + this.visibleCount, this.totalItems - 1);
    return { start, end };
  }

  // 在滚动事件中调用
  onScroll(scrollTop) {
    const { start, end } = this.getVisibleRange(scrollTop);
    console.log(`渲染从${start}到${end}的项`);
    // 渲染可见项...
  }
}
```

2. **自动完成/搜索建议**：在已排序的关键词列表中快速查找匹配项。

```javascript
/**
 * 使用二分查找优化前缀匹配搜索
 * @param {string[]} sortedKeywords 已排序的关键词列表
 * @param {string} prefix 搜索前缀
 * @return {string[]} 匹配的关键词列表
 */
function prefixSearch(sortedKeywords, prefix) {
  if (!prefix) return [];

  // 查找第一个以prefix开头的关键词
  let left = 0;
  let right = sortedKeywords.length - 1;
  let firstMatch = sortedKeywords.length;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);
    if (sortedKeywords[mid].startsWith(prefix)) {
      firstMatch = mid;
      right = mid - 1;
    } else if (sortedKeywords[mid] < prefix) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  // 如果没有匹配项
  if (firstMatch === sortedKeywords.length) {
    return [];
  }

  // 收集所有以prefix开头的关键词
  const results = [];
  for (let i = firstMatch; i < sortedKeywords.length && sortedKeywords[i].startsWith(prefix); i++) {
    results.push(sortedKeywords[i]);
  }

  return results;
}

// 调用示例
const keywords = [
  "angular", "apollo", "axios", "babel",
  "backbone", "bootstrap", "chrome", "css",
  "dart", "dom", "electron", "ember",
  "express", "figma", "firebase", "flutter"
];

console.log(prefixSearch(keywords, "ba"));
// 输出: ["babel", "backbone"]

console.log(prefixSearch(keywords, "f"));
// 输出: ["figma", "firebase", "flutter"]

// 实际应用场景:
// 1. 搜索框自动完成
// 2. IDE代码提示
// 3. 标签输入自动补全
```

## 2. 深度优先搜索 (DFS)

### 2.1 基本概念

深度优先搜索（Depth-First Search，简称DFS）是一种用于遍历或搜索树或图的算法。其特点是沿着一条路径尽可能深入，直到不能再深入为止，然后回溯到前一个节点，继续搜索其他路径。

### 2.2 算法步骤

1. 从起始节点开始，标记为已访问
2. 对于当前节点的每个未访问的相邻节点，递归地应用DFS
3. 如果没有未访问的相邻节点，则回溯

### 2.3 代码实现

#### 递归实现（以树为例）

```javascript
/**
 * 树节点定义
 * @param {number|string} val 节点值
 * @param {TreeNode|null} left 左子节点
 * @param {TreeNode|null} right 右子节点
 */
function TreeNode(val, left, right) {
  this.val = (val === undefined ? 0 : val);
  this.left = (left === undefined ? null : left);
  this.right = (right === undefined ? null : right);
}

/**
 * 前序遍历（根-左-右）
 * @param {TreeNode} root 根节点
 * @return {number[]} 遍历结果数组
 */
function preorderDFS(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    // 访问当前节点
    result.push(node.val);
    // 递归遍历左子树
    traverse(node.left);
    // 递归遍历右子树
    traverse(node.right);
  }

  traverse(root);
  return result;
}

/**
 * 中序遍历（左-根-右）
 * @param {TreeNode} root 根节点
 * @return {number[]} 遍历结果数组
 */
function inorderDFS(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    traverse(node.left);
    result.push(node.val);
    traverse(node.right);
  }

  traverse(root);
  return result;
}

/**
 * 后序遍历（左-右-根）
 * @param {TreeNode} root 根节点
 * @return {number[]} 遍历结果数组
 */
function postorderDFS(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    traverse(node.left);
    traverse(node.right);
    result.push(node.val);
  }

  traverse(root);
  return result;
}

// 创建一个示例二叉树:
//       1
//      / \
//     2   3
//    / \   \
//   4   5   6
const root = new TreeNode(1,
  new TreeNode(2,
    new TreeNode(4),
    new TreeNode(5)
  ),
  new TreeNode(3,
    null,
    new TreeNode(6)
  )
);

console.log("前序遍历:", preorderDFS(root));
// 输出: 前序遍历: [1, 2, 4, 5, 3, 6]

console.log("中序遍历:", inorderDFS(root));
// 输出: 中序遍历: [4, 2, 5, 1, 3, 6]

console.log("后序遍历:", postorderDFS(root));
// 输出: 后序遍历: [4, 5, 2, 6, 3, 1]

// 执行过程分析 (以前序遍历为例):
// 1. 访问根节点(1)，将1加入结果数组
// 2. 递归访问左子树:
//    a. 访问节点2，将2加入结果数组
//    b. 递归访问节点2的左子树:
//       - 访问节点4，将4加入结果数组
//       - 节点4没有子节点，回溯
//    c. 递归访问节点2的右子树:
//       - 访问节点5，将5加入结果数组
//       - 节点5没有子节点，回溯
//    d. 节点2的子节点遍历完毕，回溯
// 3. 递归访问右子树:
//    a. 访问节点3，将3加入结果数组
//    b. 节点3没有左子节点，跳过
//    c. 递归访问节点3的右子树:
//       - 访问节点6，将6加入结果数组
//       - 节点6没有子节点，回溯
//    d. 节点3的子节点遍历完毕，回溯
// 4. 根节点的所有子节点遍历完毕，结束
```

#### 非递归实现（使用栈）

```javascript
/**
 * 前序遍历（非递归）
 * @param {TreeNode} root 根节点
 * @return {number[]} 遍历结果数组
 */
function preorderDFSIterative(root) {
  if (!root) return [];

  const result = [];
  const stack = [root];

  while (stack.length > 0) {
    const node = stack.pop();

    // 访问当前节点
    result.push(node.val);

    // 注意：先压入右子节点，再压入左子节点（因为栈是后进先出）
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }

  return result;
}

/**
 * 中序遍历（非递归）
 * @param {TreeNode} root 根节点
 * @return {number[]} 遍历结果数组
 */
function inorderDFSIterative(root) {
  const result = [];
  const stack = [];
  let current = root;

  while (current || stack.length > 0) {
    // 遍历到最左叶子节点
    while (current) {
      stack.push(current);
      current = current.left;
    }

    // 弹出栈顶元素并访问
    current = stack.pop();
    result.push(current.val);

    // 处理右子树
    current = current.right;
  }

  return result;
}

/**
 * 后序遍历（非递归）
 * @param {TreeNode} root 根节点
 * @return {number[]} 遍历结果数组
 */
function postorderDFSIterative(root) {
  if (!root) return [];

  const result = [];
  const stack = [root];
  const visitedMap = new Map();

  while (stack.length) {
    const node = stack[stack.length - 1]; // 查看栈顶元素，但不弹出

    // 如果当前节点是叶子节点或者其子节点已经被访问过，则访问当前节点
    if ((!node.left && !node.right) ||
        (node.left && visitedMap.get(node.left)) ||
        (node.right && visitedMap.get(node.right))) {
      result.push(node.val);
      visitedMap.set(node, true);
      stack.pop(); // 弹出已访问的节点
    } else {
      // 先将右子节点入栈，再将左子节点入栈（这样左子节点会先被处理）
      if (node.right) stack.push(node.right);
      if (node.left) stack.push(node.left);
    }
  }

  return result;
}

// 对比递归和非递归实现
console.log("递归前序遍历:", preorderDFS(root));
console.log("非递归前序遍历:", preorderDFSIterative(root));
// 输出应相同: [1, 2, 4, 5, 3, 6]

console.log("递归中序遍历:", inorderDFS(root));
console.log("非递归中序遍历:", inorderDFSIterative(root));
// 输出应相同: [4, 2, 5, 1, 3, 6]

console.log("递归后序遍历:", postorderDFS(root));
console.log("非递归后序遍历:", postorderDFSIterative(root));
// 输出应相同: [4, 5, 2, 6, 3, 1]

// 性能对比 (对较大的树结构)
function generateLargeTree(depth) {
  if (depth <= 0) return null;
  return new TreeNode(
    depth,
    generateLargeTree(depth - 1),
    generateLargeTree(depth - 1)
  );
}

const largeTree = generateLargeTree(12); // 深度为12的满二叉树

console.time('递归DFS');
preorderDFS(largeTree);
console.timeEnd('递归DFS');

console.time('非递归DFS');
preorderDFSIterative(largeTree);
console.timeEnd('非递归DFS');

// 输出示例：
// 递归DFS: 10.123ms
// 非递归DFS: 5.456ms
// 注意：非递归版本通常性能更佳，因为避免了函数调用栈的开销
```

### 2.4 时间复杂度和空间复杂度

- **时间复杂度**：O(V + E)，其中V是节点数，E是边数
- **空间复杂度**：O(V)，最坏情况下需要存储所有节点

### 2.5 前端实际应用场景

1. **DOM树遍历和操作**：遍历DOM树查找特定元素或应用样式。

```javascript
/**
 * 使用DFS查找满足条件的所有DOM元素
 * @param {HTMLElement} root 根DOM节点
 * @param {Function} predicate 判断函数
 * @return {HTMLElement[]} 满足条件的DOM元素数组
 */
function findElementsDFS(root, predicate) {
  const results = [];

  function dfs(node) {
    if (!node) return;

    // 检查当前节点是否满足条件
    if (predicate(node)) {
      results.push(node);
    }

    // 递归检查所有子节点
    for (const child of node.children) {
      dfs(child);
    }
  }

  dfs(root);
  return results;
}

// 实际应用示例: 查找包含特定类名的所有元素
function findElementsByClassName(root, className) {
  return findElementsDFS(root, node =>
    node.classList && node.classList.contains(className)
  );
}

// 实际应用示例: 查找所有自定义属性data-testid的元素
function findElementsByTestId(root) {
  return findElementsDFS(root, node => node.hasAttribute('data-testid'));
}

// 调用示例
const elementsWithTestId = findElementsByTestId(document.body);
console.log('找到的测试元素:', elementsWithTestId);

// 查找所有图片并预加载
const allImages = findElementsDFS(document.body, node => node.tagName === 'IMG');
for (const img of allImages) {
  // 预加载图片以提高用户体验
  if (!img.complete) {
    img.loading = 'eager';
  }
}
```

2. **组件树遍历**：在React或Vue等框架中遍历组件树。

```javascript
// React组件树示例 (简化版)
function traverseReactComponentTree(component, callback) {
  // 访问当前组件
  callback(component);

  // 获取子组件引用 (在实际应用中，需使用React内部API)
  const children = React.Children.toArray(component.props.children);

  // 递归遍历子组件
  for (const child of children) {
    if (React.isValidElement(child)) {
      traverseReactComponentTree(child, callback);
    }
  }
}

// Vue组件树示例 (Vue 3)
function traverseVueComponentTree(instance, callback) {
  if (!instance) return;

  // 访问当前组件实例
  callback(instance);

  // 获取子组件
  if (instance.$subTree && instance.$subTree.component) {
    traverseVueComponentTree(instance.$subTree.component, callback);
  }

  // 遍历子组件
  if (instance.$children) {
    for (const child of instance.$children) {
      traverseVueComponentTree(child, callback);
    }
  }
}

// 实际应用场景:
// 1. 查找符合特定条件的组件
// 2. 收集所有组件的特定属性
// 3. 性能分析和调试
// 4. 组件树可视化工具
```

3. **状态管理解析**：在Redux或Vuex中的状态对象深度查找。

```javascript
/**
 * 在嵌套状态对象中查找特定键的所有匹配值
 * @param {Object} state 状态对象
 * @param {string} key 要查找的键
 * @return {Array} 匹配值数组
 */
function findValuesInState(state, key) {
  const results = [];

  function dfs(obj, path = []) {
    if (!obj || typeof obj !== 'object') return;

    for (const [k, v] of Object.entries(obj)) {
      const currentPath = [...path, k];
      if (k === key) {
        results.push({ path: currentPath.join('.'), value: v });
      }
      if (v && typeof v === 'object') {
        dfs(v, currentPath);
      }
    }
  }

  dfs(state);
  return results;
}

// Redux状态示例
const reduxState = {
  auth: {
    user: {
      id: 1,
      name: 'John Doe',
    },
    isAuthenticated: true,
  },
  products: {
    items: [
      { id: 1, name: 'Product A', price: 10, isAvailable: true },
      { id: 2, name: 'Product B', price: 20, isAvailable: false },
    ],
    isLoading: false,
  },
  ui: {
    theme: 'dark',
    isMenuOpen: false,
  }
};

// 查找所有"isAvailable"属性
const availabilityStates = findValuesInState(reduxState, 'isAvailable');
console.log(availabilityStates);
// 输出:
// [
//   { path: 'products.items.0.isAvailable', value: true },
//   { path: 'products.items.1.isAvailable', value: false }
// ]

// 实际应用场景:
// 1. 状态调试工具
// 2. 全局状态变更分析
// 3. 时间旅行调试器
// 4. 状态依赖图生成
```

## 3. 广度优先搜索 (BFS)

### 3.1 基本概念

广度优先搜索（Breadth-First Search，简称BFS）是一种逐层遍历树或图的算法。与DFS不同，BFS优先访问距离起始节点近的节点，然后再访问距离较远的节点。

### 3.2 算法步骤

1. 从起始节点开始，将其加入队列并标记为已访问
2. 当队列非空时，取出队首节点，访问该节点
3. 将该节点的所有未访问的相邻节点加入队列并标记为已访问
4. 重复步骤2-3直到队列为空

### 3.3 代码实现

#### 树的层序遍历

```javascript
/**
 * 二叉树的层序遍历
 * @param {TreeNode} root 根节点
 * @return {number[][]} 每层节点值的数组
 */
function levelOrder(root) {
  if (!root) return [];

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    // 处理当前层的所有节点
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);

      // 将下一层节点加入队列
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }

    result.push(currentLevel);
  }

  return result;
}

// 使用之前创建的示例树
console.log("层序遍历:", levelOrder(root));
// 输出: 层序遍历: [[1], [2, 3], [4, 5, 6]]

// 执行过程分析:
// 1. 初始队列: [1]
// 2. 处理第一层:
//    - 取出节点1，加入结果
//    - 将节点1的子节点2和3加入队列
//    - 队列变为: [2, 3]
//    - 第一层处理完毕，结果: [[1]]
// 3. 处理第二层:
//    - 取出节点2，加入当前层级结果
//    - 将节点2的子节点4和5加入队列
//    - 取出节点3，加入当前层级结果
//    - 将节点3的子节点6加入队列
//    - 队列变为: [4, 5, 6]
//    - 第二层处理完毕，结果: [[1], [2, 3]]
// 4. 处理第三层:
//    - 依次取出节点4、5、6，加入当前层级结果
//    - 这些节点没有子节点
//    - 队列变为空
//    - 第三层处理完毕，结果: [[1], [2, 3], [4, 5, 6]]
// 5. 队列为空，遍历结束
```

#### 图的BFS（邻接表表示）

```javascript
/**
 * 图的广度优先搜索
 * @param {Map<number, number[]>} graph 邻接表表示的图
 * @param {number} start 起始节点
 * @return {number[]} 访问节点的顺序
 */
function bfs(graph, start) {
  const visited = new Set();
  const queue = [start];
  const result = [];

  visited.add(start);

  while (queue.length > 0) {
    const node = queue.shift();
    result.push(node);

    // 访问所有相邻节点
    const neighbors = graph.get(node) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }

  return result;
}

// 创建一个示例图 (邻接表表示)
// 图结构:
// 0 -- 1 -- 3
// |    |
// 2 -- 4
const graph = new Map();
graph.set(0, [1, 2]);
graph.set(1, [0, 3, 4]);
graph.set(2, [0, 4]);
graph.set(3, [1]);
graph.set(4, [1, 2]);

console.log("BFS遍历结果:", bfs(graph, 0));
// 输出: BFS遍历结果: [0, 1, 2, 3, 4]

// 执行过程分析:
// 1. 初始队列: [0], 访问集合: {0}
// 2. 处理节点0:
//    - 取出节点0，加入结果数组
//    - 查找0的相邻节点: [1, 2]
//    - 将节点1和2加入队列，并标记为已访问
//    - 队列变为: [1, 2], 访问集合: {0, 1, 2}
// 3. 处理节点1:
//    - 取出节点1，加入结果数组
//    - 查找1的相邻节点: [0, 3, 4]
//    - 节点0已访问，跳过
//    - 将节点3和4加入队列，并标记为已访问
//    - 队列变为: [2, 3, 4], 访问集合: {0, 1, 2, 3, 4}
// 4. 处理节点2:
//    - 取出节点2，加入结果数组
//    - 查找2的相邻节点: [0, 4]
//    - 节点0和4已访问，跳过
//    - 队列变为: [3, 4]
// 5. 处理节点3:
//    - 取出节点3，加入结果数组
//    - 查找3的相邻节点: [1]
//    - 节点1已访问，跳过
//    - 队列变为: [4]
// 6. 处理节点4:
//    - 取出节点4，加入结果数组
//    - 查找4的相邻节点: [1, 2]
//    - 节点1和2已访问，跳过
//    - 队列变为空
// 7. 队列为空，遍历结束，结果: [0, 1, 2, 3, 4]
```

#### 带距离记录的BFS（最短路径）

```javascript
/**
 * 使用BFS查找最短路径
 * @param {Map<number, number[]>} graph 邻接表表示的图
 * @param {number} start 起始节点
 * @param {number} end 目标节点
 * @return {Object} 包含距离和路径的对象
 */
function shortestPath(graph, start, end) {
  const visited = new Set([start]);
  const queue = [start];
  // 记录每个节点的前一个节点，用于重建路径
  const previous = new Map();
  // 记录到每个节点的距离
  const distance = new Map();
  distance.set(start, 0);

  while (queue.length > 0) {
    const current = queue.shift();

    // 找到目标节点
    if (current === end) {
      break;
    }

    const neighbors = graph.get(current) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
        distance.set(neighbor, distance.get(current) + 1);
        previous.set(neighbor, current);
      }
    }
  }

  // 如果没有找到路径
  if (!distance.has(end)) {
    return { distance: -1, path: [] };
  }

  // 重建路径
  const path = [];
  let current = end;
  while (current !== start) {
    path.unshift(current);
    current = previous.get(current);
  }
  path.unshift(start);

  return {
    distance: distance.get(end),
    path: path
  };
}

// 使用之前创建的示例图
const result = shortestPath(graph, 0, 3);
console.log(`从节点0到节点3的最短距离是: ${result.distance}`);
// 输出: 从节点0到节点3的最短距离是: 2

console.log(`最短路径是: ${result.path.join(' -> ')}`);
// 输出: 最短路径是: 0 -> 1 -> 3

// 尝试另一条路径
const result2 = shortestPath(graph, 2, 3);
console.log(`从节点2到节点3的最短距离是: ${result2.distance}`);
// 输出: 从节点2到节点3的最短距离是: 3

console.log(`最短路径是: ${result2.path.join(' -> ')}`);
// 输出: 最短路径是: 2 -> 0 -> 1 -> 3
```

### 3.4 时间复杂度和空间复杂度

- **时间复杂度**：O(V + E)，其中V是节点数，E是边数
- **空间复杂度**：O(V)，最坏情况下需要存储所有节点

**DFS与BFS性能对比**：
```javascript
// 创建一个大型树以测试性能
function generateWideTree(width, depth) {
  if (depth <= 0) return null;

  const root = new TreeNode(1);
  const queue = [root];

  for (let d = 1; d < depth; d++) {
    const levelSize = queue.length;
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      for (let w = 0; w < width; w++) {
        const child = new TreeNode(d * 100 + w);
        if (w % 2 === 0) {
          node.left = child;
        } else {
          node.right = child;
        }
        queue.push(child);
      }
    }
  }

  return root;
}

// 生成一个宽度为2，深度为10的树
const wideTree = generateWideTree(2, 10);

console.time('BFS耗时');
levelOrder(wideTree);
console.timeEnd('BFS耗时');

console.time('DFS耗时');
preorderDFS(wideTree);
console.timeEnd('DFS耗时');

// 输出示例 (结果可能因设备而异):
// BFS耗时: 3.210ms
// DFS耗时: 2.765ms
// 注意: DFS可能在这种情况下更快，但具体性能取决于树的结构和遍历的目标
```

### 3.5 前端实际应用场景

1. **最短路径问题**：如网络请求的最短路径查找。

```javascript
/**
 * 在网络请求依赖图中查找最短请求路径
 * @param {Map<string, string[]>} dependencies API依赖关系图
 * @param {string} startAPI 起始API
 * @param {string} targetAPI 目标API
 * @return {Object} 包含最短请求路径和请求次数
 */
function findShortestAPIPath(dependencies, startAPI, targetAPI) {
  return shortestPath(dependencies, startAPI, targetAPI);
}

// 模拟API依赖关系
const apiDependencies = new Map();
apiDependencies.set('getUserProfile', ['getUserBasic', 'getUserPreferences']);
apiDependencies.set('getUserBasic', ['getUserAuth', 'getUserMeta']);
apiDependencies.set('getUserPreferences', ['getSystemDefaults', 'getUserSettings']);
apiDependencies.set('getUserSettings', ['getPermissions']);
apiDependencies.set('getUserAuth', ['getPermissions']);
apiDependencies.set('getUserMeta', []);
apiDependencies.set('getSystemDefaults', []);
apiDependencies.set('getPermissions', []);

const apiPath = findShortestAPIPath(apiDependencies, 'getUserProfile', 'getPermissions');
console.log(`从API 'getUserProfile' 到 'getPermissions' 的最短路径:`);
console.log(`路径: ${apiPath.path.join(' -> ')}`);
console.log(`请求次数: ${apiPath.distance}`);

// 输出:
// 从API 'getUserProfile' 到 'getPermissions' 的最短路径:
// 路径: getUserProfile -> getUserBasic -> getUserAuth -> getPermissions
// 请求次数: 3
```

2. **DOM树级联更新**：按层更新DOM元素。

```javascript
/**
 * 按层次更新DOM元素
 * @param {HTMLElement} root 根DOM节点
 * @param {Function} updateFn 更新函数
 */
function updateDOMByLevel(root, updateFn) {
  if (!root) return;

  const queue = [root];
  let level = 0;

  while (queue.length > 0) {
    const levelSize = queue.length;

    console.log(`更新第${level}层的${levelSize}个元素`);

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();

      // 应用更新函数，传入节点和当前层级
      updateFn(node, level);

      // 将所有子元素加入队列
      for (const child of node.children) {
        queue.push(child);
      }
    }

    level++;
  }
}

// 使用示例: 实现一个级联动画效果
function applyCascadingAnimation() {
  const container = document.querySelector('.cascade-container');

  updateDOMByLevel(container, (element, level) => {
    // 根据层级设置动画延迟
    element.style.animationDelay = `${level * 0.1}s`;
    element.classList.add('fade-in');

    // 添加层级标识，方便调试
    element.setAttribute('data-level', level);
  });
}

// 实际应用场景:
// 1. 级联动画效果
// 2. 按层级应用主题
// 3. 按层级渲染大型DOM树
// 4. 性能优化：先渲染可见层，延迟加载深层级元素
```

3. **组件级联渲染**：按层次顺序渲染组件。

```javascript
/**
 * 模拟组件级联渲染函数
 * @param {Component} rootComponent 根组件
 */
function cascadingRender(rootComponent) {
  if (!rootComponent) return;

  const queue = [rootComponent];
  const batchSize = 5; // 每批渲染的组件数
  let currentBatch = 0;

  function processBatch() {
    if (queue.length === 0) return;

    console.log(`处理第${currentBatch}批组件渲染`);
    const size = Math.min(batchSize, queue.length);

    for (let i = 0; i < size; i++) {
      const component = queue.shift();

      // 模拟渲染组件
      console.log(`渲染组件: ${component.name}`);

      // 将子组件加入队列
      if (component.children) {
        for (const child of component.children) {
          queue.push(child);
        }
      }
    }

    currentBatch++;

    // 模拟异步批处理，提高应用响应性
    if (queue.length > 0) {
      setTimeout(processBatch, 0);
    }
  }

  // 开始处理第一批
  processBatch();
}

// 模拟组件结构
const appComponent = {
  name: 'App',
  children: [
    { name: 'Header', children: [
      { name: 'Logo', children: [] },
      { name: 'Navigation', children: [
        { name: 'NavItem1', children: [] },
        { name: 'NavItem2', children: [] }
      ]}
    ]},
    { name: 'Content', children: [
      { name: 'Sidebar', children: [] },
      { name: 'MainContent', children: [
        { name: 'Article', children: [] },
        { name: 'Comments', children: [] }
      ]}
    ]},
    { name: 'Footer', children: [] }
  ]
};

// 调用级联渲染
cascadingRender(appComponent);

// 输出示例:
// 处理第0批组件渲染
// 渲染组件: App
// 处理第1批组件渲染
// 渲染组件: Header
// 渲染组件: Content
// 渲染组件: Footer
// 处理第2批组件渲染
// 渲染组件: Logo
// 渲染组件: Navigation
// 渲染组件: Sidebar
// 渲染组件: MainContent
// 处理第3批组件渲染
// 渲染组件: NavItem1
// 渲染组件: NavItem2
// 渲染组件: Article
// 渲染组件: Comments
```

## 4. 前端应用场景

### 4.1 二分查找的应用

1. **虚拟列表优化**：在处理大型数据列表时，可以使用二分查找快速定位可视区域的起始和结束索引。

```javascript
function findFirstVisibleIndex(items, scrollTop, itemHeight) {
  let left = 0;
  let right = items.length - 1;
  let result = 0;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);
    const itemTop = mid * itemHeight;

    if (itemTop >= scrollTop) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return result;
}
```

2. **自动完成/搜索建议**：在已排序的关键词列表中快速查找匹配项。

3. **日期选择器**：在日期排序列表中定位特定日期。

### 4.2 DFS的应用

1. **DOM树遍历和操作**：遍历DOM树查找特定元素或应用样式。

```javascript
function findElementsByClassName(root, className) {
  const results = [];

  function dfs(node) {
    if (node.classList && node.classList.contains(className)) {
      results.push(node);
    }

    for (const child of node.children) {
      dfs(child);
    }
  }

  dfs(root);
  return results;
}
```

2. **组件树遍历**：在React或Vue等框架中遍历组件树。

3. **状态管理解析**：在Redux或Vuex中的状态对象深度查找。

4. **路径查找问题**：如迷宫、游戏关卡路径等。

### 4.3 BFS的应用

1. **最短路径问题**：如网络请求的最短路径查找。

2. **DOM树级联更新**：按层更新DOM元素。

```javascript
function updateDOMByLevel(root, updateFn) {
  const queue = [root];

  while (queue.length > 0) {
    const size = queue.length;

    for (let i = 0; i < size; i++) {
      const node = queue.shift();
      updateFn(node);

      for (const child of node.children) {
        queue.push(child);
      }
    }
  }
}
```

3. **组件级联渲染**：按层次顺序渲染组件。

4. **网站爬虫**：按层次抓取网站链接。

## 5. 面试常见问题

### 5.1 二分查找相关

1. **二分查找的前提条件是什么？**

   **答案**：二分查找的前提条件是数据必须是有序的（递增或递减排列）。此外，数据结构必须支持随机访问（如数组），不适用于链表等顺序访问的数据结构。

2. **如何在一个旋转排序数组中使用二分查找？**

   **答案**：旋转排序数组是指原本有序的数组被从某个位置旋转，如[4,5,6,7,0,1,2]。在这种情况下，可以先判断中间元素所在的区间是否有序，然后决定在哪个区间继续查找。

   ```javascript
   function searchInRotatedArray(nums, target) {
     let left = 0;
     let right = nums.length - 1;

     while (left <= right) {
       const mid = left + Math.floor((right - left) / 2);

       if (nums[mid] === target) {
         return mid;
       }

       // 判断左半部分是否有序
       if (nums[left] <= nums[mid]) {
         // 目标值在有序的左半部分
         if (nums[left] <= target && target < nums[mid]) {
           right = mid - 1;
         } else {
           left = mid + 1;
         }
       }
       // 右半部分有序
       else {
         // 目标值在有序的右半部分
         if (nums[mid] < target && target <= nums[right]) {
           left = mid + 1;
         } else {
           right = mid - 1;
         }
       }
     }

     return -1;
   }
   ```

3. **二分查找的边界条件如何处理？**

   **答案**：二分查找的边界条件主要有以下几个：
   - 循环条件：使用 `left <= right` 还是 `left < right`
   - 中间值计算：`mid = left + (right - left) / 2` 避免整数溢出
   - 更新边界：当 `arr[mid] > target` 时，使用 `right = mid - 1` 还是 `right = mid`
   - 返回值：查找失败时返回什么值（通常是-1或目标值应该插入的位置）

   这些边界条件的选择取决于具体需求，如查找第一个或最后一个满足条件的元素。

### 5.2 DFS和BFS相关

1. **DFS和BFS各自的优缺点是什么？**

   **答案**：

   **DFS优点**：
   - 实现简单，尤其是使用递归时
   - 内存占用相对较小（在广度较大的树/图中）
   - 适合查找离起点较远的结果
   - 可以方便地生成全部解决方案

   **DFS缺点**：
   - 可能陷入很深的路径而错过更优解
   - 不保证找到最短路径
   - 在解空间很大时可能导致栈溢出

   **BFS优点**：
   - 保证找到最短路径（在边权重相同的情况下）
   - 适合查找离起点较近的结果
   - 不会陷入无限递归的风险

   **BFS缺点**：
   - 内存消耗较大，尤其是在广度较大的树/图中
   - 实现相对复杂
   - 对于深度很大的结构，可能效率较低

   选择使用哪种算法取决于具体问题的性质和要求。

2. **如何判断一个二叉树是否是平衡二叉树？**

   **答案**：平衡二叉树是指任意节点的左右子树高度差不超过1的二叉树。可以使用DFS自底向上地计算高度：

   ```javascript
   function isBalanced(root) {
     // 返回高度，如果不平衡则返回-1
     function getHeight(node) {
       if (!node) return 0;

       const leftHeight = getHeight(node.left);
       if (leftHeight === -1) return -1;

       const rightHeight = getHeight(node.right);
       if (rightHeight === -1) return -1;

       // 检查高度差
       if (Math.abs(leftHeight - rightHeight) > 1) {
         return -1;
       }

       return Math.max(leftHeight, rightHeight) + 1;
     }

     return getHeight(root) !== -1;
   }
   ```

3. **在前端开发中，什么情况下使用BFS比DFS更合适？**

   **答案**：
   - 需要按层级处理DOM节点时（如级联样式或动画）
   - 寻找最近的满足条件的元素时
   - 需要考虑节点间距离时（如事件冒泡路径的最短路径）
   - 实现广度优先的渲染策略时
   - 在内存有限的情况下处理较浅但宽度大的树结构时

   例如，当实现一个点击事件处理器，需要找到最近的带有特定属性的父元素时，BFS比DFS更为合适。

### 5.3 综合问题

1. **如何优化大数据量下的查找操作？**

   **答**：优化大数据量下查找操作的策略包括：

   1. **使用合适的数据结构**
      - 使用哈希表(Map)进行O(1)的查找
      - 对有序数据使用二分查找
      - 使用前缀树(Trie)优化字符串查找
      - 对于区间查找，使用线段树或索引结构

   2. **分批处理与虚拟化**
      - 实现虚拟列表，只渲染可见部分
      - 分页加载和处理数据
      - 使用无限滚动替代一次性加载

   3. **并行计算与缓存**
      - 使用Web Workers进行并行搜索
      - 缓存常用查询结果
      - 使用IndexedDB存储和索引大型数据集

   4. **算法优化**
      - 使用二分法定位虚拟列表的可视区域
      - 实现模糊匹配的高效算法
      - 使用空间换时间的策略，预计算并存储中间结果

   ```javascript
   // 大数据量下的查找优化示例

   // 1. 使用哈希表优化查找
   function optimizedLookup(items, idToFind) {
     // 创建ID到对象的映射
     const idMap = new Map();
     for (const item of items) {
       idMap.set(item.id, item);
     }

     // O(1)时间复杂度的查找
     return idMap.get(idToFind) || null;
   }

   // 2. 虚拟列表中的二分查找优化
   class VirtualList {
     constructor(data, itemHeight) {
       this.data = data; // 假设已排序
       this.itemHeight = itemHeight;
       this.visibleCount = Math.ceil(window.innerHeight / itemHeight);
       this.container = document.querySelector('.virtual-list-container');

       this.setupScroll();
     }

     // 使用二分查找确定滚动位置对应的起始索引
     findStartIndex(scrollTop) {
       let left = 0;
       let right = this.data.length - 1;
       let result = 0;

       // 二分查找比线性查找更高效
       while (left <= right) {
         const mid = left + Math.floor((right - left) / 2);
         const offset = mid * this.itemHeight;

         if (offset <= scrollTop) {
           result = mid;
           left = mid + 1;
         } else {
           right = mid - 1;
         }
       }

       return Math.max(0, result);
     }

     renderItems(scrollTop) {
       const startIndex = this.findStartIndex(scrollTop);
       const endIndex = Math.min(
         startIndex + this.visibleCount + 5, // 额外渲染5项防止滚动时出现空白
         this.data.length - 1
       );

       // 渲染可见区域内的项目
       this.container.innerHTML = '';
       for (let i = startIndex; i <= endIndex; i++) {
         const item = document.createElement('div');
         item.className = 'list-item';
         item.style.height = `${this.itemHeight}px`;
         item.style.top = `${i * this.itemHeight}px`;
         item.textContent = this.data[i].text;
         this.container.appendChild(item);
       }
     }

     setupScroll() {
       this.container.style.height = `${this.data.length * this.itemHeight}px`;
       window.addEventListener('scroll', () => {
         requestAnimationFrame(() => {
           this.renderItems(window.scrollY);
         });
       });

       // 初始渲染
       this.renderItems(0);
     }
   }

   // 3. Web Worker优化大数据搜索
   function setupSearchWithWorker() {
     // 创建一个Web Worker以不阻塞UI线程
     const searchWorker = new Worker('search-worker.js');

     searchWorker.onmessage = function(e) {
       const { results, searchId } = e.data;
       // 更新UI显示搜索结果
       displayResults(results, searchId);
     };

     // 防抖处理搜索输入
     const searchInput = document.getElementById('search-input');
     let debounceTimer;
     let searchCounter = 0;

     searchInput.addEventListener('input', function() {
       clearTimeout(debounceTimer);
       const searchText = this.value;
       const currentSearchId = ++searchCounter;

       debounceTimer = setTimeout(() => {
         // 发送搜索请求到worker
         searchWorker.postMessage({
           searchText,
           searchId: currentSearchId
         });
       }, 300);
     });
   }

   // search-worker.js 内容
   /*
   self.addEventListener('message', function(e) {
     const { searchText, searchId } = e.data;
     let results = [];

     // 这里假设largeDateArray是已经加载到worker中的大型数据集
     if (searchText) {
       // 对大型数据集执行搜索，可以使用二分查找、前缀树等优化方法
       results = searchInLargeDataArray(searchText);
     }

     // 将结果发送回主线程
     self.postMessage({ results, searchId });
   });
   */

   // 性能对比: 普通搜索 vs. 优化搜索
   function performanceComparison() {
     // 创建大型测试数据
     const largeData = Array.from({ length: 100000 }, (_, i) => ({
       id: i,
       text: `Item ${i}`,
       tags: [`tag-${i % 50}`, `category-${i % 10}`]
     }));

     const targetId = 75000;

     console.time('普通线性查找');
     const resultLinear = largeData.find(item => item.id === targetId);
     console.timeEnd('普通线性查找');

     console.time('使用Map优化的查找');
     const idMap = new Map(largeData.map(item => [item.id, item]));
     const resultMap = idMap.get(targetId);
     console.timeEnd('使用Map优化的查找');

     console.log('结果匹配:', resultLinear === resultMap);

     // 输出示例:
     // 普通线性查找: 9.123ms
     // 使用Map优化的查找: 0.045ms
     // 结果匹配: true
   }
   ```

2. **如何在前端实现一个高效的搜索建议功能？**

   **答**：实现高效搜索建议功能需要综合多种优化策略：

   1. **数据结构选择**
      - 使用前缀树(Trie)存储候选词，实现快速前缀匹配
      - 对于已排序的建议列表，使用二分查找定位起始匹配位置

   2. **性能优化**
      - 实现输入防抖/节流，减少搜索请求频率
      - 缓存常见查询结果
      - 分批异步加载建议列表
      - 使用Web Worker进行后台搜索计算

   3. **用户体验优化**
      - 优先显示历史搜索或热门搜索
      - 支持模糊匹配和容错搜索
      - 提供键盘导航功能
      - 实现精确度排序

   ```javascript
   /**
    * 高效的搜索建议实现
    */
   class SearchSuggestion {
     constructor(options = {}) {
       this.options = {
         minChars: options.minChars || 2,      // 开始显示建议的最小字符数
         maxResults: options.maxResults || 10,  // 最大结果数量
         debounceTime: options.debounceTime || 200, // 防抖延迟时间
         ...options
       };

       this.dictionary = options.dictionary || [];
       this.historicalSearches = options.historical || [];
       this.trie = this.buildTrie(this.dictionary);
       this.cache = new Map(); // 查询结果缓存

       this.setupEventListeners();
     }

     /**
      * 构建前缀树(Trie)以实现高效前缀搜索
      * @param {string[]} words 字典词汇
      * @return {Object} 前缀树结构
      */
     buildTrie(words) {
       const root = {};

       for (const word of words) {
         let node = root;
         for (const char of word.toLowerCase()) {
           if (!node[char]) {
             node[char] = {};
           }
           node = node[char];
         }
         node.isEndOfWord = true;
         node.word = word; // 存储原始单词
       }

       return root;
     }

     /**
      * 在前缀树中搜索匹配前缀的单词
      * @param {string} prefix 搜索前缀
      * @return {string[]} 匹配的单词列表
      */
     searchInTrie(prefix) {
       const results = [];
       const lowerPrefix = prefix.toLowerCase();

       // 查找前缀的末端节点
       let node = this.trie;
       for (const char of lowerPrefix) {
         if (!node[char]) {
           return results; // 没有匹配的前缀
         }
         node = node[char];
       }

       // 收集从此节点开始的所有单词
       this.collectWords(node, results);
       return results.slice(0, this.options.maxResults);
     }

     /**
      * 从给定节点收集所有单词
      * @param {Object} node Trie节点
      * @param {string[]} results 结果集合
      */
     collectWords(node, results) {
       if (node.isEndOfWord) {
         results.push(node.word);
       }

       for (const char in node) {
         if (char !== 'isEndOfWord' && char !== 'word') {
           this.collectWords(node[char], results);
         }
       }
     }

     /**
      * 获取搜索建议
      * @param {string} query 查询字符串
      * @return {Promise<string[]>} 建议列表
      */
     async getSuggestions(query) {
       if (!query || query.length < this.options.minChars) {
         return this.getHistoricalOrPopular();
       }

       // 检查缓存
       if (this.cache.has(query)) {
         return this.cache.get(query);
       }

       // 使用前缀树查找
       const suggestions = this.searchInTrie(query);

       // 如果本地结果不足，可以添加API调用获取更多建议
       if (suggestions.length < this.options.maxResults && this.options.apiCallback) {
         try {
           const apiSuggestions = await this.options.apiCallback(query);
           // 合并去重结果
           const combined = [...suggestions];
           for (const suggestion of apiSuggestions) {
             if (!combined.includes(suggestion)) {
               combined.push(suggestion);
               if (combined.length >= this.options.maxResults) break;
             }
           }
           this.cache.set(query, combined);
           return combined;
         } catch (error) {
           console.error('API建议获取失败', error);
         }
       }

       this.cache.set(query, suggestions);
       return suggestions;
     }

     /**
      * 获取历史搜索或热门搜索
      * @return {string[]} 建议列表
      */
     getHistoricalOrPopular() {
       // 优先返回历史搜索
       if (this.historicalSearches.length > 0) {
         return this.historicalSearches.slice(0, this.options.maxResults);
       }

       // 如果没有历史搜索，返回热门搜索
       if (this.options.popularSearches) {
         return this.options.popularSearches.slice(0, this.options.maxResults);
       }

       return [];
     }

     /**
      * 设置事件监听
      */
     setupEventListeners() {
       const input = document.getElementById(this.options.inputId);
       const suggestionBox = document.getElementById(this.options.suggestionBoxId);

       if (!input || !suggestionBox) return;

       let debounceTimer;

       input.addEventListener('input', (e) => {
         clearTimeout(debounceTimer);

         debounceTimer = setTimeout(async () => {
           const query = e.target.value.trim();
           const suggestions = await this.getSuggestions(query);

           // 渲染建议列表
           this.renderSuggestions(suggestions, query, suggestionBox);
         }, this.options.debounceTime);
       });

       // 添加键盘导航和选择功能
       input.addEventListener('keydown', (e) => {
         // 处理上下箭头、回车等键盘操作
         this.handleKeyboardNavigation(e, suggestionBox);
       });

       // 点击建议项
       suggestionBox.addEventListener('click', (e) => {
         if (e.target.classList.contains('suggestion-item')) {
           input.value = e.target.textContent;
           suggestionBox.innerHTML = '';

           // 添加到历史搜索
           this.addToHistoricalSearches(e.target.textContent);

           if (this.options.onSelect) {
             this.options.onSelect(e.target.textContent);
           }
         }
       });
     }

     /**
      * 渲染建议列表
      * @param {string[]} suggestions 建议列表
      * @param {string} query 查询字符串
      * @param {HTMLElement} container 容器元素
      */
     renderSuggestions(suggestions, query, container) {
       container.innerHTML = '';

       if (suggestions.length === 0) {
         container.style.display = 'none';
         return;
       }

       for (const suggestion of suggestions) {
         const item = document.createElement('div');
         item.className = 'suggestion-item';

         // 高亮匹配部分
         if (query) {
           const index = suggestion.toLowerCase().indexOf(query.toLowerCase());
           if (index >= 0) {
             item.innerHTML = `${suggestion.substring(0, index)}<strong>${suggestion.substring(index, index + query.length)}</strong>${suggestion.substring(index + query.length)}`;
           } else {
             item.textContent = suggestion;
           }
         } else {
           item.textContent = suggestion;
         }

         container.appendChild(item);
       }

       container.style.display = 'block';
     }

     /**
      * 处理键盘导航
      * @param {KeyboardEvent} event 键盘事件
      * @param {HTMLElement} suggestionBox 建议容器
      */
     handleKeyboardNavigation(event, suggestionBox) {
       const items = suggestionBox.querySelectorAll('.suggestion-item');
       const input = document.getElementById(this.options.inputId);

       if (items.length === 0) return;

       const active = suggestionBox.querySelector('.active');
       let index = -1;

       if (active) {
         index = Array.from(items).indexOf(active);
       }

       switch (event.key) {
         case 'ArrowDown':
           event.preventDefault();
           index = (index + 1) % items.length;
           break;
         case 'ArrowUp':
           event.preventDefault();
           index = (index - 1 + items.length) % items.length;
           break;
         case 'Enter':
           if (active) {
             event.preventDefault();
             input.value = active.textContent;
             suggestionBox.innerHTML = '';
             this.addToHistoricalSearches(active.textContent);
             if (this.options.onSelect) {
               this.options.onSelect(active.textContent);
             }
           }
           return;
         case 'Escape':
           suggestionBox.innerHTML = '';
           return;
         default:
           return;
       }

       // 更新活动项
       if (active) active.classList.remove('active');
       items[index].classList.add('active');
       items[index].scrollIntoView({ block: 'nearest' });
     }

     /**
      * 添加到历史搜索
      * @param {string} search 搜索词
      */
     addToHistoricalSearches(search) {
       // 移除已存在的相同搜索词
       const index = this.historicalSearches.indexOf(search);
       if (index !== -1) {
         this.historicalSearches.splice(index, 1);
       }

       // 添加到最前面
       this.historicalSearches.unshift(search);

       // 限制历史记录长度
       if (this.historicalSearches.length > 20) {
         this.historicalSearches.pop();
       }

       // 如果配置了持久化，保存到本地存储
       if (this.options.persistHistory) {
         localStorage.setItem('searchHistory', JSON.stringify(this.historicalSearches));
       }
     }
   }

   // 使用示例
   const searchSuggestions = new SearchSuggestion({
     inputId: 'search-input',
     suggestionBoxId: 'suggestions-container',
     dictionary: ['javascript', 'typescript', 'react', 'redux', 'vue', 'angular', 'svelte', 'node', 'express', 'mongodb', 'graphql'],
     popularSearches: ['javascript tutorial', 'react hooks', 'typescript setup'],
     persistHistory: true,
     onSelect: (selected) => {
       console.log(`用户选择了: ${selected}`);
       // 执行搜索或导航
     }
   });
   ```

## 6. 学习资源

### 6.1 官方文档与教程

- [二分查找详解 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
- [深度优先搜索与广度优先搜索 - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/)
- [JavaScript数据结构与算法 - GitHub](https://github.com/trekhleb/javascript-algorithms)
- [LeetCode查找算法专题](https://leetcode.com/tag/binary-search/)
- [前端算法与数据结构 - 掘金](https://juejin.cn/post/6844903776512393224)

### 6.2 进阶学习资料

- [算法可视化 - VisuAlgo](https://visualgo.net/)：通过交互式动画可视化各种算法
- [Algorithms, 4th Edition](https://algs4.cs.princeton.edu/)：普林斯顿大学算法课程，提供Java实现
- [算法导论在线课程 - MIT](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/)
- [函数式编程中的树遍历 - FrontendMasters](https://frontendmasters.com/courses/trees-and-graphs/)

### 6.3 练习平台

- [LeetCode](https://leetcode.com/)：提供丰富的算法练习题
- [HackerRank](https://www.hackerrank.com/)：各种难度级别的编程挑战
- [CodeSignal](https://codesignal.com/)：包含面试准备和技能评估的编程挑战
- [前端常见面试算法题集 - GitHub](https://github.com/azl397985856/leetcode)：针对前端工程师的算法题解析

### 6.4 推荐书籍

- 《学习JavaScript数据结构与算法》 - Loiane Groner
- 《算法图解》 - Aditya Bhargava
- 《JavaScript高级程序设计》(第4版) - Matt Frisbie
- 《编程珠玑》 - Jon Bentley

通过系统学习和实践这些资源，你将能够掌握各种查找算法，并在前端开发中灵活应用，提升代码质量和性能。