# 链表

## 基本概念

链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用（指针）。与数组不同，链表中的元素在内存中不是连续存储的，这使得它在某些操作上具有优势。

### 链表的特点

- 动态数据结构，可以根据需要增长或缩小
- 插入和删除操作效率高（不需要移动其他元素）
- 随机访问效率低（需要从头遍历）
- 不需要预先分配内存空间

### 链表的类型

1. **单向链表**：每个节点只有一个指向下一个节点的引用
2. **双向链表**：每个节点有两个引用，分别指向前一个和后一个节点
3. **循环链表**：最后一个节点指向第一个节点，形成一个环
4. **双向循环链表**：结合了双向链表和循环链表的特性

## JavaScript实现

### 单向链表

```javascript
/**
 * 链表节点类
 * @class Node
 */
class Node {
  /**
   * 链表节点类
   * @class Node
   */
  /**
   * 创建链表节点
   * @param {any} data - 节点存储的数据
   */
  constructor(data) {
    this.data = data; // 存储当前节点的数据
    this.next = null; // 指向下一个节点的引用，初始为null
  }
}

/**
 * 单向链表类
 * @class LinkedList
 */
class LinkedList {
  /**
   * 单向链表类
   * @class LinkedList
   */
  /**
   * 创建一个空链表
   */
  constructor() {
    this.head = null; // 链表头节点引用
    this.size = 0; // 链表节点数量
  }

  /**
   * 在链表末尾添加节点
   * @param {any} data - 要添加的数据
   */
  append(data) {
    const newNode = new Node(data); // 创建新节点

    if (!this.head) { // 链表为空时
      this.head = newNode; // 头节点指向新节点
    } else {
      let current = this.head; // 从头部开始遍历
      while (current.next) { // 找到最后一个节点
        current = current.next;
      }
      current.next = newNode; // 最后一个节点的next指向新节点
    }

    this.size++; // 链表长度加1
  }

  /**
   * 在指定位置插入节点
   * @param {any} data - 要插入的数据
   * @param {number} position - 插入位置（从0开始）
   * @return {boolean} 插入是否成功
   */
  /**
   * 在指定位置插入节点
   * @param {any} data - 要插入的数据
   * @param {number} position - 插入位置（从0开始）
   * @return {boolean} 插入是否成功
   */
  insert(data, position) {
    if (position < 0 || position > this.size) { // 检查位置有效性
      return false;
    }

    const newNode = new Node(data); // 创建新节点

    if (position === 0) { // 插入到头部
      newNode.next = this.head; // 新节点的next指向原头节点
      this.head = newNode; // 头节点更新为新节点
    } else {
      let current = this.head; // 当前节点指针
      let previous = null; // 前一个节点指针
      let index = 0;

      while (index < position) { // 遍历到目标位置
        previous = current;
        current = current.next;
        index++;
      }

      newNode.next = current; // 新节点的next指向当前节点
      previous.next = newNode; // 前一个节点的next指向新节点
    }

    this.size++; // 链表长度加1
    return true;
  }

  /**
   * 移除指定位置的节点
   * @param {number} position - 要移除的位置
   * @return {any} 被移除节点的数据，如果删除失败则返回null
   */
  removeAt(position) {
    if (position < 0 || position >= this.size || !this.head) {
      return null;
    }

    let current = this.head;

    if (position === 0) {
      this.head = current.next;
    } else {
      let previous = null;
      let index = 0;

      while (index < position) {
        previous = current;
        current = current.next;
        index++;
      }

      previous.next = current.next;
    }

    this.size--;
    return current.data;
  }

  /**
   * 查找元素的索引
   * @param {any} data - 要查找的数据
   * @return {number} 元素的索引，如果不存在则返回-1
   */
  indexOf(data) {
    let current = this.head;
    let index = 0;

    while (current) {
      if (current.data === data) {
        return index;
      }
      current = current.next;
      index++;
    }

    return -1;
  }

  /**
   * 移除指定元素
   * @param {any} data - 要移除的数据
   * @return {any} 被移除的数据，如果不存在则返回null
   */
  remove(data) {
    const index = this.indexOf(data);
    return this.removeAt(index);
  }

  /**
   * 判断链表是否为空
   * @return {boolean} 链表是否为空
   */
  isEmpty() {
    return this.size === 0;
  }

  /**
   * 获取链表大小
   * @return {number} 链表中的节点数量
   */
  getSize() {
    return this.size;
  }

  /**
   * 获取链表的字符串表示
   * @return {string} 链表的字符串表示
   */
  toString() {
    if (!this.head) {
      return '';
    }

    let string = `${this.head.data}`;
    let current = this.head.next;

    while (current) {
      string = `${string},${current.data}`;
      current = current.next;
    }

    return string;
  }
}

// 调用示例
const list = new LinkedList();
list.append(10);
list.append(20);
list.append(30);
console.log(list.toString()); // "10,20,30"

list.insert(15, 1);
console.log(list.toString()); // "10,15,20,30"

console.log(list.removeAt(2)); // 20
console.log(list.toString()); // "10,15,30"

console.log(list.indexOf(15)); // 1
console.log(list.remove(15)); // 15
console.log(list.toString()); // "10,30"

console.log(list.isEmpty()); // false
console.log(list.getSize()); // 2
```

### 双向链表

```javascript
/**
 * 双向链表节点类
 * @class DoublyNode
 */
class DoublyNode {
  /**
   * 双向链表节点类
   * @class DoublyNode
   */
  /**
   * 创建双向链表节点
   * @param {any} data - 节点存储的数据
   */
  constructor(data) {
    this.data = data; // 存储当前节点的数据
    this.prev = null; // 指向前一个节点的引用，初始为null
    this.next = null; // 指向下一个节点的引用，初始为null
  }
}

/**
 * 双向链表类
 * @class DoublyLinkedList
 */
class DoublyLinkedList {
  /**
   * 双向链表类
   * @class DoublyLinkedList
   */
  /**
   * 创建一个空的双向链表
   */
  constructor() {
    this.head = null; // 链表头节点引用
    this.tail = null; // 链表尾节点引用
    this.size = 0; // 链表节点数量
  }

  /**
   * 在链表末尾添加节点
   * @param {any} data - 要添加的数据
   */
  append(data) {
    const newNode = new DoublyNode(data); // 创建新节点

    if (!this.head) { // 链表为空时
      this.head = newNode; // 头尾节点都指向新节点
      this.tail = newNode;
    } else {
      newNode.prev = this.tail; // 新节点的prev指向原尾节点
      this.tail.next = newNode; // 原尾节点的next指向新节点
      this.tail = newNode; // 尾节点更新为新节点
    }

    this.size++; // 链表长度加1
  }

  /**
   * 在链表开头添加节点
   * @param {any} data - 要添加的数据
   */
  prepend(data) {
    const newNode = new DoublyNode(data);

    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
    }

    this.size++;
  }

  /**
   * 在指定位置插入节点
   * @param {any} data - 要插入的数据
   * @param {number} position - 插入位置（从0开始）
   * @return {boolean} 插入是否成功
   */
  insert(data, position) {
    if (position < 0 || position > this.size) {
      return false;
    }

    if (position === 0) {
      this.prepend(data);
      return true;
    }

    if (position === this.size) {
      this.append(data);
      return true;
    }

    const newNode = new DoublyNode(data);

    // 寻找要插入的位置
    let current;
    if (position < this.size / 2) {
      // 从头部开始查找更高效
      current = this.head;
      let index = 0;
      while (index < position) {
        current = current.next;
        index++;
      }
    } else {
      // 从尾部开始查找更高效
      current = this.tail;
      let index = this.size - 1;
      while (index > position) {
        current = current.prev;
        index--;
      }
    }

    // 插入节点
    newNode.prev = current.prev;
    newNode.next = current;
    current.prev.next = newNode;
    current.prev = newNode;
    this.size++;

    return true;
  }

  /**
   * 移除指定位置的节点
   * @param {number} position - 要移除的位置
   * @return {any} 被移除节点的数据，如果删除失败则返回null
   */
  removeAt(position) {
    if (position < 0 || position >= this.size || !this.head) {
      return null;
    }

    let current = this.head;

    // 移除头部节点
    if (position === 0) {
      this.head = current.next;

      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
    }
    // 移除尾部节点
    else if (position === this.size - 1) {
      current = this.tail;
      this.tail = current.prev;
      this.tail.next = null;
    }
    // 移除中间节点
    else {
      // 确定从哪端开始遍历更高效
      if (position < this.size / 2) {
        let index = 0;
        while (index < position) {
          current = current.next;
          index++;
        }
      } else {
        current = this.tail;
        let index = this.size - 1;
        while (index > position) {
          current = current.prev;
          index--;
        }
      }

      current.prev.next = current.next;
      current.next.prev = current.prev;
    }

    this.size--;
    return current.data;
  }

  /**
   * 获取链表的字符串表示
   * @return {string} 链表的字符串表示
   */
  toString() {
    if (!this.head) {
      return '';
    }

    let string = `${this.head.data}`;
    let current = this.head.next;

    while (current) {
      string = `${string},${current.data}`;
      current = current.next;
    }

    return string;
  }
}

// 调用示例
const doublyList = new DoublyLinkedList();
doublyList.append(10);
doublyList.append(20);
doublyList.prepend(5);
console.log(doublyList.toString()); // "5,10,20"

doublyList.insert(15, 2);
console.log(doublyList.toString()); // "5,10,15,20"

console.log(doublyList.removeAt(1)); // 10
console.log(doublyList.toString()); // "5,15,20"
```

**执行结果解析**：
1. 创建了一个空的双向链表，在末尾添加了10和20，在开头添加了5
2. 在索引2的位置插入了15（在20之前）
3. 移除了索引1的节点（值为10）
4. 最终链表包含的值为：5, 15, 20

## 常见链表操作

### 1. 反转链表

```javascript
/**
 * 反转单向链表
 * @param {Node} head - 链表头节点
 * @return {Node} 反转后的链表头节点
 */
function reverseLinkedList(head) {
  let prev = null;
  let current = head;

  while (current) {
    // 保存next引用，防止链接断开
    const next = current.next;
    // 反转指针
    current.next = prev;
    // 移动prev和current前进一步
    prev = current;
    current = next;
  }

  return prev; // 新的头节点
}

// 调用示例
const list = new LinkedList();
list.append(1);
list.append(2);
list.append(3);
list.append(4);
console.log("原链表:", list.toString()); // "1,2,3,4"

// 创建一个新链表指向反转后的链表
const newList = new LinkedList();
newList.head = reverseLinkedList(list.head);
newList.size = list.size;
console.log("反转后:", newList.toString()); // "4,3,2,1"
```

**执行结果解析**：
1. 创建原始链表：1->2->3->4
2. 调用反转函数，得到新的链表头节点
3. 输出反转后的链表：4->3->2->1

**时间复杂度**：O(n)，其中n是链表的长度
**空间复杂度**：O(1)，只使用了常数级别的额外空间

### 2. 检测环形链表

```javascript
/**
 * 检测链表是否有环
 * @param {Node} head - 链表头节点
 * @return {boolean} 是否存在环
 */
function hasCycle(head) {
  if (!head || !head.next) {
    return false;
  }

  let slow = head;  // 慢指针，每次移动一步
  let fast = head;  // 快指针，每次移动两步

  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;

    // 如果两个指针相遇，说明有环
    if (slow === fast) {
      return true;
    }
  }

  // 如果快指针到达链表末尾，说明没有环
  return false;
}

// 调用示例
function createCyclicList() {
  const list = new LinkedList();
  list.append(1);
  list.append(2);
  list.append(3);
  list.append(4);

  // 创建一个环：4->2
  let current = list.head;
  while (current.next) {
    current = current.next;
  }

  // 获取第二个节点
  let secondNode = list.head.next;
  current.next = secondNode; // 尾节点指向第二个节点，形成环

  return list.head;
}

const cyclicHead = createCyclicList();
console.log("链表是否有环:", hasCycle(cyclicHead)); // true

const normalList = new LinkedList();
normalList.append(1);
normalList.append(2);
normalList.append(3);
console.log("正常链表是否有环:", hasCycle(normalList.head)); // false
```

**执行结果解析**：
1. 创建了一个有环的链表：1->2->3->4->2(环回到2)
2. 使用快慢指针检测到了环，返回true
3. 创建了一个无环的链表：1->2->3
4. 检测无环链表，返回false

**时间复杂度**：O(n)，其中n是链表的长度
**空间复杂度**：O(1)，只使用了常数级别的额外空间

### 3. 查找链表中间节点

```javascript
/**
 * 查找链表的中间节点
 * @param {Node} head - 链表头节点
 * @return {Node|null} 中间节点或null
 */
function findMiddleNode(head) {
  if (!head) {
    return null;
  }

  let slow = head;  // 慢指针，每次移动一步
  let fast = head;  // 快指针，每次移动两步

  // 当快指针到达末尾时，慢指针正好在中间
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }

  return slow;
}

// 调用示例
// 奇数长度链表
const oddList = new LinkedList();
oddList.append(1);
oddList.append(2);
oddList.append(3);
oddList.append(4);
oddList.append(5);
const oddMiddle = findMiddleNode(oddList.head);
console.log("奇数链表的中间节点:", oddMiddle.data); // 3

// 偶数长度链表
const evenList = new LinkedList();
evenList.append(1);
evenList.append(2);
evenList.append(3);
evenList.append(4);
const evenMiddle = findMiddleNode(evenList.head);
console.log("偶数链表的中间节点:", evenMiddle.data); // 3
```

**执行结果解析**：
1. 对于奇数长度链表[1,2,3,4,5]，中间节点是3
2. 对于偶数长度链表[1,2,3,4]，返回第二个中间节点3（如果有两个中间节点，返回第二个）

**时间复杂度**：O(n)，其中n是链表的长度
**空间复杂度**：O(1)，只使用了常数级别的额外空间

### 4. 合并两个有序链表

```javascript
/**
 * 合并两个有序链表
 * @param {Node} l1 - 第一个有序链表头节点
 * @param {Node} l2 - 第二个有序链表头节点
 * @return {Node} 合并后的有序链表头节点
 */
function mergeTwoSortedLists(l1, l2) {
  // 创建一个哑节点作为合并链表的起点
  const dummy = new Node(0);
  let current = dummy;

  // 同时遍历两个链表，选择较小的节点添加到结果链表
  while (l1 && l2) {
    if (l1.data < l2.data) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }
    current = current.next;
  }

  // 将剩余节点直接连接到结果链表末尾
  current.next = l1 || l2;

  return dummy.next;
}

// 调用示例
const list1 = new LinkedList();
list1.append(1);
list1.append(3);
list1.append(5);

const list2 = new LinkedList();
list2.append(2);
list2.append(4);
list2.append(6);

// 合并两个有序链表
const mergedList = new LinkedList();
mergedList.head = mergeTwoSortedLists(list1.head, list2.head);

console.log("合并后的链表:", mergedList.toString()); // "1,2,3,4,5,6"
```

**执行结果解析**：
1. 创建了两个有序链表：[1,3,5]和[2,4,6]
2. 合并这两个链表，得到[1,2,3,4,5,6]

**时间复杂度**：O(n+m)，其中n和m是两个链表的长度
**空间复杂度**：O(1)，只使用了常数级别的额外空间

### 5. 删除链表倒数第N个节点

```javascript
/**
 * 删除链表倒数第N个节点
 * @param {Node} head - 链表头节点
 * @param {number} n - 要删除的倒数位置
 * @return {Node} 处理后的链表头节点
 */
function removeNthFromEnd(head, n) {
  // 创建哑节点，简化特殊情况的处理（如删除头节点）
  const dummy = new Node(0);
  dummy.next = head;

  let first = dummy;
  let second = dummy;

  // 先让first前进n+1步
  for (let i = 0; i <= n; i++) {
    first = first.next;
  }

  // 同时移动first和second，直到first到达末尾
  // 此时second指向要删除节点的前一个节点
  while (first) {
    first = first.next;
    second = second.next;
  }

  // 删除节点
  second.next = second.next.next;

  return dummy.next;
}

// 调用示例
const list = new LinkedList();
list.append(1);
list.append(2);
list.append(3);
list.append(4);
list.append(5);
console.log("原链表:", list.toString()); // "1,2,3,4,5"

// 删除倒数第2个节点
list.head = removeNthFromEnd(list.head, 2);
console.log("删除倒数第2个节点后:", list.toString()); // "1,2,3,5"

// 删除倒数第4个节点（即第1个节点）
list.head = removeNthFromEnd(list.head, 4);
console.log("删除倒数第4个节点后:", list.toString()); // "2,3,5"
```

**执行结果解析**：
1. 原始链表：[1,2,3,4,5]
2. 删除倒数第2个节点（值为4）后：[1,2,3,5]
3. 删除倒数第4个节点（值为1）后：[2,3,5]

**时间复杂度**：O(n)，其中n是链表的长度
**空间复杂度**：O(1)，只使用了常数级别的额外空间

## 复杂度分析

### 链表操作的时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 访问元素 | O(n) | 需要从头遍历 |
| 插入元素（头部） | O(1) | 直接修改引用 |
| 插入元素（中间） | O(n) | 需要先找到位置 |
| 插入元素（尾部） | O(n)/O(1) | 单链表O(n)，带尾指针O(1) |
| 删除元素（头部） | O(1) | 直接修改引用 |
| 删除元素（中间） | O(n) | 需要先找到位置 |
| 删除元素（尾部） | O(n) | 需要找到倒数第二个节点 |
| 查找元素 | O(n) | 需要遍历链表 |

### 空间复杂度

链表的空间复杂度为O(n)，其中n是链表的长度。每个节点需要额外的空间来存储指向下一个节点的引用。

## 前端应用场景

1. **撤销/重做功能**：使用双向链表实现操作历史
2. **LRU缓存**：最近最少使用缓存的实现
3. **前端路由**：浏览历史的管理
4. **大文件分片上传**：管理文件分片的顺序和状态
5. **虚拟DOM的Diff算法**：某些实现中使用链表结构
6. **无限滚动列表**：管理动态加载的数据

## 经典算法题

### 1. 判断回文链表

回文链表是指从前向后遍历和从后向前遍历得到的结果是一样的链表。与回文字符串类似，链表的回文判断需要比较首尾对应位置的元素是否相等。

**回文链表示例**：
- `1->2->2->1`：正向读是"1,2,2,1"，反向读也是"1,2,2,1"，所以是回文链表
- `1->2->3->2->1`：正向读是"1,2,3,2,1"，反向读也是"1,2,3,2,1"，所以是回文链表
- `1`：单个节点也视为回文链表
- `1->1`：两个相同值的节点构成回文链表

**非回文链表示例**：
- `1->2`：正向读是"1,2"，反向读是"2,1"，不一致，不是回文链表
- `1->2->3->4->5`：正向读是"1,2,3,4,5"，反向读是"5,4,3,2,1"，不一致，不是回文链表
- `1->2->1->2`：正向读是"1,2,1,2"，反向读是"2,1,2,1"，不一致，不是回文链表

```javascript
/**
 * @description 判断链表是否为回文链表
 * @param {ListNode} head - 链表头节点
 * @return {boolean} 是否为回文链表
 */
function isPalindromeLinkedList(head) {
  if (!head || !head.next) {
    return true;  // 空链表或只有一个节点的链表都视为回文
  }

  // 1. 找到中间节点
  let slow = head;
  let fast = head;

  while (fast.next && fast.next.next) {
    slow = slow.next;     // 慢指针每次移动一步
    fast = fast.next.next;  // 快指针每次移动两步
  }

  // 2. 反转后半部分链表
  let secondHalf = reverseLinkedList(slow.next);
  let firstHalfPointer = head;
  let secondHalfPointer = secondHalf;

  let result = true;

  // 3. 比较前半部分和反转后的后半部分
  while (result && secondHalfPointer) {
    if (firstHalfPointer.data !== secondHalfPointer.data) {
      result = false;  // 对应位置的值不同，不是回文
    }
    firstHalfPointer = firstHalfPointer.next;
    secondHalfPointer = secondHalfPointer.next;
  }

  // 4. 恢复链表原始结构（可选）
  slow.next = reverseLinkedList(secondHalf);

  return result;
}

/**
 * 辅助函数：反转链表
 * @param {ListNode} head - 链表头节点
 * @return {ListNode} 反转后的链表头节点
 */
/**
 * 反转单向链表
 * @param {Node} head - 原链表的头节点
 * @returns {Node} 反转后的链表头节点
 */
function reverseLinkedList(head) {
  let prev = null; // 前一个节点，初始为null（反转后的尾节点）
  let current = head; // 当前节点，初始为原链表头节点

  while (current) { // 遍历原链表直到当前节点为null
    const next = current.next; // 保存当前节点的下一个节点引用
    current.next = prev; // 将当前节点的next指向前一个节点（完成反转）
    prev = current; // 前一个节点后移（指向当前节点）
    current = next; // 当前节点后移（指向原链表的下一个节点）
  }

  return prev; // 遍历结束后，prev指向原链表的最后一个节点，即反转后的头节点
}
```

**调用示例**：
```javascript
// 创建回文链表：1->2->2->1
const palindromeList = new LinkedList();
palindromeList.append(1);
palindromeList.append(2);
palindromeList.append(2);
palindromeList.append(1);
console.log("回文链表判断:", isPalindromeLinkedList(palindromeList.head)); // true

// 创建非回文链表：1->2->3->4
const nonPalindromeList = new LinkedList();
nonPalindromeList.append(1);
nonPalindromeList.append(2);
nonPalindromeList.append(3);
nonPalindromeList.append(4);
console.log("非回文链表判断:", isPalindromeLinkedList(nonPalindromeList.head)); // false
```

**执行结果解析**：
1. 对于链表[1,2,2,1]，找到中间节点2，反转后半部分得到[1,2]和[1,2]，比较相同，返回true
2. 对于链表[1,2,3,4]，找到中间节点2，反转后半部分得到[1,2]和[4,3]，比较不同，返回false

**算法解释**：
1. 首先使用快慢指针找到链表的中点
2. 将链表的后半部分反转
3. 比较前半部分和反转后的后半部分是否相同
4. 最后将链表恢复原状（可选步骤）

**时间复杂度**：O(n)，其中n是链表的长度
**空间复杂度**：O(1)，只使用了常数额外空间

### 2. 链表排序

```javascript
function sortLinkedList(head) {
  if (!head || !head.next) {
    return head;
  }

  // 找到中间节点
  const middle = findMiddleNode(head);
  const nextOfMiddle = middle.next;
  middle.next = null;

  // 递归排序两半
  const left = sortLinkedList(head);
  const right = sortLinkedList(nextOfMiddle);

  // 合并两个有序链表
  return mergeTwoSortedLists(left, right);
}
```

### 3. 两个链表的第一个公共节点

```javascript
function getIntersectionNode(headA, headB) {
  if (!headA || !headB) {
    return null;
  }

  let pointerA = headA;
  let pointerB = headB;

  while (pointerA !== pointerB) {
    pointerA = pointerA ? pointerA.next : headB;
    pointerB = pointerB ? pointerB.next : headA;
  }

  return pointerA;
}
```

## 面试常见问题

1. **链表和数组的区别是什么？各自的优缺点是什么？**

   **答案**：

   链表和数组是两种基本的线性数据结构，它们的主要区别在于内存分配和元素访问方式：

   **链表特点**：
   - **内存分配**：动态分配内存，节点在内存中不连续
   - **元素访问**：无法直接随机访问，必须从头开始遍历，时间复杂度O(n)
   - **插入/删除**：O(1)时间复杂度（如果已知位置）
   - **内存利用**：除了存储数据外，还需额外空间存储指针

   **数组特点**：
   - **内存分配**：静态分配连续内存块（JavaScript中是动态的）
   - **元素访问**：可以通过索引直接访问，O(1)时间复杂度
   - **插入/删除**：O(n)时间复杂度（需要移动元素）
   - **内存利用**：只需要存储数据本身

   **适用场景对比**：
   - 链表适合频繁插入/删除操作，不固定大小的场景
   - 数组适合频繁随机访问，知道元素总数的场景

   **在前端中的应用**：
   - 链表：实现LRU缓存、撤销/重做功能、文件分片上传等
   - 数组：几乎所有需要有序数据的场景，如列表渲染、数据表格等

2. **如何判断一个链表中是否有环？如何找到环的入口点？**

   **答案**：

   **检测是否有环**（快慢指针法）：

   ```javascript
   /**
    * 判断链表是否有环
    * @param {ListNode} head 链表头节点
    * @return {boolean} 是否有环
    */
   function hasCycle(head) {
     if (!head || !head.next) return false;

     let slow = head;
     let fast = head;

     while (fast && fast.next) {
       slow = slow.next;       // 慢指针每次走1步
       fast = fast.next.next;  // 快指针每次走2步

       if (slow === fast) {
         return true;  // 两指针相遇，说明有环
       }
     }

     return false;  // 快指针到达终点，说明无环
   }
   ```

   **查找环的入口点**（Floyd's Tortoise and Hare）：

   ```javascript
   /**
    * 查找链表中环的入口点
    * @param {ListNode} head 链表头节点
    * @return {ListNode|null} 环的入口节点或null
    */
   function detectCycle(head) {
     if (!head || !head.next) return null;

     // 第一阶段：检测是否有环
     let slow = head;
     let fast = head;
     let hasCycle = false;

     while (fast && fast.next) {
       slow = slow.next;
       fast = fast.next.next;

       if (slow === fast) {
         hasCycle = true;
         break;
       }
     }

     if (!hasCycle) return null;

     // 第二阶段：查找环的入口
     slow = head;
     while (slow !== fast) {
       slow = slow.next;
       fast = fast.next;
     }

     return slow;  // 此时slow/fast指向环的入口
   }
   ```

   **原理解释**：
   - 第一阶段使用快慢指针检测环，如果有环，它们一定会在环内相遇
   - 设链表头到环入口的距离为a，环入口到相遇点的距离为b，相遇点到环入口的距离为c
   - 当slow和fast相遇时，slow走了a+b，fast走了a+b+n(b+c)，其中n是fast在环内多走的圈数
   - 因为fast速度是slow的两倍，所以a+b+n(b+c) = 2(a+b)
   - 化简得到：a = c+(n-1)(b+c)
   - 这表明从链表头走a步和从相遇点走c+(n-1)(b+c)步都能到达环入口
   - 实际应用中，我们让一个指针从头出发，另一个从相遇点出发，每次都走1步，它们会在环入口相遇

   **时间复杂度**：O(n)，其中n是链表的长度
   **空间复杂度**：O(1)，只使用了常数级别的额外空间

3. **如何在O(1)时间内删除链表中的一个节点（给定节点的引用，不是位置）？**

   **答案**：

   要在O(1)时间内删除链表节点，我们可以通过复制下一个节点的值到当前节点，然后删除下一个节点来实现：

   ```javascript
   /**
    * 在O(1)时间内删除链表节点
    * @param {ListNode} node 要删除的节点引用(非尾节点)
    * @return {void}
    */
   function deleteNode(node) {
     // 注意：这种方法只适用于非尾节点
     if (!node || !node.next) return;

     // 复制下一个节点的值到当前节点
     node.data = node.next.data;

     // 删除下一个节点
     node.next = node.next.next;
   }
   ```

   **限制条件**：
   - 此方法仅适用于非尾节点，因为尾节点没有下一个节点可复制
   - 无法访问头节点的情况下，不能删除头节点

   **处理尾节点的情况**：
   - 如果可能是尾节点，则需要从头遍历链表，这样时间复杂度就变成了O(n)

   **为什么这样有效**：
   - 实际上我们没有真正删除目标节点，而是：
     1. 把下一个节点的值复制到目标节点
     2. 删除下一个节点
   - 从外部看来，效果等同于删除了目标节点

4. **如何找到两个链表的交点？**

   **答案**：

   两个链表的交点是指两个链表合并的第一个共同节点。注意交点的判断是基于节点引用相同，而不是节点值相同。

   ```javascript
   /**
    * 查找两个链表的交点
    * @param {ListNode} headA 第一个链表头节点
    * @param {ListNode} headB 第二个链表头节点
    * @return {ListNode|null} 交点或null
    */
   function getIntersectionNode(headA, headB) {
     if (!headA || !headB) return null;

     // 使用两个指针
     let pointerA = headA;
     let pointerB = headB;

     // 当两个指针不相等时继续遍历
     while (pointerA !== pointerB) {
       // 如果到达链表末尾，则转到另一个链表开头
       // 如果没有交点，最终两个指针都会变成null
       pointerA = pointerA ? pointerA.next : headB;
       pointerB = pointerB ? pointerB.next : headA;
     }

     // 返回交点（如果没有交点，将返回null）
     return pointerA;
   }
   ```

   **原理解释**：
   - 假设链表A长度为a+c，链表B长度为b+c，其中c是公共部分长度
   - 指针A走完链表A后，开始走链表B；指针B走完链表B后，开始走链表A
   - 当两个指针都走了a+b+c步后，它们会在交点相遇
   - 如果没有交点(c=0)，两个指针会同时变成null，循环结束

   **其他解法**：

   ```javascript
   /**
    * 使用哈希集合查找交点
    * @param {ListNode} headA 第一个链表头节点
    * @param {ListNode} headB 第二个链表头节点
    * @return {ListNode|null} 交点或null
    */
   function getIntersectionNodeWithSet(headA, headB) {
     if (!headA || !headB) return null;

     // 存储链表A的所有节点
     const nodeSet = new Set();
     let current = headA;

     while (current) {
       nodeSet.add(current);
       current = current.next;
     }

     // 遍历链表B，寻找第一个在集合中的节点
     current = headB;
     while (current) {
       if (nodeSet.has(current)) {
         return current;
       }
       current = current.next;
     }

     return null;
   }
   ```

   **方法比较**：

   | 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
   |------|------------|-----------|--------|
   | 双指针法 | O(a+b) | O(1) | 不需要额外空间，代码简洁 |
   | 哈希集合法 | O(a+b) | O(a) | 实现直观，但需要额外空间 |

   **时间复杂度**：O(a+b)，其中a和b是两个链表的长度
   **空间复杂度**：O(1)（双指针法）或O(a)（哈希集合法）

5. **如何判断一个链表是否为回文链表？**

   **答**：

   回文链表是指从前向后和从后向前遍历得到的结果是一样的链表，如同回文字符串。判断链表是否为回文需要比较首尾对应位置的元素是否相等。

   ```javascript
   /**
    * 判断链表是否为回文链表
    * @param {ListNode} head 链表头节点
    * @return {boolean} 是否为回文链表
    */
   function isPalindromeLinkedList(head) {
     if (!head || !head.next) {
       return true;  // 空链表或只有一个节点的链表都视为回文
     }

     // 1. 找到中间节点
     let slow = head;
     let fast = head;

     while (fast.next && fast.next.next) {
       slow = slow.next;     // 慢指针每次移动一步
       fast = fast.next.next;  // 快指针每次移动两步
     }

     // 2. 反转后半部分链表
     let secondHalf = reverseLinkedList(slow.next);
     let firstHalfPointer = head;
     let secondHalfPointer = secondHalf;

     let result = true;

     // 3. 比较前半部分和反转后的后半部分
     while (result && secondHalfPointer) {
       if (firstHalfPointer.data !== secondHalfPointer.data) {
         result = false;  // 对应位置的值不同，不是回文
       }
       firstHalfPointer = firstHalfPointer.next;
       secondHalfPointer = secondHalfPointer.next;
     }

     // 4. 恢复链表原始结构（可选）
     slow.next = reverseLinkedList(secondHalf);

     return result;
   }
   ```

   **调用示例**：
   ```javascript
   // 创建回文链表：1->2->2->1
   const palindromeList = new LinkedList();
   palindromeList.append(1);
   palindromeList.append(2);
   palindromeList.append(2);
   palindromeList.append(1);
   console.log("回文链表判断:", isPalindromeLinkedList(palindromeList.head)); // true

   // 创建非回文链表：1->2->3->4
   const nonPalindromeList = new LinkedList();
   nonPalindromeList.append(1);
   nonPalindromeList.append(2);
   nonPalindromeList.append(3);
   nonPalindromeList.append(4);
   console.log("非回文链表判断:", isPalindromeLinkedList(nonPalindromeList.head)); // false
   ```

   **执行过程**：
   1. 对于链表`[1,2,2,1]`：
      - 找到中间节点：2（第二个2前面的节点）
      - 反转后半部分：原链表变为`[1,2]<->[1,2]`
      - 比较前半部分和反转后的后半部分：1=1, 2=2，完全匹配
      - 恢复链表结构
      - 返回true

   2. 对于链表`[1,2,3,4]`：
      - 找到中间节点：2
      - 反转后半部分：原链表变为`[1,2]<->[4,3]`
      - 比较：1≠4，不匹配
      - 恢复链表结构
      - 返回false

   **另一种解法**（空间复杂度较高，但更直观）：
   ```javascript
   /**
    * 使用数组辅助判断回文链表
    * @param {ListNode} head 链表头节点
    * @return {boolean} 是否为回文链表
    */
   function isPalindromeWithArray(head) {
     const values = [];

     // 遍历链表，将所有值存入数组
     let current = head;
     while (current) {
       values.push(current.data);
       current = current.next;
     }

     // 检查数组是否为回文
     let left = 0;
     let right = values.length - 1;

     while (left < right) {
       if (values[left] !== values[right]) {
         return false;
       }
       left++;
       right--;
     }

     return true;
   }
   ```

   **方法比较**：

   | 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
   |------|------------|-----------|--------|
   | 反转链表法 | O(n) | O(1) | 更高效的空间利用，但需要修改原链表（可恢复） |
   | 数组法 | O(n) | O(n) | 实现更简单直观，但需要额外空间 |

6. **如何反转链表的一部分（给定起始和结束位置）？**

   **答**：

   要反转链表的一部分，我们需要找到要反转部分的前一个节点和要反转的部分，然后进行反转操作。

   ```javascript
   /**
    * 反转链表的一部分，从位置m到n
    * @param {ListNode} head 链表头节点
    * @param {number} m 起始位置（从1开始）
    * @param {number} n 结束位置
    * @return {ListNode} 反转后的链表头节点
    */
   function reverseBetween(head, m, n) {
     if (!head || m === n) return head;

     // 创建哑节点(dummy node)，处理头节点可能被反转的情况
     const dummy = new Node(0);
     dummy.next = head;

     // 找到反转部分的前一个节点
     let prev = dummy;
     for (let i = 1; i < m; i++) {
       prev = prev.next;
     }

     // 反转部分的开始节点
     let start = prev.next;
     let then = start.next;

     // 反转从位置m到n的部分
     for (let i = 0; i < n - m; i++) {
       start.next = then.next;  // 将start的next指向then的next
       then.next = prev.next;   // 将then的next指向prev的next
       prev.next = then;        // 将prev的next指向then
       then = start.next;       // 更新then为start的next
     }

     return dummy.next;
   }
   ```

   **调用示例**：
   ```javascript
   // 创建链表：1->2->3->4->5
   const list = new LinkedList();
   list.append(1);
   list.append(2);
   list.append(3);
   list.append(4);
   list.append(5);
   console.log("原链表:", list.toString()); // "1,2,3,4,5"

   // 反转位置2到4的部分
   list.head = reverseBetween(list.head, 2, 4);
   console.log("反转2到4的部分后:", list.toString()); // "1,4,3,2,5"
   ```

   **执行过程**：
   1. 原链表：`1->2->3->4->5`
   2. 创建dummy节点：`dummy->1->2->3->4->5`
   3. 找到反转部分的前一个节点prev：`1`
   4. 反转部分的开始节点start：`2`
   5. 初始then：`3`
   6. 第一次迭代：
      - `start.next = then.next` → `2->4`
      - `then.next = prev.next` → `3->2`
      - `prev.next = then` → `1->3`
      - 链表变为：`1->3->2->4->5`
      - 更新then为start.next：`4`
   7. 第二次迭代：
      - `start.next = then.next` → `2->5`
      - `then.next = prev.next` → `4->3`
      - `prev.next = then` → `1->4`
      - 链表变为：`1->4->3->2->5`
      - 更新then为start.next：`5`
   8. 迭代结束，返回：`1->4->3->2->5`

   **时间复杂度**：O(n)，其中n是链表长度
   **空间复杂度**：O(1)，只使用了常数级额外空间

7. **如何实现链表的深拷贝？**

   **答**：

   链表的深拷贝是指创建一个全新的链表，其节点结构和值与原链表相同，但是内存空间完全独立。

   **基本链表深拷贝**：

   ```javascript
   /**
    * 普通链表的深拷贝
    * @param {ListNode} head 链表头节点
    * @return {ListNode} 深拷贝后的链表头节点
    */
   function deepCopy(head) {
     if (!head) return null;

     // 创建新的头节点
     const newHead = new Node(head.data);
     let current = newHead;
     let oldCurrent = head.next;

     // 逐个创建并连接新节点
     while (oldCurrent) {
       current.next = new Node(oldCurrent.data);
       current = current.next;
       oldCurrent = oldCurrent.next;
     }

     return newHead;
   }
   ```

   **调用示例**：
   ```javascript
   // 创建原始链表：1->2->3
   const originalList = new LinkedList();
   originalList.append(1);
   originalList.append(2);
   originalList.append(3);
   console.log("原始链表:", originalList.toString()); // "1,2,3"

   // 深拷贝链表
   const copiedList = new LinkedList();
   copiedList.head = deepCopy(originalList.head);
   console.log("拷贝链表:", copiedList.toString()); // "1,2,3"

   // 验证两个链表是独立的
   originalList.append(4);
   console.log("修改后原始链表:", originalList.toString()); // "1,2,3,4"
   console.log("拷贝链表(不受影响):", copiedList.toString()); // "1,2,3"
   ```

   **带随机指针的链表深拷贝**：

   ```javascript
   /**
    * 带随机指针的链表节点
    */
   class RandomNode {
     /**
      * 创建带随机指针的节点
      * @param {any} data 节点数据
      */
     constructor(data) {
       this.data = data;
       this.next = null;
       this.random = null; // 指向链表中任意节点或null
     }
   }

   /**
    * 带随机指针的链表深拷贝
    * @param {RandomNode} head 链表头节点
    * @return {RandomNode} 深拷贝后的链表头节点
    */
   function copyRandomList(head) {
     if (!head) return null;

     const map = new Map();

     // 第一次遍历：创建所有新节点
     let current = head;
     while (current) {
       map.set(current, new RandomNode(current.data));
       current = current.next;
     }

     // 第二次遍历：连接新节点的next和random指针
     current = head;
     while (current) {
       const newNode = map.get(current);
       newNode.next = current.next ? map.get(current.next) : null;
       newNode.random = current.random ? map.get(current.random) : null;
       current = current.next;
     }

     return map.get(head);
   }
   ```

   **不使用额外空间的解法（O(1)空间复杂度）**：

   ```javascript
   /**
    * 不使用额外空间的带随机指针的链表深拷贝
    * @param {RandomNode} head 链表头节点
    * @return {RandomNode} 深拷贝后的链表头节点
    */
   function copyRandomListO1(head) {
     if (!head) return null;

     // 步骤1：在每个原节点后创建一个新节点
     let current = head;
     while (current) {
       const newNode = new RandomNode(current.data);
       newNode.next = current.next;
       current.next = newNode;
       current = newNode.next;
     }

     // 步骤2：设置新节点的random指针
     current = head;
     while (current) {
       if (current.random) {
         current.next.random = current.random.next;
       }
       current = current.next.next;
     }

     // 步骤3：分离两个链表
     const newHead = head.next;
     current = head;

     while (current) {
       const newNode = current.next;
       current.next = newNode.next;
       newNode.next = newNode.next ? newNode.next.next : null;
       current = current.next;
     }

     return newHead;
   }
   ```

   **算法步骤解释**：
   1. 在每个原节点后创建对应的新节点，形成交错链表
   2. 设置新节点的random指针（原节点A的random指向B，则A'的random指向B'）
   3. 将交错链表分离成两个独立的链表

   **执行示例**：
   ```
   原始链表:       1 -> 2 -> 3
                   ↓    ↑    ↓
                   3    1    2

   步骤1后:        1 -> 1' -> 2 -> 2' -> 3 -> 3'

   步骤2后:        1 -> 1' -> 2 -> 2' -> 3 -> 3'
                   ↓    ↓    ↑    ↑    ↓    ↓
                   3    3'   1    1'   2    2'

   步骤3后:        1 -> 2 -> 3     和     1' -> 2' -> 3'
                   ↓    ↑    ↓           ↓    ↑    ↓
                   3    1    2           3'   1'   2'
   ```

   **方法比较**：

   | 方法 | 时间复杂度 | 空间开销 | 优缺点 |
   |------|---------------|-----------|--------|
   | 哈希表法 | O(n) | O(n) | 实现简单直观 |
   | 交错链表法 | O(n) | O(1) | 空间效率高，但实现较复杂 |

8. **如何在前端实现LRU缓存？**

   **答**：

   LRU(Least Recently Used)缓存是一种常用的缓存策略，它在达到容量限制时，会优先删除最长时间未使用的项。结合哈希表和双向链表可以实现O(1)时间复杂度的操作。

   ```javascript
   /**
    * LRU缓存实现
    * @class LRUCache
    */
   class LRUCache {
     /**
      * 创建LRU缓存
      * @param {number} capacity 缓存容量
      */
     constructor(capacity) {
       this.capacity = capacity;
       this.cache = new Map();  // 提供O(1)的查找性能

       // 使用双向链表维护访问顺序
       this.head = { key: 0, value: 0 };  // 哑头节点
       this.tail = { key: 0, value: 0 };  // 哑尾节点
       this.head.next = this.tail;
       this.tail.prev = this.head;
     }

     /**
      * 获取缓存中的值
      * @param {any} key 键
      * @return {any} 值，不存在返回-1
      */
     get(key) {
       if (!this.cache.has(key)) return -1;

       // 获取节点
       const node = this.cache.get(key);

       // 将节点移到最前(表示最近使用)
       this.moveToHead(node);

       return node.value;
     }

     /**
      * 设置缓存
      * @param {any} key 键
      * @param {any} value 值
      */
     put(key, value) {
       // 如果已存在，更新值，并移到最前
       if (this.cache.has(key)) {
         const node = this.cache.get(key);
         node.value = value;
         this.moveToHead(node);
         return;
       }

       // 如果不存在，创建新节点
       const newNode = { key, value, prev: null, next: null };
       this.cache.set(key, newNode);
       this.addToHead(newNode);

       // 如果超出容量，删除最久未使用的节点(链表尾部)
       if (this.cache.size > this.capacity) {
         const tailNode = this.removeTail();
         this.cache.delete(tailNode.key);
       }
     }

     /**
      * 添加节点到链表头部
      * @param {Object} node 节点
      * @private
      */
     addToHead(node) {
       node.prev = this.head;
       node.next = this.head.next;
       this.head.next.prev = node;
       this.head.next = node;
     }

     /**
      * 从链表中移除节点
      * @param {Object} node 节点
      * @private
      */
     removeNode(node) {
       node.prev.next = node.next;
       node.next.prev = node.prev;
     }

     /**
      * 将节点移到链表头部
      * @param {Object} node 节点
      * @private
      */
     moveToHead(node) {
       this.removeNode(node);
       this.addToHead(node);
     }

     /**
      * 移除链表尾部节点
      * @return {Object} 尾部节点
      * @private
      */
     removeTail() {
       const tailNode = this.tail.prev;
       this.removeNode(tailNode);
       return tailNode;
     }
   }
   ```

   **调用示例**：
   ```javascript
   // 创建容量为2的LRU缓存
   const lruCache = new LRUCache(2);

   // 添加两个键值对
   lruCache.put(1, 'one');
   lruCache.put(2, 'two');
   console.log(lruCache.get(1)); // 'one'

   // 添加新键值对，容量已满，会删除最久未使用的键2
   lruCache.put(3, 'three');
   console.log(lruCache.get(2)); // -1 (已被删除)
   console.log(lruCache.get(3)); // 'three'

   // 再次访问键1，使其成为最近使用
   console.log(lruCache.get(1)); // 'one'

   // 添加新键值对，会删除最久未使用的键3
   lruCache.put(4, 'four');
   console.log(lruCache.get(3)); // -1 (已被删除)
   console.log(lruCache.get(1)); // 'one'
   console.log(lruCache.get(4)); // 'four'
   ```

   **前端实际应用示例**：

   ```javascript
   /**
    * 前端API请求缓存实现
    * @class APICache
    */
   class APICache {
     /**
      * 创建API缓存
      * @param {number} capacity 缓存容量
      */
     constructor(capacity = 100) {
       this.cache = new LRUCache(capacity);
     }

     /**
      * 获取API数据，优先从缓存获取
      * @param {string} url API地址
      * @param {Object} options 请求选项
      * @return {Promise} 请求结果
      */
     async fetchData(url, options = {}) {
       const cacheKey = this.getCacheKey(url, options);

       // 尝试从缓存获取
       const cachedData = this.cache.get(cacheKey);
       if (cachedData !== -1 && !this.isExpired(cachedData)) {
         console.log('从缓存获取数据:', url);
         return cachedData.data;
       }

       // 发起网络请求
       console.log('从网络获取数据:', url);
       try {
         const response = await fetch(url, options);
         const data = await response.json();

         // 存入缓存
         this.cache.put(cacheKey, {
           data,
           timestamp: Date.now(),
           expiration: options.expiration || 60000 // 默认1分钟
         });

         return data;
       } catch (error) {
         console.error('API请求失败:', error);
         throw error;
       }
     }

     /**
      * 生成缓存键
      * @param {string} url API地址
      * @param {Object} options 请求选项
      * @return {string} 缓存键
      * @private
      */
     getCacheKey(url, options) {
       return `${url}|${JSON.stringify(options)}`;
     }

     /**
      * 检查缓存是否过期
      * @param {Object} cachedData 缓存数据
      * @return {boolean} 是否过期
      * @private
      */
     isExpired(cachedData) {
       return Date.now() - cachedData.timestamp > cachedData.expiration;
     }

     /**
      * 清除缓存
      * @param {string} url 可选，特定URL的缓存
      */
     clearCache(url) {
       if (url) {
         // 清除特定URL的缓存
         const cacheKeys = Array.from(this.cache.cache.keys());
         for (const key of cacheKeys) {
           if (key.startsWith(url)) {
             this.cache.cache.delete(key);
           }
         }
       } else {
         // 清除所有缓存
         this.cache = new LRUCache(this.cache.capacity);
       }
     }
   }
   ```

   **使用示例**：
   ```javascript
   // 创建API缓存实例
   const apiCache = new APICache(50);

   // 模拟API调用
   async function fetchUserData(userId) {
     return apiCache.fetchData(`https://api.example.com/users/${userId}`, {
       expiration: 300000 // 缓存5分钟
     });
   }

   // 多次调用同一API，只会发出一次网络请求
   async function test() {
     const user1 = await fetchUserData(123);
     console.log('首次获取用户数据');

     const user2 = await fetchUserData(123);
     console.log('第二次获取用户数据(从缓存)');

     // 清除缓存
     apiCache.clearCache();

     const user3 = await fetchUserData(123);
     console.log('第三次获取用户数据(缓存已清除，从网络获取)');
   }

   test();
   ```

   **实现要点**：
   - 使用HashMap(Map)实现O(1)时间的查找
   - 使用双向链表维护访问顺序
   - 每次访问后，将节点移到链表头部
   - 缓存满时，删除链表尾部节点（最久未使用）

   **应用场景**：
   - API响应缓存：减少重复网络请求
   - 组件渲染结果缓存：提高复杂组件的渲染性能
   - 路由导航状态缓存：保存用户在不同页面的状态
   - 图片资源预加载缓存：提升图片加载速度

9. **如何优化链表的查找操作？**

   **答**：

   链表的查找操作通常需要O(n)时间复杂度，我们可以通过以下几种技术优化：

   **1. 使用跳跃表(Skip List)**：

   跳跃表是一种可以用来快速查找的数据结构，通过添加多级索引减少查找时间。

   ```javascript
   /**
    * 跳跃表节点
    * @class SkipNode
    */
   class SkipNode {
     /**
      * 创建跳跃表节点
      * @param {any} value 节点值
      * @param {number} level 节点层级
      */
     constructor(value, level) {
       this.value = value;
       this.forward = new Array(level + 1).fill(null);
     }
   }

   /**
    * 跳跃表实现 - 带有概率层级的链表结构
    * @class SkipList
    */
   class SkipList {
     /**
      * 创建跳跃表
      */
     constructor() {
       this.MAXLEVEL = 16;       // 最大层数
       this.P = 0.5;             // 层级概率
       this.level = 0;           // 当前层数
       this.header = new SkipNode(-1, this.MAXLEVEL);
     }

     /**
      * 获取随机层级
      * @return {number} 随机层级
      * @private
      */
     randomLevel() {
       let level = 0;
       while (Math.random() < this.P && level < this.MAXLEVEL) {
         level++;
       }
       return level;
     }

     /**
      * 插入元素
      * @param {number} value 值
      */
     insert(value) {
       const update = new Array(this.MAXLEVEL + 1).fill(null);
       let current = this.header;

       // 从当前最高层开始查找
       for (let i = this.level; i >= 0; i--) {
         while (current.forward[i] && current.forward[i].value < value) {
           current = current.forward[i];
         }
         update[i] = current;
       }

       // 获取新节点的随机层级
       const newLevel = this.randomLevel();

       // 更新当前最大层级
       if (newLevel > this.level) {
         for (let i = this.level + 1; i <= newLevel; i++) {
           update[i] = this.header;
         }
         this.level = newLevel;
       }

       // 创建新节点
       const newNode = new SkipNode(value, newLevel);

       // 插入节点到所有层级
       for (let i = 0; i <= newLevel; i++) {
         newNode.forward[i] = update[i].forward[i];
         update[i].forward[i] = newNode;
       }
     }

     /**
      * 查找元素
      * @param {number} value 值
      * @return {boolean} 是否存在
      */
     search(value) {
       let current = this.header;

       // 从当前最高层开始查找
       for (let i = this.level; i >= 0; i--) {
         while (current.forward[i] && current.forward[i].value < value) {
           current = current.forward[i];
         }
       }

       current = current.forward[0];

       return current && current.value === value;
     }
   }
   ```

   **调用示例**：
   ```javascript
   // 创建跳跃表
   const skipList = new SkipList();

   // 插入数据
   skipList.insert(3);
   skipList.insert(6);
   skipList.insert(7);
   skipList.insert(9);
   skipList.insert(12);
   skipList.insert(19);
   skipList.insert(17);

   // 查找数据
   console.log(skipList.search(9));  // true
   console.log(skipList.search(10)); // false
   ```

   **2. 哈希链表**：

   哈希链表结合了哈希表和链表的特性，通过哈希表实现O(1)的查找，同时保持链表的顺序性。

   ```javascript
   /**
    * 哈希链表 - 结合哈希表和链表
    * @class HashLinkedList
    */
   class HashLinkedList {
     /**
      * 创建哈希链表
      */
     constructor() {
       this.hashMap = new Map();  // 哈希表存储节点引用
       this.head = null;          // 链表头
       this.tail = null;          // 链表尾
       this.count = 0;            // 节点计数
     }

     /**
      * 添加节点
      * @param {string} key 键
      * @param {any} value 值
      */
     add(key, value) {
       // 如果已存在，更新值
       if (this.hashMap.has(key)) {
         const node = this.hashMap.get(key);
         node.value = value;
         return;
       }

       // 创建新节点
       const newNode = {
         key,
         value,
         next: null,
         prev: this.tail
       };

       // 更新链表
       if (!this.head) {
         this.head = newNode;
       } else {
         this.tail.next = newNode;
       }

       this.tail = newNode;
       this.hashMap.set(key, newNode);
       this.count++;
     }

     /**
      * 根据键查找节点
      * @param {string} key 键
      * @return {any} 值或undefined
      */
     get(key) {
       const node = this.hashMap.get(key);
       return node ? node.value : undefined;
     }

     /**
      * 根据键删除节点
      * @param {string} key 键
      * @return {boolean} 是否成功删除
      */
     remove(key) {
       const node = this.hashMap.get(key);
       if (!node) return false;

       // 更新相邻节点的指针
       if (node.prev) {
         node.prev.next = node.next;
       } else {
         this.head = node.next;
       }

       if (node.next) {
         node.next.prev = node.prev;
       } else {
         this.tail = node.prev;
       }

       this.hashMap.delete(key);
       this.count--;
       return true;
     }
   }
   ```

   **调用示例**：
   ```javascript
   // 创建哈希链表
   const hashList = new HashLinkedList();

   // 添加数据
   hashList.add('user1', { name: 'Alice', age: 25 });
   hashList.add('user2', { name: 'Bob', age: 30 });
   hashList.add('user3', { name: 'Charlie', age: 35 });

   // 快速查找
   console.log(hashList.get('user2')); // { name: 'Bob', age: 30 }

   // 删除并验证
   hashList.remove('user2');
   console.log(hashList.get('user2')); // undefined
   ```

   **3. 索引链表**：

   索引链表通过维护值到位置的映射，快速定位节点位置。

   ```javascript
   /**
    * 带索引的链表
    * @class IndexedLinkedList
    */
   class IndexedLinkedList {
     /**
      * 创建索引链表
      */
     constructor() {
       this.head = null;
       this.size = 0;
       this.indexMap = new Map(); // 存储位置索引
     }

     /**
      * 添加节点
      * @param {any} data 节点数据
      */
     append(data) {
       const newNode = { data, next: null };

       if (!this.head) {
         this.head = newNode;
       } else {
         let current = this.head;
         while (current.next) {
           current = current.next;
         }
         current.next = newNode;
       }

       // 更新索引
       this.indexMap.set(data, this.size);
       this.size++;
     }

     /**
      * 根据数据查找节点
      * @param {any} data 节点数据
      * @return {Object|null} 节点或null
      */
     find(data) {
       if (this.indexMap.has(data)) {
         const index = this.indexMap.get(data);
         let current = this.head;

         // 直接跳到索引位置
         for (let i = 0; i < index; i++) {
           current = current.next;
         }

         return current;
       }

       return null;
     }
   }
   ```

   **调用示例**：
   ```javascript
   // 创建索引链表
   const indexedList = new IndexedLinkedList();

   // 添加数据
   indexedList.append('apple');
   indexedList.append('banana');
   indexedList.append('cherry');
   indexedList.append('date');

   // 快速查找
   console.log(indexedList.find('cherry')); // {data: 'cherry', next: {...}}
   console.log(indexedList.find('grape'));  // null
   ```

   **性能对比**：

   | 方法 | 查找时间复杂度 | 空间开销 | 适用场景 |
   |------|---------------|---------|---------|
   | 标准链表 | O(n) | O(n) | 一般用途，数据量小 |
   | 跳跃表 | 平均O(log n) | O(n log n) | 需要有序集合，如Redis中的Sorted Set |
   | 哈希链表 | 平均O(1) | O(n) | 需要快速查找且保持插入顺序，如LRU缓存 |
   | 索引链表 | 平均O(1) | O(n) | 需要通过值快速查找节点位置的场景 |

   **实际应用技巧**：

   1. **缓存热点数据**：将经常访问的节点缓存或移到链表前部
   2. **按频率组织**：将高频访问节点集中放置
   3. **批量操作**：尽可能一次遍历完成多个操作
   4. **延迟加载**：对于大型链表，考虑分段加载
   5. **定期重组**：根据访问模式重新组织链表结构

## 学习资源

- [JavaScript数据结构 - 链表](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/linked-list) - GitHub上的JS实现，包含完整的链表实现和相关算法
- [LeetCode链表题集](https://leetcode.com/tag/linked-list/) - 丰富的链表相关算法题，可以系统地练习链表操作
- [前端进阶之道 - 链表](https://juejin.cn/post/6844903498362912775) - 前端视角的链表讲解，包含实际应用场景
- [JavaScript链表实现详解](https://www.freecodecamp.org/news/implementing-a-linked-list-in-javascript/) - FreeCodeCamp上的教程，从基础到高级的链表知识
- [可视化算法](https://visualgo.net/en/list) - 链表操作的可视化展示，帮助理解链表算法的执行过程

## 总结

链表是一种基础且强大的数据结构，在前端开发中有着广泛的应用。它的特点是动态性强、插入删除高效，但随机访问较慢。通过本章的学习，我们掌握了链表的基本实现、常见操作和优化技巧，以及在前端中的实际应用场景。

在实际开发中，链表常用于实现LRU缓存、撤销/重做功能、路由历史管理等场景。掌握链表及其相关算法，对提升代码质量和解决复杂问题有着重要作用。

最后，持续练习链表相关的算法题是提高编程能力的有效方式，建议读者在LeetCode等平台上进行系统性训练。