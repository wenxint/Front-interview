# 前端算法应用

> 算法与数据结构在前端开发中有着广泛的应用，掌握这些知识能够显著提升代码质量和性能。

## 前端常见算法应用场景

### 1. 防抖与节流

**防抖(Debounce)**：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

```javascript
/**
 * @description 防抖函数 - 延迟执行版本
 * @param {Function} fn - 需要防抖的函数
 * @param {number} delay - 延迟时间(ms)
 * @return {Function} 防抖处理后的函数
 */
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

/**
 * @description 防抖函数 - 立即执行版本
 * @param {Function} fn - 需要防抖的函数
 * @param {number} delay - 冷却时间(ms)
 * @return {Function} 防抖处理后的函数
 */
function debounceImmediate(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    const callNow = !timer;
    timer = setTimeout(() => {
      timer = null;
    }, delay);
    if (callNow) fn.apply(this, args);
  };
}

// 使用示例
const handleSearch = debounce(function(e) {
  // 搜索请求逻辑
  console.log('搜索内容：', e.target.value);
}, 300);

// 绑定到输入框
searchInput.addEventListener('input', handleSearch);

// 执行结果分析:
// 1. 用户快速输入"hello"
// 2. 每次输入都会触发input事件，但handleSearch函数不会立即执行
// 3. 用户停止输入300ms后，才会执行一次handleSearch函数
// 4. 控制台只会打印一次"搜索内容：hello"
```

**节流(Throttle)**：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行。

```javascript
/**
 * @description 节流函数 - 时间戳版本(首次触发立即执行)
 * @param {Function} fn - 需要节流的函数
 * @param {number} delay - 节流间隔时间(ms)
 * @return {Function} 节流处理后的函数
 */
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

/**
 * @description 节流函数 - 定时器版本(结束触发后仍执行一次)
 * @param {Function} fn - 需要节流的函数
 * @param {number} delay - 节流间隔时间(ms)
 * @return {Function} 节流处理后的函数
 */
function throttleTimer(fn, delay) {
  let timer = null;
  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = null;
      }, delay);
    }
  };
}

/**
 * @description 节流函数 - 结合版本(首次触发立即执行，结束触发后仍执行一次)
 * @param {Function} fn - 需要节流的函数
 * @param {number} delay - 节流间隔时间(ms)
 * @return {Function} 节流处理后的函数
 */
function throttleCombined(fn, delay) {
  let timer = null;
  let lastTime = 0;

  return function(...args) {
    const now = Date.now();
    const remaining = delay - (now - lastTime);

    if (remaining <= 0) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn.apply(this, args);
      lastTime = now;
    } else if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args);
        lastTime = Date.now();
        timer = null;
      }, remaining);
    }
  };
}

// 使用示例
const handleScroll = throttle(function() {
  // 滚动处理逻辑
  console.log('页面滚动位置：', window.scrollY);
}, 200);

// 绑定到滚动事件
window.addEventListener('scroll', handleScroll);

// 执行结果分析:
// 1. 用户快速滚动页面
// 2. 即使滚动事件触发频率很高(如每16ms一次)，handleScroll函数最多每200ms执行一次
// 3. 如果1秒内滚动触发了60次事件，实际只会执行约5次handleScroll函数
// 4. 控制台打印的滚动位置会以200ms的间隔更新
```

**防抖与节流的性能对比**：

```javascript
// 性能测试
function performanceTest() {
  const testFunction = () => {
    // 模拟耗时操作
    let sum = 0;
    for (let i = 0; i < 10000; i++) {
      sum += i;
    }
    return sum;
  };

  const rawFn = testFunction;
  const debouncedFn = debounce(testFunction, 300);
  const throttledFn = throttle(testFunction, 300);

  console.time('原始函数连续调用100次');
  for (let i = 0; i < 100; i++) {
    rawFn();
  }
  console.timeEnd('原始函数连续调用100次');

  console.time('防抖函数连续调用100次');
  for (let i = 0; i < 100; i++) {
    debouncedFn();
  }
  setTimeout(() => {
    console.timeEnd('防抖函数连续调用100次');
  }, 400);

  console.time('节流函数连续调用100次');
  for (let i = 0; i < 100; i++) {
    throttledFn();
  }
  setTimeout(() => {
    console.timeEnd('节流函数连续调用100次');
  }, 400);
}

// 输出示例:
// 原始函数连续调用100次: 150.123ms
// 节流函数连续调用100次: 1.537ms (只执行了1次实际函数)
// 防抖函数连续调用100次: 1.234ms (只执行了1次实际函数)
```

**前端应用场景**：

| 技术 | 典型应用场景 | 实际例子 |
|------|------------|---------|
| 防抖 | 输入框搜索   | 用户输入关键词时等用户输入完毕再发起请求 |
|      | 窗口大小调整 | 浏览器窗口调整完成后再重新布局 |
|      | 表单提交     | 防止用户多次点击提交按钮 |
| 节流 | 页面滚动事件 | 滚动加载或固定导航栏时控制处理频率 |
|      | 按钮点击     | 游戏中的武器发射或连续点击操作 |
|      | 拖拽事件     | 拖拽元素时以固定频率更新位置 |

### 2. 数据结构优化

#### 使用Map/Set优化查找与缓存

```javascript
/**
 * @description 使用Map实现函数记忆化缓存
 * @param {Function} fn - 需要缓存的函数
 * @return {Function} 带缓存功能的函数
 */
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      console.log('缓存命中:', key);
      return cache.get(key);
    }
    console.log('缓存未命中，执行函数:', key);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 使用示例 - 斐波那契数列
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(function(n) {
  if (n <= 1) return n;
  return memoizedFib(n - 1) + memoizedFib(n - 2);
});

console.time('未优化');
console.log(fibonacci(30)); // 832040
console.timeEnd('未优化');

console.time('使用Map优化');
console.log(memoizedFib(30)); // 832040
console.timeEnd('使用Map优化');

// 输出示例:
// 未优化: 21.422s
// 缓存未命中，执行函数: [30]
// 缓存未命中，执行函数: [29]
// ...更多缓存记录...
// 832040
// 使用Map优化: 0.003s
```

#### 使用Set实现去重和集合操作

```javascript
/**
 * @description 使用Set对数组去重
 * @param {Array} arr - 需要去重的数组
 * @return {Array} 去重后的数组
 */
function uniqueArray(arr) {
  return [...new Set(arr)];
}

/**
 * @description 集合操作
 * @param {Array} arr1 - 集合1
 * @param {Array} arr2 - 集合2
 * @return {Object} 包含交集、并集、差集的结果
 */
function setOperations(arr1, arr2) {
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);

  // 交集
  const intersection = new Set([...set1].filter(x => set2.has(x)));

  // 并集
  const union = new Set([...set1, ...set2]);

  // 差集 (set1 - set2)
  const difference = new Set([...set1].filter(x => !set2.has(x)));

  return {
    intersection: [...intersection],
    union: [...union],
    difference: [...difference]
  };
}

// 使用示例
const arr1 = [1, 2, 2, 3, 4, 5];
const arr2 = [3, 4, 5, 6, 7];

console.log('去重:', uniqueArray(arr1)); // [1, 2, 3, 4, 5]
console.log('集合操作:', setOperations(arr1, arr2));
// {
//   intersection: [3, 4, 5],
//   union: [1, 2, 3, 4, 5, 6, 7],
//   difference: [1, 2]
// }
```

#### 使用Object/Map实现简单LRU缓存

```javascript
/**
 * @description 简单的LRU缓存实现
 * @param {number} capacity - 缓存容量
 */
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  /**
   * @description 获取缓存值
   * @param {string} key - 缓存键
   * @return {any} 缓存的值或-1(未命中)
   */
  get(key) {
    if (!this.cache.has(key)) return -1;

    // 更新位置（删除后重新插入到最后）
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  /**
   * @description 设置缓存值
   * @param {string} key - 缓存键
   * @param {any} value - 缓存的值
   */
  put(key, value) {
    // 如果已存在，先删除旧的
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    // 如果缓存已满，删除最久未使用的项(第一个)
    else if (this.cache.size >= this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    // 新增到最后
    this.cache.set(key, value);
  }

  /**
   * 获取当前缓存内容
   */
  getCache() {
    return Object.fromEntries(this.cache);
  }
}

// 使用示例
const cache = new LRUCache(3);
cache.put('a', 1);
cache.put('b', 2);
cache.put('c', 3);
console.log('初始缓存:', cache.getCache()); // {a: 1, b: 2, c: 3}

// 访问b，b变为最近使用
console.log('访问b:', cache.get('b')); // 2
console.log('访问后缓存:', cache.getCache()); // {a: 1, c: 3, b: 2}

// 加入新值d，将淘汰最久未使用的a
cache.put('d', 4);
console.log('加入d后缓存:', cache.getCache()); // {c: 3, b: 2, d: 4}
```

#### 使用WeakMap实现数据结构关联

```javascript
/**
 * @description 使用WeakMap关联DOM元素和数据
 */
class DOMDataManager {
  constructor() {
    // 使用WeakMap，当DOM元素被移除时，对应数据可被垃圾回收
    this.dataMap = new WeakMap();
  }

  /**
   * 设置元素关联数据
   */
  setData(element, key, value) {
    if (!this.dataMap.has(element)) {
      this.dataMap.set(element, {});
    }
    const data = this.dataMap.get(element);
    data[key] = value;
  }

  /**
   * 获取元素关联数据
   */
  getData(element, key) {
    const data = this.dataMap.get(element);
    return data ? data[key] : undefined;
  }

  /**
   * 清除元素所有关联数据
   */
  clearData(element) {
    this.dataMap.delete(element);
  }
}

// 使用示例
const dataManager = new DOMDataManager();
const button = document.createElement('button');

// 关联数据
dataManager.setData(button, 'clickCount', 0);
dataManager.setData(button, 'lastClickTime', null);

// 模拟点击
button.addEventListener('click', () => {
  const count = dataManager.getData(button, 'clickCount') || 0;
  dataManager.setData(button, 'clickCount', count + 1);
  dataManager.setData(button, 'lastClickTime', new Date());

  console.log(`按钮点击次数: ${dataManager.getData(button, 'clickCount')}`);
});

// 输出示例(点击按钮后):
// 按钮点击次数: 1
```

### 3. 虚拟列表实现

虚拟列表核心思想：只渲染可视区域的内容，优化大数据量渲染性能。

```javascript
/**
 * @description 虚拟列表实现
 * @param {Object} options - 配置选项
 */
class VirtualList {
  constructor(options) {
    this.container = options.container;
    this.itemHeight = options.itemHeight;
    this.items = options.items || [];
    this.renderItem = options.renderItem || (item => `<div>${item}</div>`);

    // 计算可视区域能显示的item数量
    this.visibleItems = Math.ceil(this.container.clientHeight / this.itemHeight) + 2; // +2作为缓冲
    this.startIndex = 0;
    this.endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);
    this.scrollTop = 0;

    this.initDOM();
    this.bindEvents();
    this.render();
  }

  /**
   * 初始化DOM结构
   */
  initDOM() {
    this.container.style.overflow = 'auto';
    this.container.style.position = 'relative';

    // 创建高度占位元素
    this.phantom = document.createElement('div');
    this.phantom.style.height = `${this.items.length * this.itemHeight}px`;
    this.phantom.style.position = 'absolute';
    this.phantom.style.left = '0';
    this.phantom.style.top = '0';
    this.phantom.style.right = '0';
    this.phantom.style.zIndex = '-1';
    this.container.appendChild(this.phantom);

    // 创建内容容器
    this.content = document.createElement('div');
    this.content.style.position = 'absolute';
    this.content.style.left = '0';
    this.content.style.top = '0';
    this.content.style.right = '0';
    this.container.appendChild(this.content);
  }

  /**
   * 绑定滚动事件
   */
  bindEvents() {
    this.handleScroll = this.handleScroll.bind(this);
    this.container.addEventListener('scroll', this.handleScroll);
  }

  /**
   * 处理滚动事件
   */
  handleScroll() {
    const currentScrollTop = this.container.scrollTop;

    // 判断是否需要更新视图
    if (Math.abs(currentScrollTop - this.scrollTop) >= this.itemHeight / 2) {
      this.scrollTop = currentScrollTop;
      const newStartIndex = Math.floor(currentScrollTop / this.itemHeight);
      this.updateVisibleItems(newStartIndex);
    }
  }

  /**
   * 更新可视区域的item
   */
  updateVisibleItems(startIndex) {
    this.startIndex = Math.max(0, startIndex);
    this.endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);
    this.render();
  }

  /**
   * 渲染虚拟列表
   */
  render() {
    const visibleData = this.items.slice(this.startIndex, this.endIndex);
    this.content.style.transform = `translateY(${this.startIndex * this.itemHeight}px)`;

    this.content.innerHTML = visibleData.map((item, index) => `
      <div style="height: ${this.itemHeight}px;" data-index="${this.startIndex + index}">
        ${this.renderItem(item, this.startIndex + index)}
      </div>
    `).join('');
  }

  /**
   * 更新数据源
   */
  updateItems(newItems) {
    this.items = newItems;
    this.phantom.style.height = `${this.items.length * this.itemHeight}px`;
    this.updateVisibleItems(this.startIndex);
  }

  /**
   * 销毁实例
   */
  destroy() {
    this.container.removeEventListener('scroll', this.handleScroll);
    this.container.innerHTML = '';
  }
}

// 使用示例
function initVirtualList() {
  // 生成大量数据
  const items = Array.from({ length: 10000 }, (_, index) => ({
    id: index,
    content: `Item ${index + 1}`,
    height: 50
  }));

  const container = document.getElementById('virtual-list-container');
  if (!container) return;

  const virtualList = new VirtualList({
    container,
    items,
    itemHeight: 50,
    renderItem: (item, index) => `
      <div class="list-item">
        <span class="item-id">#${item.id}</span>
        <span class="item-content">${item.content}</span>
      </div>
    `
  });

  // 绑定添加按钮
  const addButton = document.getElementById('add-item-btn');
  if (addButton) {
    addButton.addEventListener('click', () => {
      const newItems = [...items, {
        id: items.length,
        content: `New Item ${items.length + 1}`,
        height: 50
      }];
      items.push(newItems[newItems.length - 1]);
      virtualList.updateItems(newItems);
    });
  }

  return virtualList;
}

// 初始化示例
document.addEventListener('DOMContentLoaded', initVirtualList);

// 性能对比测试
function performanceCompare() {
  // 模拟数据
  const data = Array.from({ length: 10000 }, (_, i) => ({ id: i, text: `Item ${i}` }));

  console.time('常规渲染');
  const normalList = document.createElement('div');
  normalList.innerHTML = data.map(item => `<div>${item.text}</div>`).join('');
  console.timeEnd('常规渲染');

  console.time('虚拟列表初始化');
  const container = document.createElement('div');
  container.style.height = '400px';
  document.body.appendChild(container);

  const virtualList = new VirtualList({
    container,
    items: data,
    itemHeight: 40,
    renderItem: item => item.text
  });
  console.timeEnd('虚拟列表初始化');

  // 模拟滚动
  console.time('虚拟列表滚动');
  container.scrollTop = 5000; // 滚动到中间位置
  // 由于滚动是异步的，我们需要等待一会儿
  setTimeout(() => {
    console.timeEnd('虚拟列表滚动');
  }, 50);
}

// 输出示例:
// 常规渲染: 1532.63ms
// 虚拟列表初始化: 5.23ms
// 虚拟列表滚动: 0.92ms
```

### 4. 树结构操作

前端开发中经常需要处理树形结构数据，如组件树、虚拟DOM、文件目录等。掌握树的遍历和操作方法非常重要。

#### 树的遍历方法

```javascript
/**
 * @description 深度优先遍历(DFS) - 递归实现
 * @param {Object} node - 树节点
 * @param {Array} nodeList - 存放遍历结果的数组
 * @return {Array} 遍历结果数组
 */
function deepTraversal(node, nodeList = []) {
  if (node) {
    // 访问当前节点
    nodeList.push(node);

    // 递归遍历子节点
    const children = node.children || [];
    for (let i = 0; i < children.length; i++) {
      deepTraversal(children[i], nodeList);
    }
  }
  return nodeList;
}

/**
 * @description 深度优先遍历 - 非递归实现(栈)
 * @param {Object} root - 根节点
 * @return {Array} 遍历结果数组
 */
function deepTraversalWithStack(root) {
  const result = [];
  const stack = [];

  if (root) {
    stack.push(root);

    while (stack.length > 0) {
      const current = stack.pop();
      result.push(current);

      // 将子节点从右到左入栈，保证出栈时从左到右访问
      const children = current.children || [];
      for (let i = children.length - 1; i >= 0; i--) {
        stack.push(children[i]);
      }
    }
  }

  return result;
}

/**
 * @description 广度优先遍历(BFS) - 队列实现
 * @param {Object} root - 根节点
 * @return {Array} 遍历结果数组
 */
function breadthTraversal(root) {
  const result = [];
  const queue = [];

  if (root) {
    queue.push(root);

    while (queue.length > 0) {
      const current = queue.shift();
      result.push(current);

      // 将子节点从左到右入队
      const children = current.children || [];
      for (let i = 0; i < children.length; i++) {
        queue.push(children[i]);
      }
    }
  }

  return result;
}

// 使用示例
const tree = {
  id: 'root',
  name: 'Root Node',
  children: [
    {
      id: 'node1',
      name: 'Node 1',
      children: [
        { id: 'node11', name: 'Node 1.1' },
        { id: 'node12', name: 'Node 1.2' }
      ]
    },
    {
      id: 'node2',
      name: 'Node 2',
      children: [
        { id: 'node21', name: 'Node 2.1' }
      ]
    }
  ]
};

console.log('DFS递归遍历结果:', deepTraversal(tree).map(node => node.id));
// 输出: ["root", "node1", "node11", "node12", "node2", "node21"]

console.log('DFS非递归遍历结果:', deepTraversalWithStack(tree).map(node => node.id));
// 输出: ["root", "node1", "node11", "node12", "node2", "node21"]

console.log('BFS遍历结果:', breadthTraversal(tree).map(node => node.id));
// 输出: ["root", "node1", "node2", "node11", "node12", "node21"]

// 性能测试(使用大规模树)
function generateLargeTree(depth, breadth) {
  if (depth === 0) return null;

  const node = { id: `node-${Math.random().toString(36).substr(2, 5)}` };

  if (depth > 1) {
    node.children = Array.from({ length: breadth }, () =>
      generateLargeTree(depth - 1, breadth)
    );
  }

  return node;
}

const largeTree = generateLargeTree(5, 5); // 深度5，每个节点5个子节点

console.time('大规模树-DFS递归');
deepTraversal(largeTree);
console.timeEnd('大规模树-DFS递归');

console.time('大规模树-DFS非递归');
deepTraversalWithStack(largeTree);
console.timeEnd('大规模树-DFS非递归');

console.time('大规模树-BFS');
breadthTraversal(largeTree);
console.timeEnd('大规模树-BFS');

// 输出示例:
// 大规模树-DFS递归: 15.423ms
// 大规模树-DFS非递归: 10.132ms
// 大规模树-BFS: 12.567ms
```

#### 树的查找和操作

```javascript
/**
 * @description 在树中查找指定ID的节点
 * @param {Object|Array} tree - 树结构或节点数组
 * @param {string} id - 要查找的节点ID
 * @return {Object|null} 找到的节点或null
 */
function findNodeById(tree, id) {
  // 处理数组类型的树
  const treeArray = Array.isArray(tree) ? tree : [tree];
  const queue = [...treeArray];

  while (queue.length) {
    const node = queue.shift();
    if (!node) continue;

    // 找到目标节点
    if (node.id === id) return node;

    // 将子节点加入队列
    if (node.children && node.children.length) {
      queue.push(...node.children);
    }
  }

  return null;
}

/**
 * @description 在树中查找符合条件的所有节点
 * @param {Object|Array} tree - 树结构或节点数组
 * @param {Function} predicate - 判断条件函数
 * @return {Array} 所有符合条件的节点数组
 */
function findNodes(tree, predicate) {
  const treeArray = Array.isArray(tree) ? tree : [tree];
  const result = [];
  const stack = [...treeArray];

  while (stack.length) {
    const node = stack.pop();
    if (!node) continue;

    // 判断节点是否符合条件
    if (predicate(node)) {
      result.push(node);
    }

    // 将子节点加入栈
    if (node.children && node.children.length) {
      stack.push(...node.children);
    }
  }

  return result;
}

/**
 * @description 树结构转换为扁平数组
 * @param {Object|Array} tree - 树结构或节点数组
 * @return {Array} 扁平化后的节点数组
 */
function flattenTree(tree) {
  const treeArray = Array.isArray(tree) ? tree : [tree];
  const result = [];

  function dfs(nodes) {
    for (const node of nodes) {
      result.push({ ...node, children: undefined });

      if (node.children && node.children.length) {
        dfs(node.children);
      }
    }
  }

  dfs(treeArray);
  return result;
}

/**
 * @description 向树中指定节点添加子节点
 * @param {Object} tree - 树结构
 * @param {string} parentId - 父节点ID
 * @param {Object} newNode - 新节点
 * @return {boolean} 是否添加成功
 */
function addNode(tree, parentId, newNode) {
  const parent = findNodeById(tree, parentId);

  if (!parent) return false;

  if (!parent.children) {
    parent.children = [];
  }

  parent.children.push(newNode);
  return true;
}

/**
 * @description 从树中删除指定ID的节点
 * @param {Object|Array} tree - 树结构或节点数组
 * @param {string} id - 要删除的节点ID
 * @return {boolean} 是否删除成功
 */
function removeNode(tree, id) {
  const treeArray = Array.isArray(tree) ? tree : [tree];

  // 处理根节点情况
  for (let i = 0; i < treeArray.length; i++) {
    if (treeArray[i].id === id) {
      treeArray.splice(i, 1);
      return true;
    }
  }

  // 处理子节点情况
  for (const node of treeArray) {
    if (node.children && node.children.length) {
      for (let i = 0; i < node.children.length; i++) {
        if (node.children[i].id === id) {
          node.children.splice(i, 1);
          return true;
        }
      }

      // 递归处理更深层的节点
      if (removeNode(node.children, id)) {
        return true;
      }
    }
  }

  return false;
}

// 使用示例
const sampleTree = {
  id: 'root',
  name: 'Root',
  children: [
    {
      id: 'node1',
      name: 'Node 1',
      children: [
        { id: 'node11', name: 'Node 1.1' }
      ]
    },
    { id: 'node2', name: 'Node 2' }
  ]
};

// 查找节点
const foundNode = findNodeById(sampleTree, 'node11');
console.log('查找结果:', foundNode); // { id: 'node11', name: 'Node 1.1' }

// 查找满足条件的节点
const nodesWithChildren = findNodes(sampleTree, node =>
  node.children && node.children.length > 0
);
console.log('有子节点的节点:', nodesWithChildren.map(n => n.id)); // ['root', 'node1']

// 添加节点
const newNode = { id: 'node21', name: 'Node 2.1' };
addNode(sampleTree, 'node2', newNode);
console.log('添加节点后的树:', JSON.stringify(sampleTree, null, 2));

// 删除节点
removeNode(sampleTree, 'node11');
console.log('删除节点后的树:', JSON.stringify(sampleTree, null, 2));

// 树扁平化
const flatTree = flattenTree(sampleTree);
console.log('扁平化后的树:', flatTree);
```

#### 前端应用实例：组件树渲染

```javascript
/**
 * @description 简单的组件树渲染实现
 */
class Component {
  constructor(props) {
    this.props = props || {};
    this.state = {};
    this.children = [];
  }

  setState(newState) {
    this.state = { ...this.state, ...newState };
    // 状态更新后重新渲染
    this.render();
  }

  addChild(child) {
    this.children.push(child);
    return this;
  }

  render() {
    // 基类render方法，子类应重写此方法
    return '';
  }
}

class VirtualDOM {
  /**
   * @description 将组件树渲染为HTML字符串
   * @param {Component} component - 组件实例
   * @return {string} HTML字符串
   */
  static renderToString(component) {
    if (!component) return '';

    // 获取组件自身的渲染结果
    let result = component.render();

    // 处理子组件
    if (component.children && component.children.length) {
      // 假设render方法返回的HTML中包含 {children} 作为子组件占位符
      const childrenOutput = component.children
        .map(child => VirtualDOM.renderToString(child))
        .join('');

      result = result.replace('{children}', childrenOutput);
    }

    return result;
  }

  /**
   * @description 将组件树渲染到DOM元素中
   * @param {Component} component - 组件实例
   * @param {HTMLElement} container - 容器元素
   */
  static render(component, container) {
    if (!component || !container) return;

    const html = VirtualDOM.renderToString(component);
    container.innerHTML = html;
  }
}

// 示例组件
class ContainerComponent extends Component {
  render() {
    return `<div class="container">
      <h1>${this.props.title}</h1>
      <div class="content">{children}</div>
    </div>`;
  }
}

class ListComponent extends Component {
  render() {
    return `<ul class="list">
      ${this.props.items.map(item => `<li>${item}</li>`).join('')}
    </ul>`;
  }
}

class TextComponent extends Component {
  render() {
    return `<p>${this.props.text}</p>`;
  }
}

// 使用示例
const app = new ContainerComponent({ title: '组件树示例' });
const text = new TextComponent({ text: '这是一段文本内容' });
const list = new ListComponent({ items: ['项目1', '项目2', '项目3'] });

// 构建组件树
app.addChild(text).addChild(list);

// 渲染组件树
console.log(VirtualDOM.renderToString(app));
// 输出HTML字符串:
// <div class="container">
//   <h1>组件树示例</h1>
//   <div class="content">
//     <p>这是一段文本内容</p>
//     <ul class="list">
//       <li>项目1</li>
//       <li>项目2</li>
//       <li>项目3</li>
//     </ul>
//   </div>
// </div>

// 在实际DOM中渲染
// VirtualDOM.render(app, document.getElementById('app'));
```

#### 前端实际应用场景

在前端开发中，树结构操作的常见应用场景包括：

1. **虚拟DOM实现**：使用树结构表示DOM，通过对比新旧虚拟DOM树找出最小变更集合。
2. **组件树管理**：在React、Vue等框架中管理组件的层级结构。
3. **目录/文件系统**：展示和操作文件目录树。
4. **菜单结构**：多级菜单的生成和管理。
5. **树形选择器**：如地区选择器、组织架构选择器等。

```javascript
/**
 * @description 实现一个简单的树形菜单生成器
 * @param {Array} treeData - 树形数据
 * @param {HTMLElement} container - 容器元素
 */
function createTreeMenu(treeData, container) {
  // 创建ul元素
  const ul = document.createElement('ul');
  ul.className = 'tree-menu';

  // 遍历树节点
  treeData.forEach(node => {
    // 创建li元素
    const li = document.createElement('li');
    li.className = 'tree-node';

    // 创建节点标题
    const title = document.createElement('div');
    title.className = 'node-title';
    title.textContent = node.name;

    // 添加点击事件处理
    title.addEventListener('click', function() {
      // 切换展开/折叠状态
      if (childContainer) {
        childContainer.style.display =
          childContainer.style.display === 'none' ? 'block' : 'none';
      }

      // 调用回调函数
      if (typeof node.onClick === 'function') {
        node.onClick(node);
      }
    });

    li.appendChild(title);

    // 处理子节点
    let childContainer = null;
    if (node.children && node.children.length) {
      childContainer = document.createElement('div');
      childContainer.className = 'children-container';

      // 递归创建子菜单
      createTreeMenu(node.children, childContainer);
      li.appendChild(childContainer);
    }

    ul.appendChild(li);
  });

  container.appendChild(ul);
}

// 使用示例
const menuData = [
  {
    name: '系统管理',
    onClick: node => console.log('点击了:', node.name),
    children: [
      { name: '用户管理', onClick: node => console.log('点击了:', node.name) },
      { name: '权限管理', onClick: node => console.log('点击了:', node.name) }
    ]
  },
  {
    name: '内容管理',
    onClick: node => console.log('点击了:', node.name),
    children: [
      { name: '文章管理', onClick: node => console.log('点击了:', node.name) },
      { name: '评论管理', onClick: node => console.log('点击了:', node.name) }
    ]
  }
];

// 在DOM中使用
// const menuContainer = document.getElementById('tree-menu');
// createTreeMenu(menuData, menuContainer);
```

## 前端常见算法面试题

### 1. 实现一个LRU缓存

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return -1;

    // 更新位置（删除后重新插入到最后）
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 删除最久未使用的元素（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}
```

### 2. 实现数组打平(Flatten)

```javascript
// 递归实现
function flatten(arr) {
  let result = [];
  arr.forEach(item => {
    if (Array.isArray(item)) {
      result = result.concat(flatten(item));
    } else {
      result.push(item);
    }
  });
  return result;
}

// 非递归实现
function flattenIterative(arr) {
  return arr.reduce((result, item) => {
    return result.concat(Array.isArray(item) ? flattenIterative(item) : item);
  }, []);
}

// 使用ES6的flat
const flatArray = arr => arr.flat(Infinity);
```

### 3. 实现深拷贝

```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  if (typeof obj !== 'object') return obj;

  // 处理循环引用
  if (hash.has(obj)) return hash.get(obj);

  const cloneObj = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloneObj);

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }

  return cloneObj;
}
```

### 4. 如何设计一个高效的前端状态管理系统？
高效的状态管理系统需要考虑：
- 单一数据源原则
- 状态的不可变性
- 使用观察者模式或发布-订阅模式处理状态变化
- 合理的组件通信机制
- 支持中间件处理副作用

```javascript
/**
 * @description 简单的状态管理系统实现
 */
class Store {
  /**
   * @param {Object} initialState - 初始状态
   * @param {Function} reducer - 状态处理函数
   */
  constructor(initialState = {}, reducer) {
    this.state = initialState;
    this.reducer = reducer;
    this.listeners = [];
    this.middlewares = [];
  }

  /**
   * @description 获取当前状态
   * @return {Object} 当前状态对象
   */
  getState() {
    return this.state;
  }

  /**
   * @description 添加状态变化监听器
   * @param {Function} listener - 监听函数
   * @return {Function} 移除监听器的函数
   */
  subscribe(listener) {
    this.listeners.push(listener);
    // 返回取消订阅的函数
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  /**
   * @description 添加中间件
   * @param {Function} middleware - 中间件函数
   */
  use(middleware) {
    this.middlewares.push(middleware);
  }

  /**
   * @description 分发action
   * @param {Object} action - action对象
   * @return {Object} 分发的action
   */
  dispatch(action) {
    // 应用中间件
    if (this.middlewares.length > 0) {
      const chain = this.middlewares.map(middleware => middleware(this));
      const dispatch = chain.reduce((composed, fn) => fn(composed), this.baseDispatch.bind(this));
      return dispatch(action);
    }
    return this.baseDispatch(action);
  }

  /**
   * @description 基础dispatch实现
   * @param {Object} action - action对象
   * @return {Object} 分发的action
   */
  baseDispatch(action) {
    // 使用reducer计算新状态
    this.state = this.reducer(this.state, action);
    // 通知所有监听器
    this.listeners.forEach(listener => listener(this.state));
    return action;
  }
}

// 使用示例
// 定义reducer
function todoReducer(state = { todos: [] }, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, {
          id: Date.now(),
          text: action.payload,
          completed: false
        }]
      };
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    default:
      return state;
  }
}

// 创建store
const store = new Store({ todos: [] }, todoReducer);

// 添加日志中间件
store.use(store => next => action => {
  console.log('当前状态:', store.getState());
  console.log('分发action:', action);
  const result = next(action);
  console.log('新状态:', store.getState());
  return result;
});

// 订阅状态变化
const unsubscribe = store.subscribe(state => {
  console.log('状态已更新:', state);
  renderTodos(state.todos);
});

// 分发action
store.dispatch({ type: 'ADD_TODO', payload: '学习状态管理' });
store.dispatch({ type: 'ADD_TODO', payload: '完成项目' });
store.dispatch({ type: 'TOGGLE_TODO', payload: store.getState().todos[0].id });

// 渲染函数(示例)
function renderTodos(todos) {
  console.log('渲染待办事项:', todos);
  // 真实项目中这里会操作DOM更新UI
}

// 执行结果示例：
// 当前状态: { todos: [] }
// 分发action: { type: 'ADD_TODO', payload: '学习状态管理' }
// 新状态: { todos: [{ id: 1625764800000, text: '学习状态管理', completed: false }] }
// 状态已更新: { todos: [{ id: 1625764800000, text: '学习状态管理', completed: false }] }
// 渲染待办事项: [{ id: 1625764800000, text: '学习状态管理', completed: false }]
// ...后续操作的日志...
```

**性能考量**:
1. **不可变状态**: 使用浅拷贝或Immer等库确保状态不可变性，便于实现撤销/重做功能。
2. **选择器(Selectors)**: 使用记忆化选择器(如reselect)避免重复计算。
3. **批量更新**: 合并短时间内的多次状态更新减少渲染次数。

### 5. 如何处理前端的大文件上传？
大文件上传可以采用：
- 文件分片上传：将大文件切分成小块上传
- 断点续传：记录已上传的分片，支持中断后继续上传
- MD5校验：避免重复上传相同内容
- 并发控制：控制同时上传的分片数量

```javascript
/**
 * @description 大文件分片上传实现
 */
class ChunkUploader {
  /**
   * @param {Object} options 配置选项
   * @param {number} options.chunkSize 分片大小(bytes)
   * @param {number} options.concurrency 并发上传数量
   * @param {string} options.uploadUrl 上传接口地址
   * @param {Function} options.onProgress 进度回调
   * @param {Function} options.onSuccess 成功回调
   * @param {Function} options.onError 错误回调
   */
  constructor(options) {
    this.chunkSize = options.chunkSize || 2 * 1024 * 1024; // 默认2MB
    this.concurrency = options.concurrency || 3;
    this.uploadUrl = options.uploadUrl;
    this.onProgress = options.onProgress || (() => {});
    this.onSuccess = options.onSuccess || (() => {});
    this.onError = options.onError || (() => {});

    this.uploadQueue = [];
    this.uploadingCount = 0;
    this.uploadedChunks = new Set();
    this.fileHash = null;
    this.totalChunks = 0;
    this.pauseFlag = false;
  }

  /**
   * @description 计算文件MD5哈希值
   * @param {File} file 文件对象
   * @return {Promise<string>} 哈希值
   */
  async calculateFileHash(file) {
    return new Promise((resolve) => {
      // 注意：实际项目中应使用专门的哈希库如spark-md5
      // 这里简化处理，仅用文件名和大小模拟哈希
      const hash = `${file.name}_${file.size}_${Date.now()}`;
      resolve(hash);
    });
  }

  /**
   * @description 分割文件为块
   * @param {File} file 文件对象
   * @return {Array} 分片数组
   */
  createFileChunks(file) {
    const chunks = [];
    let start = 0;

    while (start < file.size) {
      const end = Math.min(start + this.chunkSize, file.size);
      const chunk = file.slice(start, end);
      chunks.push({
        file: chunk,
        start,
        end,
        index: chunks.length
      });
      start = end;
    }

    return chunks;
  }

  /**
   * @description 上传单个分片
   * @param {Object} chunk 分片对象
   * @param {File} file 原始文件
   * @return {Promise} 上传结果
   */
  uploadChunk(chunk, file) {
    return new Promise((resolve, reject) => {
      if (this.pauseFlag) {
        return reject('上传已暂停');
      }

      if (this.uploadedChunks.has(chunk.index)) {
        return resolve({
          chunkIndex: chunk.index,
          skipped: true
        });
      }

      const formData = new FormData();
      formData.append('file', chunk.file);
      formData.append('filename', file.name);
      formData.append('chunkIndex', chunk.index);
      formData.append('chunkSize', this.chunkSize);
      formData.append('chunkCount', this.totalChunks);
      formData.append('fileHash', this.fileHash);

      const xhr = new XMLHttpRequest();
      xhr.open('POST', this.uploadUrl, true);

      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          this.uploadedChunks.add(chunk.index);
          resolve({
            chunkIndex: chunk.index,
            response: xhr.responseText
          });
        } else {
          reject(`上传失败: ${xhr.status} ${xhr.statusText}`);
        }
      };

      xhr.onerror = () => reject('网络错误');
      xhr.ontimeout = () => reject('上传超时');

      xhr.send(formData);
    });
  }

  /**
   * @description 处理上传队列
   */
  processQueue() {
    if (this.pauseFlag) return;

    while (this.uploadingCount < this.concurrency && this.uploadQueue.length > 0) {
      const { chunk, file } = this.uploadQueue.shift();
      this.uploadingCount++;

      this.uploadChunk(chunk, file)
        .then(result => {
          this.uploadingCount--;

          // 计算并通知进度
          const progress = Math.floor((this.uploadedChunks.size / this.totalChunks) * 100);
          this.onProgress(progress, result);

          // 检查是否全部完成
          if (this.uploadedChunks.size === this.totalChunks) {
            this.mergeChunks(file);
          } else {
            this.processQueue();
          }
        })
        .catch(err => {
          this.uploadingCount--;
          // 失败的分片重新入队
          if (!this.pauseFlag) {
            this.uploadQueue.push({ chunk, file });
          }
          console.error('分片上传失败:', err);
          this.processQueue();
        });
    }
  }

  /**
   * @description 通知服务器合并分片
   * @param {File} file 原始文件
   */
  mergeChunks(file) {
    fetch(`${this.uploadUrl}/merge`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        filename: file.name,
        fileHash: this.fileHash,
        chunkCount: this.totalChunks,
        fileSize: file.size
      })
    })
    .then(response => response.json())
    .then(data => {
      console.log('文件合并成功:', data);
      this.onSuccess(data);
    })
    .catch(err => {
      console.error('文件合并失败:', err);
      this.onError(err);
    });
  }

  /**
   * @description 开始上传文件
   * @param {File} file 文件对象
   */
  async upload(file) {
    if (!file) return;

    try {
      this.fileHash = await this.calculateFileHash(file);

      // 检查文件是否已上传(秒传)
      const verifyResponse = await fetch(`${this.uploadUrl}/verify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fileHash: this.fileHash, filename: file.name })
      }).then(res => res.json());

      if (verifyResponse.uploaded) {
        console.log('文件已存在，秒传成功');
        this.onSuccess(verifyResponse);
        return;
      }

      // 恢复上传: 获取已上传的分片
      if (verifyResponse.uploadedChunks && verifyResponse.uploadedChunks.length > 0) {
        verifyResponse.uploadedChunks.forEach(index => {
          this.uploadedChunks.add(index);
        });
        console.log(`已有${this.uploadedChunks.size}个分片上传完成，继续上传剩余部分`);
      }

      // 分割文件
      const chunks = this.createFileChunks(file);
      this.totalChunks = chunks.length;

      // 创建上传队列
      this.uploadQueue = chunks
        .filter(chunk => !this.uploadedChunks.has(chunk.index))
        .map(chunk => ({ chunk, file }));

      console.log(`开始上传，共${this.totalChunks}个分片，${this.uploadQueue.length}个待上传`);

      // 开始处理队列
      this.processQueue();
    } catch (err) {
      console.error('上传过程发生错误:', err);
      this.onError(err);
    }
  }

  /**
   * @description 暂停上传
   */
  pause() {
    this.pauseFlag = true;
    console.log('上传已暂停');
  }

  /**
   * @description 恢复上传
   */
  resume() {
    this.pauseFlag = false;
    console.log('上传已恢复');
    this.processQueue();
  }
}

// 使用示例
function uploadFile(file) {
  const uploader = new ChunkUploader({
    chunkSize: 2 * 1024 * 1024, // 2MB分片
    concurrency: 3,
    uploadUrl: 'https://api.example.com/upload',
    onProgress: (progress, chunkResult) => {
      console.log(`上传进度: ${progress}%`, chunkResult);
      // 更新进度条
      document.getElementById('progress').style.width = `${progress}%`;
    },
    onSuccess: (data) => {
      console.log('上传成功:', data);
      // 显示成功信息
    },
    onError: (err) => {
      console.error('上传失败:', err);
      // 显示错误信息
    }
  });

  // 开始上传
  uploader.upload(file);

  // 绑定暂停/恢复按钮
  document.getElementById('pauseBtn').onclick = () => uploader.pause();
  document.getElementById('resumeBtn').onclick = () => uploader.resume();
}

// 调用示例
document.getElementById('fileInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (file && file.size > 10 * 1024 * 1024) { // 大于10MB使用分片上传
    uploadFile(file);
  } else {
    // 小文件直接上传
    const formData = new FormData();
    formData.append('file', file);
    fetch('https://api.example.com/upload/small', {
      method: 'POST',
      body: formData
    });
  }
});
```

**性能优化点**：
1. **并发控制**: 同时上传多个分片提高效率，但避免过多并发导致网络拥塞
2. **动态分片大小**: 根据网络状况动态调整分片大小
3. **失败重试**: 对失败的分片实施指数退避重试策略
4. **上传进度缓存**: 使用localStorage/IndexedDB存储上传进度，支持页面刷新后恢复

### 6. 解释一下事件循环(Event Loop)及其在异步编程中的作用？

事件循环是JavaScript异步编程的核心机制，负责协调执行栈、回调队列和微任务队列之间的关系，确保代码按正确顺序执行。

```javascript
/**
 * @description 演示事件循环机制
 */
console.log('1. 同步代码开始');

setTimeout(() => {
  console.log('2. 定时器回调 (宏任务)');

  Promise.resolve().then(() => {
    console.log('3. 定时器内的Promise (微任务)');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('4. 首次Promise (微任务)');

  setTimeout(() => {
    console.log('5. Promise中的定时器 (宏任务)');
  }, 0);
});

async function asyncDemo() {
  console.log('6. async函数同步部分');
  await Promise.resolve();
  console.log('7. await之后的代码 (微任务)');
}

asyncDemo();

console.log('8. 同步代码结束');

// 执行结果:
// 1. 同步代码开始
// 6. async函数同步部分
// 8. 同步代码结束
// 4. 首次Promise (微任务)
// 7. await之后的代码 (微任务)
// 2. 定时器回调 (宏任务)
// 3. 定时器内的Promise (微任务)
// 5. Promise中的定时器 (宏任务)
```

**事件循环的工作原理**:

1. **执行栈(Call Stack)**: 执行所有同步代码
2. **微任务队列(Microtask Queue)**: 执行所有微任务，包括:
   - Promise.then/catch/finally回调
   - async/await中await之后的代码
   - process.nextTick (Node.js)
   - MutationObserver回调
3. **宏任务队列(Macrotask Queue)**: 每次事件循环只执行一个宏任务，包括:
   - setTimeout/setInterval回调
   - UI渲染事件
   - I/O操作
   - postMessage
   - setImmediate (Node.js)

**事件循环详细过程**:
```javascript
/**
 * @description 模拟浏览器事件循环
 */
function simulateEventLoop() {
  // 模拟任务队列
  const macroTaskQueue = [];
  const microTaskQueue = [];

  // 模拟添加任务的API
  function setTimeout(callback, delay) {
    macroTaskQueue.push({
      callback,
      executionTime: Date.now() + delay
    });
  }

  function queueMicrotask(callback) {
    microTaskQueue.push({ callback });
  }

  function Promise(executor) {
    this.then = function(onFulfilled) {
      queueMicrotask(onFulfilled);
      return this;
    };

    // 立即执行executor
    executor(() => {}, () => {});
  }

  // 模拟事件循环
  function eventLoopTick() {
    console.log('--- 事件循环开始新的一轮 ---');

    // 1. 执行一个宏任务
    if (macroTaskQueue.length > 0) {
      // 按执行时间排序
      macroTaskQueue.sort((a, b) => a.executionTime - b.executionTime);

      if (macroTaskQueue[0].executionTime <= Date.now()) {
        const task = macroTaskQueue.shift();
        console.log('执行宏任务');
        task.callback();
      }
    }

    // 2. 执行所有微任务
    while (microTaskQueue.length > 0) {
      const task = microTaskQueue.shift();
      console.log('执行微任务');
      task.callback();
    }

    // 3. UI渲染(模拟)
    console.log('UI渲染(如果需要)');

    // 继续下一轮事件循环
    if (macroTaskQueue.length > 0 || microTaskQueue.length > 0) {
      setTimeout(eventLoopTick, 0);
    } else {
      console.log('--- 事件循环结束 ---');
    }
  }

  // 示例代码
  console.log('开始执行同步代码');

  setTimeout(() => {
    console.log('第一个定时器回调');
    new Promise(resolve => {
      console.log('宏任务中的Promise同步代码');
      resolve();
    }).then(() => {
      console.log('宏任务中的Promise的微任务回调');
    });
  }, 1000);

  new Promise(resolve => {
    console.log('同步代码中的Promise');
    resolve();
  }).then(() => {
    console.log('第一个微任务');
    queueMicrotask(() => {
      console.log('微任务中嵌套的微任务');
    });
  });

  setTimeout(() => {
    console.log('第二个定时器回调');
  }, 2000);

  console.log('同步代码结束');

  // 开始事件循环
  eventLoopTick();
}

// 输出分析:
// 首先执行所有同步代码:
//   开始执行同步代码
//   同步代码中的Promise
//   同步代码结束
//   --- 事件循环开始新的一轮 ---
// 然后执行所有微任务:
//   执行微任务
//   第一个微任务
//   执行微任务
//   微任务中嵌套的微任务
//   UI渲染(如果需要)
//   --- 事件循环开始新的一轮 ---
// 第一个定时器时间到达后:
//   执行宏任务
//   第一个定时器回调
//   宏任务中的Promise同步代码
//   UI渲染(如果需要)
//   --- 事件循环开始新的一轮 ---
//   执行微任务
//   宏任务中的Promise的微任务回调
//   UI渲染(如果需要)
// 第二个定时器时间到达后:
//   --- 事件循环开始新的一轮 ---
//   执行宏任务
//   第二个定时器回调
//   UI渲染(如果需要)
//   --- 事件循环结束 ---
```

**实际应用中的考量**:

1. **避免长任务阻塞**: 长时间运行的JavaScript代码会阻塞主线程，导致UI冻结
   ```javascript
   // 不良实践 - 长时间运行的同步代码
   function heavyComputation() {
     let result = 0;
     for (let i = 0; i < 10000000000; i++) {
       result += i;
     }
     return result;
   }

   // 良好实践 - 使用Web Worker或分片处理
   function chunkProcessing(start, end, callback) {
     return new Promise(resolve => {
       setTimeout(() => {
         let result = 0;
         for (let i = start; i < end; i++) {
           result += i;
         }
         callback(result);
         resolve();
       }, 0);
     });
   }

   async function processInChunks() {
     const CHUNK_SIZE = 1000000;
     const TOTAL = 10000000000;
     let finalResult = 0;

     for (let start = 0; start < TOTAL; start += CHUNK_SIZE) {
       const end = Math.min(start + CHUNK_SIZE, TOTAL);
       await chunkProcessing(start, end, result => {
         finalResult += result;
         // 更新进度UI
         updateProgressUI((start + CHUNK_SIZE) / TOTAL * 100);
       });
     }

     return finalResult;
   }
   ```

2. **微任务优先级**: 微任务总是在下一个宏任务之前执行，可用于确保在UI渲染前完成相关操作

3. **避免嵌套过深的定时器**: 浏览器对嵌套定时器有最小间隔限制(通常4ms)
   ```javascript
   // 避免这种写法
   function recursiveTimer() {
     setTimeout(() => {
       // 处理逻辑
       recursiveTimer(); // 导致嵌套定时器
     }, 0);
   }

   // 优选这种写法
   function betterApproach() {
     function tick() {
       // 处理逻辑
       requestAnimationFrame(tick); // 与浏览器刷新同步
     }

     tick();
   }
   ```

**Node.js与浏览器事件循环的区别**:
- Node.js的事件循环更复杂，有多个阶段(timers, pending callbacks, idle/prepare, poll, check, close callbacks)
- process.nextTick在Node.js中优先级最高，比Promise.then还要先执行
- setImmediate在Node.js中用于安排在当前轮poll阶段完成后立即执行的回调

## 实际项目应用场景

1. **搜索建议优化**：使用前缀树(Trie)实现高效的关键词匹配
2. **表单验证**：使用策略模式结合正则表达式
3. **复杂表格**：使用虚拟滚动优化大数据量渲染
4. **图表可视化**：使用数据结构优化和布局算法
5. **路由管理**：使用有限状态机管理复杂的页面状态转换

## 常见面试问题解答

### 1. 在前端开发中，你最常用到哪些算法和数据结构？
在实际前端开发中，我最常用到的算法包括防抖节流、事件委托、递归遍历、排序和搜索算法等。常用的数据结构有数组、对象、Map/Set、树结构等。这些算法和数据结构主要用于处理用户交互、DOM操作优化、数据处理与展示等场景。

### 2. 如何优化大量数据的前端渲染？
优化大量数据渲染可以采用：
- 虚拟列表/虚拟滚动技术，只渲染可视区域的数据
- 时间分片(Time Slicing)，将大任务分割成小任务分批执行
- Web Worker处理数据计算，避免阻塞主线程
- 数据缓存与懒加载策略

### 3. 实现一个简单的前端路由是如何工作的？
前端路由主要有两种实现方式：
- 基于hash(#)：监听hashchange事件，根据hash值渲染对应组件
- 基于History API：使用pushState和replaceState修改URL，监听popstate事件处理前进后退

### 4. 如何设计一个高效的前端状态管理系统？
高效的状态管理系统需要考虑：
- 单一数据源原则
- 状态的不可变性
- 使用观察者模式或发布-订阅模式处理状态变化
- 合理的组件通信机制
- 支持中间件处理副作用

### 5. 如何处理前端的大文件上传？
大文件上传可以采用：
- 文件分片上传：将大文件切分成小块上传
- 断点续传：记录已上传的分片，支持中断后继续上传
- MD5校验：避免重复上传相同内容
- 并发控制：控制同时上传的分片数量

### 6. 解释一下事件循环(Event Loop)及其在异步编程中的作用？

事件循环是JavaScript异步编程的核心机制，负责协调执行栈、回调队列和微任务队列之间的关系，确保代码按正确顺序执行。

```javascript
/**
 * @description 演示事件循环机制
 */
console.log('1. 同步代码开始');

setTimeout(() => {
  console.log('2. 定时器回调 (宏任务)');

  Promise.resolve().then(() => {
    console.log('3. 定时器内的Promise (微任务)');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('4. 首次Promise (微任务)');

  setTimeout(() => {
    console.log('5. Promise中的定时器 (宏任务)');
  }, 0);
});

async function asyncDemo() {
  console.log('6. async函数同步部分');
  await Promise.resolve();
  console.log('7. await之后的代码 (微任务)');
}

asyncDemo();

console.log('8. 同步代码结束');

// 执行结果:
// 1. 同步代码开始
// 6. async函数同步部分
// 8. 同步代码结束
// 4. 首次Promise (微任务)
// 7. await之后的代码 (微任务)
// 2. 定时器回调 (宏任务)
// 3. 定时器内的Promise (微任务)
// 5. Promise中的定时器 (宏任务)
```

**事件循环的工作原理**:

1. **执行栈(Call Stack)**: 执行所有同步代码
2. **微任务队列(Microtask Queue)**: 执行所有微任务，包括:
   - Promise.then/catch/finally回调
   - async/await中await之后的代码
   - process.nextTick (Node.js)
   - MutationObserver回调
3. **宏任务队列(Macrotask Queue)**: 每次事件循环只执行一个宏任务，包括:
   - setTimeout/setInterval回调
   - UI渲染事件
   - I/O操作
   - postMessage
   - setImmediate (Node.js)

**事件循环详细过程**:
```javascript
/**
 * @description 模拟浏览器事件循环
 */
function simulateEventLoop() {
  // 模拟任务队列
  const macroTaskQueue = [];
  const microTaskQueue = [];

  // 模拟添加任务的API
  function setTimeout(callback, delay) {
    macroTaskQueue.push({
      callback,
      executionTime: Date.now() + delay
    });
  }

  function queueMicrotask(callback) {
    microTaskQueue.push({ callback });
  }

  function Promise(executor) {
    this.then = function(onFulfilled) {
      queueMicrotask(onFulfilled);
      return this;
    };

    // 立即执行executor
    executor(() => {}, () => {});
  }

  // 模拟事件循环
  function eventLoopTick() {
    console.log('--- 事件循环开始新的一轮 ---');

    // 1. 执行一个宏任务
    if (macroTaskQueue.length > 0) {
      // 按执行时间排序
      macroTaskQueue.sort((a, b) => a.executionTime - b.executionTime);

      if (macroTaskQueue[0].executionTime <= Date.now()) {
        const task = macroTaskQueue.shift();
        console.log('执行宏任务');
        task.callback();
      }
    }

    // 2. 执行所有微任务
    while (microTaskQueue.length > 0) {
      const task = microTaskQueue.shift();
      console.log('执行微任务');
      task.callback();
    }

    // 3. UI渲染(模拟)
    console.log('UI渲染(如果需要)');

    // 继续下一轮事件循环
    if (macroTaskQueue.length > 0 || microTaskQueue.length > 0) {
      setTimeout(eventLoopTick, 0);
    } else {
      console.log('--- 事件循环结束 ---');
    }
  }

  // 示例代码
  console.log('开始执行同步代码');

  setTimeout(() => {
    console.log('第一个定时器回调');
    new Promise(resolve => {
      console.log('宏任务中的Promise同步代码');
      resolve();
    }).then(() => {
      console.log('宏任务中的Promise的微任务回调');
    });
  }, 1000);

  new Promise(resolve => {
    console.log('同步代码中的Promise');
    resolve();
  }).then(() => {
    console.log('第一个微任务');
    queueMicrotask(() => {
      console.log('微任务中嵌套的微任务');
    });
  });

  setTimeout(() => {
    console.log('第二个定时器回调');
  }, 2000);

  console.log('同步代码结束');

  // 开始事件循环
  eventLoopTick();
}

// 输出分析:
// 首先执行所有同步代码:
//   开始执行同步代码
//   同步代码中的Promise
//   同步代码结束
//   --- 事件循环开始新的一轮 ---
// 然后执行所有微任务:
//   执行微任务
//   第一个微任务
//   执行微任务
//   微任务中嵌套的微任务
//   UI渲染(如果需要)
//   --- 事件循环开始新的一轮 ---
// 第一个定时器时间到达后:
//   执行宏任务
//   第一个定时器回调
//   宏任务中的Promise同步代码
//   UI渲染(如果需要)
//   --- 事件循环开始新的一轮 ---
//   执行微任务
//   宏任务中的Promise的微任务回调
//   UI渲染(如果需要)
// 第二个定时器时间到达后:
//   --- 事件循环开始新的一轮 ---
//   执行宏任务
//   第二个定时器回调
//   UI渲染(如果需要)
//   --- 事件循环结束 ---
```

**实际应用中的考量**:

1. **避免长任务阻塞**: 长时间运行的JavaScript代码会阻塞主线程，导致UI冻结
   ```javascript
   // 不良实践 - 长时间运行的同步代码
   function heavyComputation() {
     let result = 0;
     for (let i = 0; i < 10000000000; i++) {
       result += i;
     }
     return result;
   }

   // 良好实践 - 使用Web Worker或分片处理
   function chunkProcessing(start, end, callback) {
     return new Promise(resolve => {
       setTimeout(() => {
         let result = 0;
         for (let i = start; i < end; i++) {
           result += i;
         }
         callback(result);
         resolve();
       }, 0);
     });
   }

   async function processInChunks() {
     const CHUNK_SIZE = 1000000;
     const TOTAL = 10000000000;
     let finalResult = 0;

     for (let start = 0; start < TOTAL; start += CHUNK_SIZE) {
       const end = Math.min(start + CHUNK_SIZE, TOTAL);
       await chunkProcessing(start, end, result => {
         finalResult += result;
         // 更新进度UI
         updateProgressUI((start + CHUNK_SIZE) / TOTAL * 100);
       });
     }

     return finalResult;
   }
   ```

2. **微任务优先级**: 微任务总是在下一个宏任务之前执行，可用于确保在UI渲染前完成相关操作

3. **避免嵌套过深的定时器**: 浏览器对嵌套定时器有最小间隔限制(通常4ms)
   ```javascript
   // 避免这种写法
   function recursiveTimer() {
     setTimeout(() => {
       // 处理逻辑
       recursiveTimer(); // 导致嵌套定时器
     }, 0);
   }

   // 优选这种写法
   function betterApproach() {
     function tick() {
       // 处理逻辑
       requestAnimationFrame(tick); // 与浏览器刷新同步
     }

     tick();
   }
   ```

**Node.js与浏览器事件循环的区别**:
- Node.js的事件循环更复杂，有多个阶段(timers, pending callbacks, idle/prepare, poll, check, close callbacks)
- process.nextTick在Node.js中优先级最高，比Promise.then还要先执行
- setImmediate在Node.js中用于安排在当前轮poll阶段完成后立即执行的回调
