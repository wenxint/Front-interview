# 排序算法

## 基本概念

排序算法是将一组特定的数据按照某种顺序进行排列的算法。排序算法在计算机科学中非常重要，是许多其他算法的基础，在前端开发中也有广泛的应用。

### 排序算法的分类

1. **比较类排序**：通过比较来决定元素间的相对次序，时间复杂度不能突破O(nlogn)
   - 交换排序（冒泡排序、快速排序）
   - 插入排序（简单插入排序、希尔排序）
   - 选择排序（简单选择排序、堆排序）
   - 归并排序

2. **非比较类排序**：不通过比较来决定元素间的相对次序，可以突破O(nlogn)的限制
   - 计数排序
   - 桶排序
   - 基数排序

### 排序算法的评价指标

- **时间复杂度**：算法执行所需的时间
- **空间复杂度**：算法执行所需的额外空间
- **稳定性**：相等的元素在排序后是否保持原有的相对位置

## 常见排序算法

### 1. 冒泡排序

冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就交换它们，直到没有再需要交换的元素为止。

```javascript
/**
 * @description 冒泡排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(bubbleSort(arr)); // [2, 3, 4, 5, 8]
 */
function bubbleSort(arr) {
  const len = arr.length;

  for (let i = 0; i < len; i++) {
    // 标记当前轮次是否发生交换
    let swapped = false;

    // 每一轮比较相邻元素，大的元素向后移动
    for (let j = 0; j < len - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }

    // 如果没有发生交换，说明数组已经有序，提前退出
    if (!swapped) break;
  }

  return arr;
}

// 调用示例
const bubbleExample = [5, 3, 8, 4, 2];
console.log("原始数组:", bubbleExample);
console.log("冒泡排序后:", bubbleSort([...bubbleExample]));
// 原始数组: [5, 3, 8, 4, 2]
// 冒泡排序后: [2, 3, 4, 5, 8]

// 执行过程分析
// 第1轮：[5, 3, 8, 4, 2] → [3, 5, 4, 2, 8]（8浮到最后）
// 第2轮：[3, 5, 4, 2, 8] → [3, 4, 2, 5, 8]（5浮到倒数第二位）
// 第3轮：[3, 4, 2, 5, 8] → [3, 2, 4, 5, 8]（4浮到倒数第三位）
// 第4轮：[3, 2, 4, 5, 8] → [2, 3, 4, 5, 8]（3浮到倒数第四位）
// 完成排序
```

**时间复杂度**：
- 最好情况：O(n)，当数组已经有序时
- 最坏情况：O(n²)，当数组逆序时
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：稳定

### 2. 选择排序

选择排序是一种简单直观的排序算法，它的工作原理是每次从待排序的数据中选出最小（或最大）的元素，放在已排序序列的末尾。

```javascript
/**
 * @description 选择排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(selectionSort(arr)); // [2, 3, 4, 5, 8]
 */
function selectionSort(arr) {
  const len = arr.length;

  for (let i = 0; i < len - 1; i++) {
    // 假设当前位置的元素是最小的
    let minIndex = i;

    // 在未排序的部分中寻找最小元素
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }

    // 如果找到了更小的元素，交换位置
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }

  return arr;
}

// 调用示例
const selectionExample = [5, 3, 8, 4, 2];
console.log("原始数组:", selectionExample);
console.log("选择排序后:", selectionSort([...selectionExample]));
// 原始数组: [5, 3, 8, 4, 2]
// 选择排序后: [2, 3, 4, 5, 8]

// 执行过程分析
// 第1轮：找到最小元素2，与位置0的5交换 → [2, 3, 8, 4, 5]
// 第2轮：找到未排序部分最小元素3，已在正确位置，不交换 → [2, 3, 8, 4, 5]
// 第3轮：找到未排序部分最小元素4，与位置2的8交换 → [2, 3, 4, 8, 5]
// 第4轮：找到未排序部分最小元素5，与位置3的8交换 → [2, 3, 4, 5, 8]
// 完成排序
```

**时间复杂度**：
- 最好情况：O(n²)
- 最坏情况：O(n²)
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：不稳定

## 前端应用场景

排序算法在前端开发中有着广泛的应用，了解不同排序算法的特点可以帮助我们在实际开发中选择最合适的方案。

### 1. 数据表格排序

在前端开发中，数据表格是最常见的需要排序的场景。用户通常可以点击表头对某一列数据进行排序。

```javascript
/**
 * @description 表格数据排序函数
 * @param {Array} data - 表格数据数组
 * @param {string} key - 排序的键名
 * @param {string} order - 排序方式，'asc'或'desc'
 * @returns {Array} - 排序后的数组
 */
function sortTableData(data, key, order = 'asc') {
  return [...data].sort((a, b) => {
    // 处理不同数据类型
    if (typeof a[key] === 'string') {
      // 字符串排序，考虑本地化比较
      const compareResult = a[key].localeCompare(b[key]);
      return order === 'asc' ? compareResult : -compareResult;
    } else {
      // 数字排序
      const compareResult = a[key] - b[key];
      return order === 'asc' ? compareResult : -compareResult;
    }
  });
}

// 使用示例
const users = [
  { id: 1, name: '张三', age: 28, score: 85 },
  { id: 2, name: '李四', age: 22, score: 90 },
  { id: 3, name: '王五', age: 25, score: 85 },
  { id: 4, name: '赵六', age: 30, score: 78 }
];

// 按年龄升序排序
const sortedByAge = sortTableData(users, 'age', 'asc');
console.log('按年龄升序:', sortedByAge);

// 按姓名降序排序
const sortedByName = sortTableData(users, 'name', 'desc');
console.log('按姓名降序:', sortedByName);
```

#### 多字段排序实现

在复杂的数据表格中，经常需要实现多字段排序功能，例如先按部门排序，再按工资排序：

```javascript
/**
 * @description 多字段表格排序函数
 * @param {Array} data - 表格数据数组
 * @param {Array} sortFields - 排序字段配置数组，格式为[{field, order}]
 * @returns {Array} - 排序后的数组
 */
function multiFieldSort(data, sortFields) {
  return [...data].sort((a, b) => {
    // 遍历排序字段配置
    for (const { field, order } of sortFields) {
      // 获取当前字段的值
      const aValue = a[field];
      const bValue = b[field];

      // 跳过值相等的情况
      if (aValue === bValue) continue;

      // 根据字段类型和排序方向进行比较
      if (typeof aValue === 'string') {
        const result = aValue.localeCompare(bValue);
        return order === 'asc' ? result : -result;
      } else {
        return order === 'asc' ? aValue - bValue : bValue - aValue;
      }
    }

    // 所有字段都相等
    return 0;
  });
}

// 使用示例
const employees = [
  { id: 1, name: '张三', department: '技术部', salary: 15000 },
  { id: 2, name: '李四', department: '市场部', salary: 12000 },
  { id: 3, name: '王五', department: '技术部', salary: 18000 },
  { id: 4, name: '赵六', department: '市场部', salary: 12000 },
  { id: 5, name: '钱七', department: '技术部', salary: 15000 }
];

// 先按部门升序，再按薪资降序排序
const sortConfig = [
  { field: 'department', order: 'asc' },
  { field: 'salary', order: 'desc' }
];

const sortedEmployees = multiFieldSort(employees, sortConfig);
console.log('多字段排序结果:', sortedEmployees);
// 输出结果：先按部门分组，同部门内按薪资从高到低排序
```

### 2. 搜索结果排序

在搜索功能中，通常需要根据相关性、时间等多个维度对结果进行排序。

```javascript
/**
 * @description 搜索结果排序函数
 * @param {Array} results - 搜索结果数组
 * @param {Object} options - 排序选项
 * @returns {Array} - 排序后的结果
 */
function sortSearchResults(results, options = {}) {
  const {
    relevanceWeight = 0.6,  // 相关性权重
    dateWeight = 0.3,       // 日期权重
    popularityWeight = 0.1, // 热度权重
    sortBy = 'combined'     // 排序方式：combined, relevance, date, popularity
  } = options;

  return [...results].sort((a, b) => {
    if (sortBy === 'relevance') {
      return b.relevanceScore - a.relevanceScore;
    } else if (sortBy === 'date') {
      return new Date(b.date) - new Date(a.date);
    } else if (sortBy === 'popularity') {
      return b.views - a.views;
    } else {
      // 综合排序 - 计算加权分数
      const scoreA = (a.relevanceScore * relevanceWeight) +
                    (new Date(a.date).getTime() / 8.64e7 * dateWeight) +
                    (a.views / 1000 * popularityWeight);

      const scoreB = (b.relevanceScore * relevanceWeight) +
                    (new Date(b.date).getTime() / 8.64e7 * dateWeight) +
                    (b.views / 1000 * popularityWeight);

      return scoreB - scoreA;
    }
  });
}

// 使用示例
const searchResults = [
  { id: 1, title: '前端开发基础', relevanceScore: 0.8, date: '2023-05-15', views: 1200 },
  { id: 2, title: '高级JavaScript技巧', relevanceScore: 0.9, date: '2022-11-20', views: 3500 },
  { id: 3, title: 'React性能优化', relevanceScore: 0.7, date: '2023-06-10', views: 800 },
  { id: 4, title: 'Vue3新特性解析', relevanceScore: 0.85, date: '2023-04-05', views: 2200 }
];

// 默认综合排序
const defaultSorted = sortSearchResults(searchResults);
console.log('综合排序结果:', defaultSorted);

// 仅按相关性排序
const relevanceSorted = sortSearchResults(searchResults, { sortBy: 'relevance' });
console.log('相关性排序结果:', relevanceSorted);

// 自定义权重的综合排序
const customSorted = sortSearchResults(searchResults, {
  relevanceWeight: 0.4,
  dateWeight: 0.5,
  popularityWeight: 0.1
});
console.log('自定义权重排序结果:', customSorted);
```

### 3. 拖拽排序实现

在许多前端应用中，需要实现列表项的拖拽排序功能，这也涉及到排序算法的应用。

```javascript
/**
 * @description 拖拽排序组件示例
 */
class DraggableList {
  constructor(containerId, items) {
    this.container = document.getElementById(containerId);
    this.items = items;
    this.draggedItem = null;
    this.draggedIndex = -1;

    this.render();
    this.addEventListeners();
  }

  render() {
    this.container.innerHTML = '';

    this.items.forEach((item, index) => {
      const element = document.createElement('div');
      element.className = 'draggable-item';
      element.setAttribute('draggable', 'true');
      element.setAttribute('data-index', index);
      element.textContent = item.text;

      this.container.appendChild(element);
    });
  }

  addEventListeners() {
    const items = this.container.querySelectorAll('.draggable-item');

    items.forEach(item => {
      // 开始拖拽
      item.addEventListener('dragstart', (e) => {
        this.draggedItem = item;
        this.draggedIndex = parseInt(item.getAttribute('data-index'));
        setTimeout(() => {
          item.classList.add('dragging');
        }, 0);
      });

      // 拖拽结束
      item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
        this.draggedItem = null;
        this.draggedIndex = -1;
      });

      // 拖拽经过其他元素
      item.addEventListener('dragover', (e) => {
        e.preventDefault();
      });

      // 放置
      item.addEventListener('drop', (e) => {
        e.preventDefault();
        if (this.draggedItem) {
          const targetIndex = parseInt(item.getAttribute('data-index'));

          // 执行排序操作
          this.reorderItems(this.draggedIndex, targetIndex);

          // 重新渲染列表
          this.render();
          this.addEventListeners();
        }
      });
    });
  }

  /**
   * 重新排序数组元素
   * @param {number} fromIndex - 起始索引
   * @param {number} toIndex - 目标索引
   */
  reorderItems(fromIndex, toIndex) {
    // 保存被拖拽的元素
    const itemToMove = this.items[fromIndex];

    // 从数组中移除该元素
    this.items.splice(fromIndex, 1);

    // 在新位置插入该元素
    this.items.splice(toIndex, 0, itemToMove);
  }

  // 获取当前排序后的数据
  getItems() {
    return this.items;
  }
}

// 使用示例
const todoItems = [
  { id: 1, text: '完成项目文档' },
  { id: 2, text: '修复页面布局问题' },
  { id: 3, text: '实现新功能' },
  { id: 4, text: '代码审查' },
  { id: 5, text: '部署应用' }
];

// 初始化拖拽列表
// HTML结构: <div id="todo-list"></div>
const todoList = new DraggableList('todo-list', todoItems);

// 获取排序后的数据
console.log('排序后的待办事项:', todoList.getItems());
```

### 4. 自动完成/提示功能

在搜索框的自动完成功能中，需要对推荐结果进行排序，通常是根据匹配度和历史数据。

```javascript
/**
 * @description 自动完成推荐排序
 * @param {string} query - 用户输入的查询字符串
 * @param {Array} suggestions - 候选推荐项数组
 * @param {Object} options - 排序选项
 * @returns {Array} - 排序后的推荐结果
 */
function sortAutocompleteSuggestions(query, suggestions, options = {}) {
  const {
    maxResults = 5,
    useHistory = true,
    historicalSearches = []
  } = options;

  // 计算字符串匹配度分数
  function calculateMatchScore(suggestion, query) {
    const text = suggestion.text.toLowerCase();
    const searchQuery = query.toLowerCase();

    // 完全匹配得分最高
    if (text === searchQuery) return 1;

    // 前缀匹配得分次之
    if (text.startsWith(searchQuery)) return 0.8;

    // 包含匹配再次之
    if (text.includes(searchQuery)) {
      // 单词边界匹配得分更高
      const words = text.split(/\s+/);
      for (const word of words) {
        if (word.startsWith(searchQuery)) return 0.7;
      }
      return 0.5;
    }

    // 编辑距离计算模糊匹配度
    // 这里使用简化版，实际可以用Levenshtein距离算法
    let matchCount = 0;
    for (let i = 0; i < searchQuery.length; i++) {
      if (text.includes(searchQuery[i])) matchCount++;
    }
    return matchCount / searchQuery.length * 0.3;
  }

  // 为每个推荐项计算综合分数
  const scoredSuggestions = suggestions.map(suggestion => {
    // 基础匹配分数
    let score = calculateMatchScore(suggestion, query);

    // 考虑历史搜索频率
    if (useHistory) {
      const historyItem = historicalSearches.find(h => h.text === suggestion.text);
      if (historyItem) {
        // 历史搜索频率加权
        score += Math.min(historyItem.frequency / 10, 0.5);
      }
    }

    // 考虑推荐项自身权重
    if (suggestion.weight) {
      score += suggestion.weight * 0.2;
    }

    return { ...suggestion, score };
  });

  // 按分数排序并限制结果数量
  return scoredSuggestions
    .sort((a, b) => b.score - a.score)
    .slice(0, maxResults);
}

// 使用示例
const userQuery = 'jav';

const allSuggestions = [
  { id: 1, text: 'JavaScript基础教程' },
  { id: 2, text: 'Java编程入门' },
  { id: 3, text: 'JavaScript框架比较' },
  { id: 4, text: 'Python vs JavaScript' },
  { id: 5, text: 'JavaScript设计模式' },
  { id: 6, text: 'Java虚拟机原理' },
  { id: 7, text: 'TypeScript和JavaScript区别' },
  { id: 8, text: '如何学习JavaScript' }
];

const historicalSearches = [
  { text: 'JavaScript基础教程', frequency: 5 },
  { text: 'JavaScript设计模式', frequency: 3 },
  { text: 'Java编程入门', frequency: 2 }
];

// 获取排序后的推荐结果
const sortedSuggestions = sortAutocompleteSuggestions(userQuery, allSuggestions, {
  maxResults: 4,
  useHistory: true,
  historicalSearches
});

console.log('推荐结果:', sortedSuggestions);
```

### 5. 前端排序与后端排序选择

在实际开发中，需要权衡何时使用前端排序，何时使用后端排序。

```javascript
/**
 * @description 前端/后端排序选择辅助函数
 * @param {Array} data - 需要排序的数据
 * @param {Object} options - 排序选项
 * @returns {Object} - 排序策略建议
 */
function determineSortingStrategy(data, options = {}) {
  const {
    dataSize = data.length,
    isInitialLoad = true,
    sortFrequency = 'low', // 'low', 'medium', 'high'
    networkCondition = 'good', // 'poor', 'good', 'excellent'
    serverCapability = 'normal', // 'limited', 'normal', 'powerful'
    clientDevice = 'desktop' // 'mobile', 'desktop', 'powerful'
  } = options;

  // 决策因素评分
  let frontendScore = 0;
  let backendScore = 0;

  // 1. 数据量评估
  if (dataSize < 1000) {
    frontendScore += 3;
  } else if (dataSize < 10000) {
    frontendScore += 1;
    backendScore += 1;
  } else {
    backendScore += 3;
  }

  // 2. 是否初次加载
  if (isInitialLoad) {
    backendScore += 2; // 初次加载通常由后端预排序更高效
  } else {
    frontendScore += 1; // 后续交互排序可以在前端进行
  }

  // 3. 排序频率
  if (sortFrequency === 'high') {
    frontendScore += 2; // 高频排序在前端进行可减少请求
  } else if (sortFrequency === 'medium') {
    frontendScore += 1;
  } else {
    backendScore += 1; // 低频排序可以接受网络延迟
  }

  // 4. 网络状况
  if (networkCondition === 'poor') {
    frontendScore += 2; // 网络不佳时前端排序可减少请求
  } else if (networkCondition === 'excellent') {
    backendScore += 1;
  }

  // 5. 服务器能力
  if (serverCapability === 'powerful') {
    backendScore += 2;
  } else if (serverCapability === 'limited') {
    frontendScore += 2;
  }

  // 6. 客户端设备
  if (clientDevice === 'powerful') {
    frontendScore += 2;
  } else if (clientDevice === 'mobile') {
    backendScore += 1;
  }

  // 决策结果
  const recommendation = {
    strategy: frontendScore > backendScore ? 'frontend' : 'backend',
    frontendScore,
    backendScore,
    reasons: []
  };

  // 添加决策理由
  if (dataSize >= 10000) {
    recommendation.reasons.push('数据量较大，后端排序更高效');
  } else if (dataSize < 1000) {
    recommendation.reasons.push('数据量较小，前端排序响应更快');
  }

  if (sortFrequency === 'high') {
    recommendation.reasons.push('排序频率高，前端排序可减少请求次数');
  }

  if (networkCondition === 'poor') {
    recommendation.reasons.push('网络状况不佳，前端排序可提供更好的用户体验');
  }

  if (clientDevice === 'mobile' && dataSize > 5000) {
    recommendation.reasons.push('移动设备处理大量数据排序可能影响性能');
  }

  return recommendation;
}

// 使用示例
const tableData = Array.from({ length: 8000 }, (_, i) => ({
  id: i + 1,
  name: `Item ${i + 1}`,
  category: ['A', 'B', 'C', 'D'][Math.floor(Math.random() * 4)],
  price: Math.floor(Math.random() * 1000) + 1,
  stock: Math.floor(Math.random() * 100) + 1
}));

// 场景1: 数据表格初始加载
const initialLoadStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: true,
  sortFrequency: 'low',
  networkCondition: 'good',
  serverCapability: 'normal',
  clientDevice: 'desktop'
});
console.log('初始加载排序策略:', initialLoadStrategy);

// 场景2: 用户频繁切换排序条件
const frequentSortingStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: false,
  sortFrequency: 'high',
  networkCondition: 'good',
  serverCapability: 'normal',
  clientDevice: 'desktop'
});
console.log('频繁排序策略:', frequentSortingStrategy);

// 场景3: 移动设备访问
const mobileSortingStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: true,
  sortFrequency: 'medium',
  networkCondition: 'poor',
  serverCapability: 'normal',
  clientDevice: 'mobile'
});
console.log('移动设备排序策略:', mobileSortingStrategy);
```

#### 前端排序与后端排序的选择指南

| 因素 | 前端排序 | 后端排序 |
|------|---------|----------|
| **数据量** | 适合小型数据集(<1000条) | 适合大型数据集(>10000条) |
| **排序频率** | 适合高频排序操作 | 适合低频排序操作 |
| **网络状况** | 适合网络不稳定环境 | 适合网络良好环境 |
| **初始加载** | 不太适合 | 非常适合 |
| **分页数据** | 仅适合当前页数据 | 适合跨页排序 |
| **客户端性能** | 依赖客户端性能 | 不依赖客户端性能 |
| **实现复杂度** | 简单，使用Array.sort即可 | 需要后端API支持 |
| **用户体验** | 即时响应，无加载状态 | 有网络延迟，需要加载状态 |

#### 混合策略最佳实践

在实际项目中，通常采用混合策略：

1. **初始加载**：使用后端排序，与数据获取同时进行
2. **本地交互**：对当前页数据使用前端排序
3. **复杂排序**：多字段排序、模糊匹配等复杂排序使用后端实现
4. **全局排序**：需要对全部数据排序时使用后端排序
5. **缓存策略**：对常用排序结果进行缓存，减少重复计算

## 面试常见问题

### 1. 请解释一下JavaScript中Array.sort()的工作原理，以及它的时间复杂度是多少？

**答案**：

JavaScript中的`Array.sort()`方法的实现因浏览器而异，但大多数现代浏览器采用以下策略：

- 对于小数组（通常少于10-20个元素），使用**插入排序**（时间复杂度O(n²)）
- 对于大数组，使用**快速排序**的变种或**TimSort**（结合了归并排序和插入排序的混合算法）

因此，`Array.sort()`的平均时间复杂度为O(n log n)，但在最坏情况下可能达到O(n²)。

需要注意的是，如果不提供比较函数，`Array.sort()`会将元素转换为字符串，然后按照Unicode编码进行比较，这可能导致意外的排序结果，特别是对数字排序时：

```javascript
// 不提供比较函数的数字排序
const numbers = [10, 5, 40, 25, 1000, 1];
console.log(numbers.sort()); // [1, 10, 1000, 25, 40, 5]

// 正确的数字排序
console.log(numbers.sort((a, b) => a - b)); // [1, 5, 10, 25, 40, 1000]
```

### 2. 在前端开发中，如何优化大数据量表格的排序性能？

**答案**：

优化大数据量表格排序性能的策略包括：

1. **虚拟滚动**：只渲染可视区域的数据，减少DOM操作

```javascript
function createVirtualizedTable(data, containerSelector) {
  const container = document.querySelector(containerSelector);
  const rowHeight = 40; // 每行高度
  const visibleRows = Math.ceil(container.clientHeight / rowHeight);
  let scrollTop = 0;
  let sortedData = [...data];

  // 设置容器总高度
  function updateTotalHeight() {
    container.style.height = `${data.length * rowHeight}px`;
  }

  // 渲染可见行
  function renderVisibleRows() {
    const startIndex = Math.floor(scrollTop / rowHeight);
    const endIndex = Math.min(startIndex + visibleRows + 2, data.length);

    container.innerHTML = '';
    for (let i = startIndex; i < endIndex; i++) {
      const row = document.createElement('div');
      row.className = 'table-row';
      row.style.position = 'absolute';
      row.style.top = `${i * rowHeight}px`;
      row.style.height = `${rowHeight}px`;
      row.textContent = JSON.stringify(sortedData[i]);
      container.appendChild(row);
    }
  }

  // 排序函数
  function sortData(key, direction = 'asc') {
    sortedData = [...data].sort((a, b) => {
      return direction === 'asc' ? a[key] - b[key] : b[key] - a[key];
    });
    renderVisibleRows();
  }

  // 监听滚动事件
  container.addEventListener('scroll', () => {
    scrollTop = container.scrollTop;
    renderVisibleRows();
  });

  updateTotalHeight();
  renderVisibleRows();

  return { sortData };
}
```

2. **Web Worker**：将排序操作放在后台线程中执行，避免阻塞UI

```javascript
// main.js
const worker = new Worker('sort-worker.js');

worker.onmessage = function(e) {
  const { sortedData, requestId } = e.data;
  // 更新UI显示排序后的数据
  updateTableUI(sortedData);
};

function sortTable(data, sortKey, sortOrder) {
  const requestId = Date.now();
  worker.postMessage({
    data,
    sortKey,
    sortOrder,
    requestId
  });
}

// sort-worker.js
self.onmessage = function(e) {
  const { data, sortKey, sortOrder, requestId } = e.data;

  const sortedData = [...data].sort((a, b) => {
    if (sortOrder === 'asc') {
      return a[sortKey] > b[sortKey] ? 1 : -1;
    } else {
      return a[sortKey] < b[sortKey] ? 1 : -1;
    }
  });

  self.postMessage({ sortedData, requestId });
};
```

3. **分页排序**：只对当前页数据进行排序，减少计算量
4. **预排序缓存**：缓存常用排序结果，避免重复计算
5. **防抖处理**：对于用户频繁切换排序条件的情况，使用防抖处理
6. **索引优化**：为大数据集创建索引，加速查找和排序

### 3. 请比较快速排序和归并排序的优缺点，以及它们在前端应用中的适用场景。

**答案**：

**快速排序**：

优点：
- 平均情况下性能优秀，时间复杂度O(n log n)
- 原地排序，空间复杂度O(log n)（递归调用栈）
- 缓存友好，局部性好

缺点：
- 最坏情况下时间复杂度为O(n²)
- 不稳定排序（相等元素的相对位置可能改变）

**归并排序**：

优点：
- 稳定排序（相等元素的相对位置不变）
- 最好、最坏、平均情况下时间复杂度都是O(n log n)
- 适合处理链表等非随机访问的数据结构

缺点：
- 需要额外O(n)的空间复杂度
- 对于小数组，常数因子较大

**适用场景**：

快速排序适用于：
- 内存受限但CPU资源充足的场景
- 对排序稳定性没有要求的场景
- 数据分布较为随机的场景

```javascript
// 前端表格大数据排序，使用快速排序
function quickSortTable(data, key) {
  if (data.length <= 5000) {
    // 数据量不大，直接在主线程排序
    return quickSort(data, key);
  } else {
    // 数据量大，使用Web Worker
    return new Promise(resolve => {
      const worker = new Worker('quicksort-worker.js');
      worker.onmessage = e => {
        resolve(e.data);
        worker.terminate();
      };
      worker.postMessage({ data, key });
    });
  }
}
```

归并排序适用于：
- 需要稳定排序的场景（如保持用户的初始排序偏好）
- 外部排序（数据太大，无法全部加载到内存）
- 对排序结果有可预测性要求的场景

```javascript
// 用户交互历史记录排序，使用归并排序保持相对顺序
function sortUserInteractions(interactions, timestamp) {
  // 使用归并排序保持相同时间戳的交互顺序不变
  return mergeSort(interactions, (a, b) => a[timestamp] - b[timestamp]);
}
```

### 4. 如何实现一个支持多字段排序的数据表格？

**答案**：

实现多字段排序的数据表格需要考虑以下几点：

1. 定义排序优先级
2. 实现比较函数支持多字段比较
3. 提供用户界面支持多字段排序设置

```javascript
/**
 * @description 多字段排序函数
 * @param {Array} data - 要排序的数据数组
 * @param {Array} sortFields - 排序字段配置数组，格式为[{field, direction}]
 * @returns {Array} - 排序后的数组
 */
function multiFieldSort(data, sortFields) {
  return [...data].sort((a, b) => {
    // 依次比较每个排序字段
    for (const { field, direction } of sortFields) {
      // 获取字段值
      const valueA = getNestedValue(a, field);
      const valueB = getNestedValue(b, field);

      // 跳过相等的值
      if (valueA === valueB) continue;

      // 根据字段类型和排序方向比较
      const compareResult = compareValues(valueA, valueB);
      return direction === 'asc' ? compareResult : -compareResult;
    }

    // 所有字段都相等
    return 0;
  });
}

// 获取嵌套对象的值（支持 'user.profile.name' 这样的路径）
function getNestedValue(obj, path) {
  return path.split('.').reduce((o, key) => (o && o[key] !== undefined) ? o[key] : null, obj);
}

// 根据值类型进行比较
function compareValues(a, b) {
  // 处理null和undefined
  if (a === null || a === undefined) return -1;
  if (b === null || b === undefined) return 1;

  // 根据类型比较
  if (typeof a === 'string' && typeof b === 'string') {
    return a.localeCompare(b);
  } else if (a instanceof Date && b instanceof Date) {
    return a - b;
  } else {
    return a < b ? -1 : 1;
  }
}

// 使用示例
const users = [
  { name: 'Alice', age: 30, role: 'Admin', lastLogin: new Date('2023-05-10') },
  { name: 'Bob', age: 25, role: 'User', lastLogin: new Date('2023-06-15') },
  { name: 'Charlie', age: 30, role: 'User', lastLogin: new Date('2023-05-20') },
  { name: 'David', age: 28, role: 'Admin', lastLogin: new Date('2023-06-10') },
  { name: 'Alice', age: 22, role: 'User', lastLogin: new Date('2023-06-05') }
];

// 按角色升序，年龄降序，姓名升序排序
const sortedUsers = multiFieldSort(users, [
  { field: 'role', direction: 'asc' },
  { field: 'age', direction: 'desc' },
  { field: 'name', direction: 'asc' }
]);

console.log(sortedUsers);
```

在React中实现多字段排序的表格组件：

```jsx
import React, { useState, useMemo } from 'react';

function SortableTable({ data, columns }) {
  const [sortConfig, setSortConfig] = useState([]);

  // 处理列标题点击
  const handleHeaderClick = (field) => {
    setSortConfig(prevSortConfig => {
      // 查找当前字段是否已在排序配置中
      const fieldIndex = prevSortConfig.findIndex(config => config.field === field);

      if (fieldIndex >= 0) {
        // 字段已存在，切换排序方向或移除
        const newConfig = [...prevSortConfig];
        if (newConfig[fieldIndex].direction === 'asc') {
          newConfig[fieldIndex].direction = 'desc';
        } else {
          // 已经是降序，移除此排序字段
          newConfig.splice(fieldIndex, 1);
        }
        return newConfig;
      } else {
        // 添加新的排序字段（按住Shift键添加多字段排序）
        if (window.event && window.event.shiftKey) {
          return [...prevSortConfig, { field, direction: 'asc' }];
        } else {
          // 不按Shift则替换所有排序
          return [{ field, direction: 'asc' }];
        }
      }
    });
  };

  // 排序后的数据
  const sortedData = useMemo(() => {
    if (sortConfig.length === 0) return data;
    return multiFieldSort(data, sortConfig);
  }, [data, sortConfig]);

  // 获取列标题的排序指示器
  const getSortIndicator = (field) => {
    const config = sortConfig.find(config => config.field === field);
    if (!config) return null;

    const index = sortConfig.indexOf(config) + 1;
    return (
      <span className="sort-indicator">
        {config.direction === 'asc' ? '↑' : '↓'}
        {sortConfig.length > 1 && <sup>{index}</sup>}
      </span>
    );
  };

  return (
    <table className="sortable-table">
      <thead>
        <tr>
          {columns.map(column => (
            <th
              key={column.field}
              onClick={() => handleHeaderClick(column.field)}
              className={sortConfig.some(config => config.field === column.field) ? 'sorted' : ''}
            >
              {column.title} {getSortIndicator(column.field)}
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {sortedData.map((row, rowIndex) => (
          <tr key={rowIndex}>
            {columns.map(column => (
              <td key={column.field}>{row[column.field]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

### 5. 如何在不使用Array.sort()的情况下，实现一个稳定的排序算法？

**答案**：

可以实现一个稳定的归并排序算法，它能保证相等元素的相对顺序不变：

```javascript
/**
 * @description 稳定的归并排序实现
 * @param {Array} arr - 要排序的数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 排序后的新数组
 */
function stableMergeSort(arr, compareFn = (a, b) => a - b) {
  // 基本情况：数组长度为0或1时已经排序
  if (arr.length <= 1) return [...arr];

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = stableMergeSort(arr.slice(0, mid), compareFn);
  const right = stableMergeSort(arr.slice(mid), compareFn);

  // 合并两个已排序的数组
  return merge(left, right, compareFn);
}

/**
 * @description 合并两个已排序的数组
 * @param {Array} left - 左侧已排序数组
 * @param {Array} right - 右侧已排序数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 合并后的已排序数组
 */
function merge(left, right, compareFn) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较并合并两个数组
  while (leftIndex < left.length && rightIndex < right.length) {
    // 使用 <= 0 而不是 < 0 来确保稳定性
    // 当比较结果为0（相等）时，优先选择左侧数组的元素
    if (compareFn(left[leftIndex], right[rightIndex]) <= 0) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 添加剩余元素
  return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}

// 使用示例：对对象数组进行稳定排序
const students = [
  { name: 'Alice', grade: 'A', enrollmentOrder: 1 },
  { name: 'Bob', grade: 'B', enrollmentOrder: 2 },
  { name: 'Charlie', grade: 'A', enrollmentOrder: 3 },
  { name: 'David', grade: 'C', enrollmentOrder: 4 },
  { name: 'Eve', grade: 'B', enrollmentOrder: 5 },
  { name: 'Frank', grade: 'A', enrollmentOrder: 6 }
];

// 按成绩排序，成绩相同时保持原有顺序
const sortedByGrade = stableMergeSort(students, (a, b) => {
  // 按字母顺序比较成绩（A > B > C）
  return a.grade.localeCompare(b.grade);
});

console.log('按成绩排序（稳定）:', sortedByGrade);
// 可以看到所有成绩为A的学生（Alice, Charlie, Frank）保持了原有的相对顺序
```

稳定排序在以下场景特别有用：

1. **多级排序**：先按一个条件排序，再按另一个条件排序
2. **保持用户意图**：如用户手动调整过的项目顺序
3. **动画过渡**：在数据可视化中，稳定排序可以使元素位置变化更可预测，便于实现平滑过渡

除了归并排序，其他稳定的排序算法还包括：
- 插入排序
- 冒泡排序
- 计数排序
- 基数排序

而不稳定的排序算法包括：
- 快速排序
- 堆排序
- 选择排序

```javascript
/**
 * @description 搜索结果多维度排序
 * @param {Array} results - 搜索结果数组
 * @param {Object} weights - 各维度的权重，如{relevance: 0.6, date: 0.4}
 * @returns {Array} - 排序后的结果
 */
function sortSearchResults(results, weights) {
  return [...results].sort((a, b) => {
    // 计算加权得分
    const scoreA = calculateScore(a, weights);
    const scoreB = calculateScore(b, weights);

    // 降序排列（得分高的排前面）
    return scoreB - scoreA;
  });
}

/**
 * @description 计算单个结果的加权得分
 * @param {Object} item - 搜索结果项
 * @param {Object} weights - 权重对象
 * @returns {number} - 加权得分
 */
function calculateScore(item, weights) {
  let score = 0;

  // 相关性得分 (0-1)
  if ('relevance' in weights) {
    score += item.relevance * weights.relevance;
  }

  // 日期得分 (将日期转换为0-1的分数，越新越高)
  if ('date' in weights) {
    const now = new Date();
    const itemDate = new Date(item.date);
    const ageInDays = (now - itemDate) / (1000 * 60 * 60 * 24);
    const dateScore = Math.max(0, 1 - ageInDays / 365); // 一年以内的文档
    score += dateScore * weights.date;
  }

  return score;
}
```

### 3. 自动完成/提示功能

在输入框的自动完成功能中，需要对推荐结果进行排序，通常基于匹配度和使用频率。

```javascript
/**
 * @description 自动完成推荐结果排序
 * @param {string} input - 用户输入
 * @param {Array} suggestions - 候选推荐项
 * @returns {Array} - 排序后的推荐结果
 */
function sortAutocompleteSuggestions(input, suggestions) {
  const lowerInput = input.toLowerCase();

  // 计算每个推荐项的得分
  const scoredSuggestions = suggestions.map(item => {
    const text = item.text.toLowerCase();
    let score = 0;

    // 1. 精确匹配开头（最高优先级）
    if (text.startsWith(lowerInput)) {
      score += 100;
    }
    // 2. 包含输入文本
    else if (text.includes(lowerInput)) {
      score += 50;
    }

    // 3. 考虑历史使用频率
    score += (item.frequency || 0) * 0.5;

    return { ...item, score };
  });

  // 按得分降序排序
  return scoredSuggestions
    .filter(item => item.score > 0) // 只返回有相关性的结果
    .sort((a, b) => b.score - a.score);
}
```

### 4. 拖拽排序

在支持拖拽排序的列表中，需要在用户交互后重新排序元素。

```javascript
/**
 * @description 处理列表拖拽排序
 * @param {Array} list - 原列表数据
 * @param {number} fromIndex - 拖拽项的原始索引
 * @param {number} toIndex - 拖拽项的目标索引
 * @returns {Array} - 重新排序后的列表
 */
function handleDragSort(list, fromIndex, toIndex) {
  const result = [...list];
  const [removed] = result.splice(fromIndex, 1);
  result.splice(toIndex, 0, removed);
  return result;
}

// 使用示例（React组件中）
/*
const [items, setItems] = useState(['项目1', '项目2', '项目3', '项目4']);

const onDragEnd = (result) => {
  // 拖拽结束时调用
  if (!result.destination) return;

  const newItems = handleDragSort(
    items,
    result.source.index,
    result.destination.index
  );

  setItems(newItems);
};
*/
```

### 5. 前端排序与后端排序的选择

在实际开发中，需要根据数据量和性能要求选择在前端还是后端进行排序。

```javascript
/**
 * @description 智能排序策略选择器
 * @param {Array} data - 数据数组
 * @param {string} key - 排序键
 * @param {string} order - 排序方式
 * @param {Object} options - 配置选项
 * @returns {Promise<Array>} - 排序后的数据
 */
async function smartSort(data, key, order, options = {}) {
  const {
    threshold = 1000, // 前端排序的数据量阈值
    apiEndpoint = '/api/sort', // 后端排序API
    forceClient = false, // 强制前端排序
    forceServer = false // 强制后端排序
  } = options;

  // 强制选择排序位置
  if (forceClient) {
    return clientSideSort(data, key, order);
  }

  if (forceServer) {
    return serverSideSort(data, key, order, apiEndpoint);
  }

  // 根据数据量智能选择
  if (data.length <= threshold) {
    return clientSideSort(data, key, order);
  } else {
    return serverSideSort(data, key, order, apiEndpoint);
  }
}

// 前端排序实现
function clientSideSort(data, key, order) {
  console.log('使用前端排序');
  return Promise.resolve([...data].sort((a, b) => {
    const compareResult = a[key] < b[key] ? -1 : a[key] > b[key] ? 1 : 0;
    return order === 'asc' ? compareResult : -compareResult;
  }));
}

// 后端排序实现
async function serverSideSort(data, key, order, apiEndpoint) {
  console.log('使用后端排序');
  try {
    // 这里只是示例，实际应用中可能只需要发送必要的参数
    const response = await fetch(apiEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data, key, order })
    });

    if (!response.ok) {
      throw new Error('排序请求失败');
    }

    return await response.json();
  } catch (error) {
    console.error('后端排序失败，回退到前端排序', error);
    return clientSideSort(data, key, order);
  }
}
```

## 算法选择指南

在前端开发中，选择合适的排序算法需要考虑以下因素：

1. **数据规模**：数据量大小直接影响算法选择
2. **数据特征**：数据是否接近有序、是否有大量重复元素等
3. **稳定性要求**：是否需要保持相等元素的相对顺序
4. **空间限制**：是否有额外空间使用的限制
5. **实现复杂度**：在时间紧迫的情况下，可能优先考虑实现简单的算法

### 常见场景的算法选择

| 场景 | 推荐算法 | 理由 |
|------|---------|------|
| 小数据量（<50） | 插入排序 | 常数因子小，实现简单 |
| 接近有序的数据 | 插入排序 | 时间复杂度接近O(n) |
| 大数据量通用场景 | 快速排序 | 平均性能最佳，原地排序 |
| 对稳定性有要求 | 归并排序 | 稳定的O(n log n)算法 |
| 外部排序（数据量超过内存） | 归并排序 | 可以分块处理 |
| 包含多种数据类型 | Array.sort() + 比较函数 | 浏览器优化，处理复杂情况 |
| 有大量重复元素 | 三路快排 | 有效处理重复元素 |

### JavaScript内置排序方法的选择

在实际开发中，通常使用JavaScript的内置方法：

```javascript
// 1. Array.prototype.sort()
// 优点：内置、方便、浏览器优化
// 缺点：不同浏览器实现可能不同
const sortedArray = array.sort((a, b) => a - b);

// 2. Lodash的_.sortBy()
// 优点：API简洁，支持多重排序
// 缺点：需要引入额外库
// const sortedArray = _.sortBy(array, item => item.value);

// 3. 自定义排序
// 优点：完全控制排序逻辑
// 缺点：需要自己实现和维护
function customSort(array) {
  // 根据需求选择合适的排序算法实现
}
```

### 排序算法可视化资源

以下是一些帮助理解排序算法的可视化资源：

1. [VisuAlgo - 排序算法可视化](https://visualgo.net/en/sorting)
2. [排序算法动画演示](https://www.toptal.com/developers/sorting-algorithms)
3. [USF排序算法可视化](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)（相同元素的相对位置可能改变）

### 3. 插入排序

插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

```javascript
/**
 * @description 插入排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(insertionSort(arr)); // [2, 3, 4, 5, 8]
 */
function insertionSort(arr) {
  const len = arr.length;

  for (let i = 1; i < len; i++) {
    // 当前要插入的元素
    const current = arr[i];
    let j = i - 1;

    // 寻找插入位置，将大于current的元素向后移动
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }

    // 插入元素到正确位置
    arr[j + 1] = current;
  }

  return arr;
}

// 调用示例
const insertionExample = [5, 3, 8, 4, 2];
console.log("原始数组:", insertionExample);
console.log("插入排序后:", insertionSort([...insertionExample]));
// 原始数组: [5, 3, 8, 4, 2]
// 插入排序后: [2, 3, 4, 5, 8]

// 执行过程分析
// 初始状态：[5] | [3, 8, 4, 2] (已排序部分 | 未排序部分)
// 处理3：将3插入到5前面 → [3, 5] | [8, 4, 2]
// 处理8：将8插入到5后面 → [3, 5, 8] | [4, 2]
// 处理4：将4插入到5前面 → [3, 4, 5, 8] | [2]
// 处理2：将2插入到3前面 → [2, 3, 4, 5, 8] | []
// 完成排序
```

**时间复杂度**：
- 最好情况：O(n)，当数组已经有序时
- 最坏情况：O(n²)，当数组逆序时
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：稳定

### 4. 希尔排序

希尔排序是插入排序的一种改进版本，它通过将整个数组分为多个子数组分别进行插入排序，逐步缩小增量，最终完成整个数组的排序。

```javascript
/**
 * @description 希尔排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(shellSort(arr)); // [2, 3, 4, 5, 8]
 */
function shellSort(arr) {
  const len = arr.length;
  // 初始间隔设为数组长度的一半
  let gap = Math.floor(len / 2);

  // 不断缩小间隔直到为1
  while (gap > 0) {
    // 对每一个子序列进行插入排序
    for (let i = gap; i < len; i++) {
      const temp = arr[i];
      let j = i;

      // 对间隔为gap的元素进行比较和移动
      while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap];
        j -= gap;
      }

      // 放入正确位置
      arr[j] = temp;
    }

    // 缩小间隔
    gap = Math.floor(gap / 2);
  }

  return arr;
}

// 调用示例
const shellExample = [5, 3, 8, 4, 2, 9, 1, 7, 6];
console.log("原始数组:", shellExample);
console.log("希尔排序后:", shellSort([...shellExample]));
// 原始数组: [5, 3, 8, 4, 2, 9, 1, 7, 6]
// 希尔排序后: [1, 2, 3, 4, 5, 6, 7, 8, 9]

// 执行过程分析（以长度为9的数组为例）
// 初始状态：[5, 3, 8, 4, 2, 9, 1, 7, 6]
// gap = 4：
//   比较并排序[5, 2]、[3, 9]、[8, 1]、[4, 7]、[4, 6]
//   结果：[2, 3, 1, 4, 5, 9, 8, 7, 6]
// gap = 2：
//   比较并排序[2, 1, 5, 8, 6]和[3, 4, 9, 7]
//   结果：[1, 2, 3, 4, 5, 6, 7, 8, 9]
// gap = 1：
//   进行最后一次普通插入排序
//   结果：[1, 2, 3, 4, 5, 6, 7, 8, 9]
// 完成排序
```

**时间复杂度**：
- 最好情况：O(n log² n)
- 最坏情况：O(n²)，取决于间隔序列
- 平均情况：O(n log² n)

**空间复杂度**：O(1)

**稳定性**：不稳定

## 前端应用场景

排序算法在前端开发中有着广泛的应用，了解不同排序算法的特点可以帮助我们在实际开发中选择最合适的方案。

### 1. 数据表格排序

在前端开发中，数据表格是最常见的需要排序的场景。用户通常可以点击表头对某一列数据进行排序。

```javascript
/**
 * @description 表格数据排序函数
 * @param {Array} data - 表格数据数组
 * @param {string} key - 排序的键名
 * @param {string} order - 排序方式，'asc'或'desc'
 * @returns {Array} - 排序后的数组
 */
function sortTableData(data, key, order = 'asc') {
  return [...data].sort((a, b) => {
    // 处理不同数据类型
    if (typeof a[key] === 'string') {
      // 字符串排序，考虑本地化比较
      const compareResult = a[key].localeCompare(b[key]);
      return order === 'asc' ? compareResult : -compareResult;
    } else {
      // 数字排序
      const compareResult = a[key] - b[key];
      return order === 'asc' ? compareResult : -compareResult;
    }
  });
}

// 使用示例
const users = [
  { id: 1, name: '张三', age: 28, score: 85 },
  { id: 2, name: '李四', age: 22, score: 90 },
  { id: 3, name: '王五', age: 25, score: 85 },
  { id: 4, name: '赵六', age: 30, score: 78 }
];

// 按年龄升序排序
const sortedByAge = sortTableData(users, 'age', 'asc');
console.log('按年龄升序:', sortedByAge);

// 按姓名降序排序
const sortedByName = sortTableData(users, 'name', 'desc');
console.log('按姓名降序:', sortedByName);
```

#### 多字段排序实现

在复杂的数据表格中，经常需要实现多字段排序功能，例如先按部门排序，再按工资排序：

```javascript
/**
 * @description 多字段表格排序函数
 * @param {Array} data - 表格数据数组
 * @param {Array} sortFields - 排序字段配置数组，格式为[{field, order}]
 * @returns {Array} - 排序后的数组
 */
function multiFieldSort(data, sortFields) {
  return [...data].sort((a, b) => {
    // 遍历排序字段配置
    for (const { field, order } of sortFields) {
      // 获取当前字段的值
      const aValue = a[field];
      const bValue = b[field];

      // 跳过值相等的情况
      if (aValue === bValue) continue;

      // 根据字段类型和排序方向进行比较
      if (typeof aValue === 'string') {
        const result = aValue.localeCompare(bValue);
        return order === 'asc' ? result : -result;
      } else {
        return order === 'asc' ? aValue - bValue : bValue - aValue;
      }
    }

    // 所有字段都相等
    return 0;
  });
}

// 使用示例
const employees = [
  { id: 1, name: '张三', department: '技术部', salary: 15000 },
  { id: 2, name: '李四', department: '市场部', salary: 12000 },
  { id: 3, name: '王五', department: '技术部', salary: 18000 },
  { id: 4, name: '赵六', department: '市场部', salary: 12000 },
  { id: 5, name: '钱七', department: '技术部', salary: 15000 }
];

// 先按部门升序，再按薪资降序排序
const sortConfig = [
  { field: 'department', order: 'asc' },
  { field: 'salary', order: 'desc' }
];

const sortedEmployees = multiFieldSort(employees, sortConfig);
console.log('多字段排序结果:', sortedEmployees);
// 输出结果：先按部门分组，同部门内按薪资从高到低排序
```

### 2. 搜索结果排序

在搜索功能中，通常需要根据相关性、时间等多个维度对结果进行排序。

```javascript
/**
 * @description 搜索结果排序函数
 * @param {Array} results - 搜索结果数组
 * @param {Object} options - 排序选项
 * @returns {Array} - 排序后的结果
 */
function sortSearchResults(results, options = {}) {
  const {
    relevanceWeight = 0.6,  // 相关性权重
    dateWeight = 0.3,       // 日期权重
    popularityWeight = 0.1, // 热度权重
    sortBy = 'combined'     // 排序方式：combined, relevance, date, popularity
  } = options;

  return [...results].sort((a, b) => {
    if (sortBy === 'relevance') {
      return b.relevanceScore - a.relevanceScore;
    } else if (sortBy === 'date') {
      return new Date(b.date) - new Date(a.date);
    } else if (sortBy === 'popularity') {
      return b.views - a.views;
    } else {
      // 综合排序 - 计算加权分数
      const scoreA = (a.relevanceScore * relevanceWeight) +
                    (new Date(a.date).getTime() / 8.64e7 * dateWeight) +
                    (a.views / 1000 * popularityWeight);

      const scoreB = (b.relevanceScore * relevanceWeight) +
                    (new Date(b.date).getTime() / 8.64e7 * dateWeight) +
                    (b.views / 1000 * popularityWeight);

      return scoreB - scoreA;
    }
  });
}

// 使用示例
const searchResults = [
  { id: 1, title: '前端开发基础', relevanceScore: 0.8, date: '2023-05-15', views: 1200 },
  { id: 2, title: '高级JavaScript技巧', relevanceScore: 0.9, date: '2022-11-20', views: 3500 },
  { id: 3, title: 'React性能优化', relevanceScore: 0.7, date: '2023-06-10', views: 800 },
  { id: 4, title: 'Vue3新特性解析', relevanceScore: 0.85, date: '2023-04-05', views: 2200 }
];

// 默认综合排序
const defaultSorted = sortSearchResults(searchResults);
console.log('综合排序结果:', defaultSorted);

// 仅按相关性排序
const relevanceSorted = sortSearchResults(searchResults, { sortBy: 'relevance' });
console.log('相关性排序结果:', relevanceSorted);

// 自定义权重的综合排序
const customSorted = sortSearchResults(searchResults, {
  relevanceWeight: 0.4,
  dateWeight: 0.5,
  popularityWeight: 0.1
});
console.log('自定义权重排序结果:', customSorted);
```

### 3. 拖拽排序实现

在许多前端应用中，需要实现列表项的拖拽排序功能，这也涉及到排序算法的应用。

```javascript
/**
 * @description 拖拽排序组件示例
 */
class DraggableList {
  constructor(containerId, items) {
    this.container = document.getElementById(containerId);
    this.items = items;
    this.draggedItem = null;
    this.draggedIndex = -1;

    this.render();
    this.addEventListeners();
  }

  render() {
    this.container.innerHTML = '';

    this.items.forEach((item, index) => {
      const element = document.createElement('div');
      element.className = 'draggable-item';
      element.setAttribute('draggable', 'true');
      element.setAttribute('data-index', index);
      element.textContent = item.text;

      this.container.appendChild(element);
    });
  }

  addEventListeners() {
    const items = this.container.querySelectorAll('.draggable-item');

    items.forEach(item => {
      // 开始拖拽
      item.addEventListener('dragstart', (e) => {
        this.draggedItem = item;
        this.draggedIndex = parseInt(item.getAttribute('data-index'));
        setTimeout(() => {
          item.classList.add('dragging');
        }, 0);
      });

      // 拖拽结束
      item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
        this.draggedItem = null;
        this.draggedIndex = -1;
      });

      // 拖拽经过其他元素
      item.addEventListener('dragover', (e) => {
        e.preventDefault();
      });

      // 放置
      item.addEventListener('drop', (e) => {
        e.preventDefault();
        if (this.draggedItem) {
          const targetIndex = parseInt(item.getAttribute('data-index'));

          // 执行排序操作
          this.reorderItems(this.draggedIndex, targetIndex);

          // 重新渲染列表
          this.render();
          this.addEventListeners();
        }
      });
    });
  }

  /**
   * 重新排序数组元素
   * @param {number} fromIndex - 起始索引
   * @param {number} toIndex - 目标索引
   */
  reorderItems(fromIndex, toIndex) {
    // 保存被拖拽的元素
    const itemToMove = this.items[fromIndex];

    // 从数组中移除该元素
    this.items.splice(fromIndex, 1);

    // 在新位置插入该元素
    this.items.splice(toIndex, 0, itemToMove);
  }

  // 获取当前排序后的数据
  getItems() {
    return this.items;
  }
}

// 使用示例
const todoItems = [
  { id: 1, text: '完成项目文档' },
  { id: 2, text: '修复页面布局问题' },
  { id: 3, text: '实现新功能' },
  { id: 4, text: '代码审查' },
  { id: 5, text: '部署应用' }
];

// 初始化拖拽列表
// HTML结构: <div id="todo-list"></div>
const todoList = new DraggableList('todo-list', todoItems);

// 获取排序后的数据
console.log('排序后的待办事项:', todoList.getItems());
```

### 4. 自动完成/提示功能

在搜索框的自动完成功能中，需要对推荐结果进行排序，通常是根据匹配度和历史数据。

```javascript
/**
 * @description 自动完成推荐排序
 * @param {string} query - 用户输入的查询字符串
 * @param {Array} suggestions - 候选推荐项数组
 * @param {Object} options - 排序选项
 * @returns {Array} - 排序后的推荐结果
 */
function sortAutocompleteSuggestions(query, suggestions, options = {}) {
  const {
    maxResults = 5,
    useHistory = true,
    historicalSearches = []
  } = options;

  // 计算字符串匹配度分数
  function calculateMatchScore(suggestion, query) {
    const text = suggestion.text.toLowerCase();
    const searchQuery = query.toLowerCase();

    // 完全匹配得分最高
    if (text === searchQuery) return 1;

    // 前缀匹配得分次之
    if (text.startsWith(searchQuery)) return 0.8;

    // 包含匹配再次之
    if (text.includes(searchQuery)) {
      // 单词边界匹配得分更高
      const words = text.split(/\s+/);
      for (const word of words) {
        if (word.startsWith(searchQuery)) return 0.7;
      }
      return 0.5;
    }

    // 编辑距离计算模糊匹配度
    // 这里使用简化版，实际可以用Levenshtein距离算法
    let matchCount = 0;
    for (let i = 0; i < searchQuery.length; i++) {
      if (text.includes(searchQuery[i])) matchCount++;
    }
    return matchCount / searchQuery.length * 0.3;
  }

  // 为每个推荐项计算综合分数
  const scoredSuggestions = suggestions.map(suggestion => {
    // 基础匹配分数
    let score = calculateMatchScore(suggestion, query);

    // 考虑历史搜索频率
    if (useHistory) {
      const historyItem = historicalSearches.find(h => h.text === suggestion.text);
      if (historyItem) {
        // 历史搜索频率加权
        score += Math.min(historyItem.frequency / 10, 0.5);
      }
    }

    // 考虑推荐项自身权重
    if (suggestion.weight) {
      score += suggestion.weight * 0.2;
    }

    return { ...suggestion, score };
  });

  // 按分数排序并限制结果数量
  return scoredSuggestions
    .sort((a, b) => b.score - a.score)
    .slice(0, maxResults);
}

// 使用示例
const userQuery = 'jav';

const allSuggestions = [
  { id: 1, text: 'JavaScript基础教程' },
  { id: 2, text: 'Java编程入门' },
  { id: 3, text: 'JavaScript框架比较' },
  { id: 4, text: 'Python vs JavaScript' },
  { id: 5, text: 'JavaScript设计模式' },
  { id: 6, text: 'Java虚拟机原理' },
  { id: 7, text: 'TypeScript和JavaScript区别' },
  { id: 8, text: '如何学习JavaScript' }
];

const historicalSearches = [
  { text: 'JavaScript基础教程', frequency: 5 },
  { text: 'JavaScript设计模式', frequency: 3 },
  { text: 'Java编程入门', frequency: 2 }
];

// 获取排序后的推荐结果
const sortedSuggestions = sortAutocompleteSuggestions(userQuery, allSuggestions, {
  maxResults: 4,
  useHistory: true,
  historicalSearches
});

console.log('推荐结果:', sortedSuggestions);
```

### 5. 前端排序与后端排序选择

在实际开发中，需要权衡何时使用前端排序，何时使用后端排序。

```javascript
/**
 * @description 前端/后端排序选择辅助函数
 * @param {Array} data - 需要排序的数据
 * @param {Object} options - 排序选项
 * @returns {Object} - 排序策略建议
 */
function determineSortingStrategy(data, options = {}) {
  const {
    dataSize = data.length,
    isInitialLoad = true,
    sortFrequency = 'low', // 'low', 'medium', 'high'
    networkCondition = 'good', // 'poor', 'good', 'excellent'
    serverCapability = 'normal', // 'limited', 'normal', 'powerful'
    clientDevice = 'desktop' // 'mobile', 'desktop', 'powerful'
  } = options;

  // 决策因素评分
  let frontendScore = 0;
  let backendScore = 0;

  // 1. 数据量评估
  if (dataSize < 1000) {
    frontendScore += 3;
  } else if (dataSize < 10000) {
    frontendScore += 1;
    backendScore += 1;
  } else {
    backendScore += 3;
  }

  // 2. 是否初次加载
  if (isInitialLoad) {
    backendScore += 2; // 初次加载通常由后端预排序更高效
  } else {
    frontendScore += 1; // 后续交互排序可以在前端进行
  }

  // 3. 排序频率
  if (sortFrequency === 'high') {
    frontendScore += 2; // 高频排序在前端进行可减少请求
  } else if (sortFrequency === 'medium') {
    frontendScore += 1;
  } else {
    backendScore += 1; // 低频排序可以接受网络延迟
  }

  // 4. 网络状况
  if (networkCondition === 'poor') {
    frontendScore += 2; // 网络不佳时前端排序可减少请求
  } else if (networkCondition === 'excellent') {
    backendScore += 1;
  }

  // 5. 服务器能力
  if (serverCapability === 'powerful') {
    backendScore += 2;
  } else if (serverCapability === 'limited') {
    frontendScore += 2;
  }

  // 6. 客户端设备
  if (clientDevice === 'powerful') {
    frontendScore += 2;
  } else if (clientDevice === 'mobile') {
    backendScore += 1;
  }

  // 决策结果
  const recommendation = {
    strategy: frontendScore > backendScore ? 'frontend' : 'backend',
    frontendScore,
    backendScore,
    reasons: []
  };

  // 添加决策理由
  if (dataSize >= 10000) {
    recommendation.reasons.push('数据量较大，后端排序更高效');
  } else if (dataSize < 1000) {
    recommendation.reasons.push('数据量较小，前端排序响应更快');
  }

  if (sortFrequency === 'high') {
    recommendation.reasons.push('排序频率高，前端排序可减少请求次数');
  }

  if (networkCondition === 'poor') {
    recommendation.reasons.push('网络状况不佳，前端排序可提供更好的用户体验');
  }

  if (clientDevice === 'mobile' && dataSize > 5000) {
    recommendation.reasons.push('移动设备处理大量数据排序可能影响性能');
  }

  return recommendation;
}

// 使用示例
const tableData = Array.from({ length: 8000 }, (_, i) => ({
  id: i + 1,
  name: `Item ${i + 1}`,
  category: ['A', 'B', 'C', 'D'][Math.floor(Math.random() * 4)],
  price: Math.floor(Math.random() * 1000) + 1,
  stock: Math.floor(Math.random() * 100) + 1
}));

// 场景1: 数据表格初始加载
const initialLoadStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: true,
  sortFrequency: 'low',
  networkCondition: 'good',
  serverCapability: 'normal',
  clientDevice: 'desktop'
});
console.log('初始加载排序策略:', initialLoadStrategy);

// 场景2: 用户频繁切换排序条件
const frequentSortingStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: false,
  sortFrequency: 'high',
  networkCondition: 'good',
  serverCapability: 'normal',
  clientDevice: 'desktop'
});
console.log('频繁排序策略:', frequentSortingStrategy);

// 场景3: 移动设备访问
const mobileSortingStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: true,
  sortFrequency: 'medium',
  networkCondition: 'poor',
  serverCapability: 'normal',
  clientDevice: 'mobile'
});
console.log('移动设备排序策略:', mobileSortingStrategy);
```

#### 前端排序与后端排序的选择指南

| 因素 | 前端排序 | 后端排序 |
|------|---------|----------|
| **数据量** | 适合小型数据集(<1000条) | 适合大型数据集(>10000条) |
| **排序频率** | 适合高频排序操作 | 适合低频排序操作 |
| **网络状况** | 适合网络不稳定环境 | 适合网络良好环境 |
| **初始加载** | 不太适合 | 非常适合 |
| **分页数据** | 仅适合当前页数据 | 适合跨页排序 |
| **客户端性能** | 依赖客户端性能 | 不依赖客户端性能 |
| **实现复杂度** | 简单，使用Array.sort即可 | 需要后端API支持 |
| **用户体验** | 即时响应，无加载状态 | 有网络延迟，需要加载状态 |

#### 混合策略最佳实践

在实际项目中，通常采用混合策略：

1. **初始加载**：使用后端排序，与数据获取同时进行
2. **本地交互**：对当前页数据使用前端排序
3. **复杂排序**：多字段排序、模糊匹配等复杂排序使用后端实现
4. **全局排序**：需要对全部数据排序时使用后端排序
5. **缓存策略**：对常用排序结果进行缓存，减少重复计算

## 面试常见问题

### 1. 请解释一下JavaScript中Array.sort()的工作原理，以及它的时间复杂度是多少？

**答案**：

JavaScript中的`Array.sort()`方法的实现因浏览器而异，但大多数现代浏览器采用以下策略：

- 对于小数组（通常少于10-20个元素），使用**插入排序**（时间复杂度O(n²)）
- 对于大数组，使用**快速排序**的变种或**TimSort**（结合了归并排序和插入排序的混合算法）

因此，`Array.sort()`的平均时间复杂度为O(n log n)，但在最坏情况下可能达到O(n²)。

需要注意的是，如果不提供比较函数，`Array.sort()`会将元素转换为字符串，然后按照Unicode编码进行比较，这可能导致意外的排序结果，特别是对数字排序时：

```javascript
// 不提供比较函数的数字排序
const numbers = [10, 5, 40, 25, 1000, 1];
console.log(numbers.sort()); // [1, 10, 1000, 25, 40, 5]

// 正确的数字排序
console.log(numbers.sort((a, b) => a - b)); // [1, 5, 10, 25, 40, 1000]
```

### 2. 在前端开发中，如何优化大数据量表格的排序性能？

**答案**：

优化大数据量表格排序性能的策略包括：

1. **虚拟滚动**：只渲染可视区域的数据，减少DOM操作

```javascript
function createVirtualizedTable(data, containerSelector) {
  const container = document.querySelector(containerSelector);
  const rowHeight = 40; // 每行高度
  const visibleRows = Math.ceil(container.clientHeight / rowHeight);
  let scrollTop = 0;
  let sortedData = [...data];

  // 设置容器总高度
  function updateTotalHeight() {
    container.style.height = `${data.length * rowHeight}px`;
  }

  // 渲染可见行
  function renderVisibleRows() {
    const startIndex = Math.floor(scrollTop / rowHeight);
    const endIndex = Math.min(startIndex + visibleRows + 2, data.length);

    container.innerHTML = '';
    for (let i = startIndex; i < endIndex; i++) {
      const row = document.createElement('div');
      row.className = 'table-row';
      row.style.position = 'absolute';
      row.style.top = `${i * rowHeight}px`;
      row.style.height = `${rowHeight}px`;
      row.textContent = JSON.stringify(sortedData[i]);
      container.appendChild(row);
    }
  }

  // 排序函数
  function sortData(key, direction = 'asc') {
    sortedData = [...data].sort((a, b) => {
      return direction === 'asc' ? a[key] - b[key] : b[key] - a[key];
    });
    renderVisibleRows();
  }

  // 监听滚动事件
  container.addEventListener('scroll', () => {
    scrollTop = container.scrollTop;
    renderVisibleRows();
  });

  updateTotalHeight();
  renderVisibleRows();

  return { sortData };
}
```

2. **Web Worker**：将排序操作放在后台线程中执行，避免阻塞UI

```javascript
// main.js
const worker = new Worker('sort-worker.js');

worker.onmessage = function(e) {
  const { sortedData, requestId } = e.data;
  // 更新UI显示排序后的数据
  updateTableUI(sortedData);
};

function sortTable(data, sortKey, sortOrder) {
  const requestId = Date.now();
  worker.postMessage({
    data,
    sortKey,
    sortOrder,
    requestId
  });
}

// sort-worker.js
self.onmessage = function(e) {
  const { data, sortKey, sortOrder, requestId } = e.data;

  const sortedData = [...data].sort((a, b) => {
    if (sortOrder === 'asc') {
      return a[sortKey] > b[sortKey] ? 1 : -1;
    } else {
      return a[sortKey] < b[sortKey] ? 1 : -1;
    }
  });

  self.postMessage({ sortedData, requestId });
};
```

3. **分页排序**：只对当前页数据进行排序，减少计算量
4. **预排序缓存**：缓存常用排序结果，避免重复计算
5. **防抖处理**：对于用户频繁切换排序条件的情况，使用防抖处理
6. **索引优化**：为大数据集创建索引，加速查找和排序

### 3. 请比较快速排序和归并排序的优缺点，以及它们在前端应用中的适用场景。

**答案**：

**快速排序**：

优点：
- 平均情况下性能优秀，时间复杂度O(n log n)
- 原地排序，空间复杂度O(log n)（递归调用栈）
- 缓存友好，局部性好

缺点：
- 最坏情况下时间复杂度为O(n²)
- 不稳定排序（相等元素的相对位置可能改变）

**归并排序**：

优点：
- 稳定排序（相等元素的相对位置不变）
- 最好、最坏、平均情况下时间复杂度都是O(n log n)
- 适合处理链表等非随机访问的数据结构

缺点：
- 需要额外O(n)的空间复杂度
- 对于小数组，常数因子较大

**适用场景**：

快速排序适用于：
- 内存受限但CPU资源充足的场景
- 对排序稳定性没有要求的场景
- 数据分布较为随机的场景

```javascript
// 前端表格大数据排序，使用快速排序
function quickSortTable(data, key) {
  if (data.length <= 5000) {
    // 数据量不大，直接在主线程排序
    return quickSort(data, key);
  } else {
    // 数据量大，使用Web Worker
    return new Promise(resolve => {
      const worker = new Worker('quicksort-worker.js');
      worker.onmessage = e => {
        resolve(e.data);
        worker.terminate();
      };
      worker.postMessage({ data, key });
    });
  }
}
```

归并排序适用于：
- 需要稳定排序的场景（如保持用户的初始排序偏好）
- 外部排序（数据太大，无法全部加载到内存）
- 对排序结果有可预测性要求的场景

```javascript
// 用户交互历史记录排序，使用归并排序保持相对顺序
function sortUserInteractions(interactions, timestamp) {
  // 使用归并排序保持相同时间戳的交互顺序不变
  return mergeSort(interactions, (a, b) => a[timestamp] - b[timestamp]);
}
```

### 4. 如何实现一个支持多字段排序的数据表格？

**答案**：

实现多字段排序的数据表格需要考虑以下几点：

1. 定义排序优先级
2. 实现比较函数支持多字段比较
3. 提供用户界面支持多字段排序设置

```javascript
/**
 * @description 多字段排序函数
 * @param {Array} data - 要排序的数据数组
 * @param {Array} sortFields - 排序字段配置数组，格式为[{field, direction}]
 * @returns {Array} - 排序后的数组
 */
function multiFieldSort(data, sortFields) {
  return [...data].sort((a, b) => {
    // 依次比较每个排序字段
    for (const { field, direction } of sortFields) {
      // 获取字段值
      const valueA = getNestedValue(a, field);
      const valueB = getNestedValue(b, field);

      // 跳过相等的值
      if (valueA === valueB) continue;

      // 根据字段类型和排序方向比较
      const compareResult = compareValues(valueA, valueB);
      return direction === 'asc' ? compareResult : -compareResult;
    }

    // 所有字段都相等
    return 0;
  });
}

// 获取嵌套对象的值（支持 'user.profile.name' 这样的路径）
function getNestedValue(obj, path) {
  return path.split('.').reduce((o, key) => (o && o[key] !== undefined) ? o[key] : null, obj);
}

// 根据值类型进行比较
function compareValues(a, b) {
  // 处理null和undefined
  if (a === null || a === undefined) return -1;
  if (b === null || b === undefined) return 1;

  // 根据类型比较
  if (typeof a === 'string' && typeof b === 'string') {
    return a.localeCompare(b);
  } else if (a instanceof Date && b instanceof Date) {
    return a - b;
  } else {
    return a < b ? -1 : 1;
  }
}

// 使用示例
const users = [
  { name: 'Alice', age: 30, role: 'Admin', lastLogin: new Date('2023-05-10') },
  { name: 'Bob', age: 25, role: 'User', lastLogin: new Date('2023-06-15') },
  { name: 'Charlie', age: 30, role: 'User', lastLogin: new Date('2023-05-20') },
  { name: 'David', age: 28, role: 'Admin', lastLogin: new Date('2023-06-10') },
  { name: 'Alice', age: 22, role: 'User', lastLogin: new Date('2023-06-05') }
];

// 按角色升序，年龄降序，姓名升序排序
const sortedUsers = multiFieldSort(users, [
  { field: 'role', direction: 'asc' },
  { field: 'age', direction: 'desc' },
  { field: 'name', direction: 'asc' }
]);

console.log(sortedUsers);
```

在React中实现多字段排序的表格组件：

```jsx
import React, { useState, useMemo } from 'react';

function SortableTable({ data, columns }) {
  const [sortConfig, setSortConfig] = useState([]);

  // 处理列标题点击
  const handleHeaderClick = (field) => {
    setSortConfig(prevSortConfig => {
      // 查找当前字段是否已在排序配置中
      const fieldIndex = prevSortConfig.findIndex(config => config.field === field);

      if (fieldIndex >= 0) {
        // 字段已存在，切换排序方向或移除
        const newConfig = [...prevSortConfig];
        if (newConfig[fieldIndex].direction === 'asc') {
          newConfig[fieldIndex].direction = 'desc';
        } else {
          // 已经是降序，移除此排序字段
          newConfig.splice(fieldIndex, 1);
        }
        return newConfig;
      } else {
        // 添加新的排序字段（按住Shift键添加多字段排序）
        if (window.event && window.event.shiftKey) {
          return [...prevSortConfig, { field, direction: 'asc' }];
        } else {
          // 不按Shift则替换所有排序
          return [{ field, direction: 'asc' }];
        }
      }
    });
  };

  // 排序后的数据
  const sortedData = useMemo(() => {
    if (sortConfig.length === 0) return data;
    return multiFieldSort(data, sortConfig);
  }, [data, sortConfig]);

  // 获取列标题的排序指示器
  const getSortIndicator = (field) => {
    const config = sortConfig.find(config => config.field === field);
    if (!config) return null;

    const index = sortConfig.indexOf(config) + 1;
    return (
      <span className="sort-indicator">
        {config.direction === 'asc' ? '↑' : '↓'}
        {sortConfig.length > 1 && <sup>{index}</sup>}
      </span>
    );
  };

  return (
    <table className="sortable-table">
      <thead>
        <tr>
          {columns.map(column => (
            <th
              key={column.field}
              onClick={() => handleHeaderClick(column.field)}
              className={sortConfig.some(config => config.field === column.field) ? 'sorted' : ''}
            >
              {column.title} {getSortIndicator(column.field)}
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {sortedData.map((row, rowIndex) => (
          <tr key={rowIndex}>
            {columns.map(column => (
              <td key={column.field}>{row[column.field]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

### 5. 如何在不使用Array.sort()的情况下，实现一个稳定的排序算法？

**答案**：

可以实现一个稳定的归并排序算法，它能保证相等元素的相对顺序不变：

```javascript
/**
 * @description 稳定的归并排序实现
 * @param {Array} arr - 要排序的数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 排序后的新数组
 */
function stableMergeSort(arr, compareFn = (a, b) => a - b) {
  // 基本情况：数组长度为0或1时已经排序
  if (arr.length <= 1) return [...arr];

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = stableMergeSort(arr.slice(0, mid), compareFn);
  const right = stableMergeSort(arr.slice(mid), compareFn);

  // 合并两个已排序的数组
  return merge(left, right, compareFn);
}

/**
 * @description 合并两个已排序的数组
 * @param {Array} left - 左侧已排序数组
 * @param {Array} right - 右侧已排序数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 合并后的已排序数组
 */
function merge(left, right, compareFn) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较并合并两个数组
  while (leftIndex < left.length && rightIndex < right.length) {
    // 使用 <= 0 而不是 < 0 来确保稳定性
    // 当比较结果为0（相等）时，优先选择左侧数组的元素
    if (compareFn(left[leftIndex], right[rightIndex]) <= 0) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 添加剩余元素
  return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}

// 使用示例：对对象数组进行稳定排序
const students = [
  { name: 'Alice', grade: 'A', enrollmentOrder: 1 },
  { name: 'Bob', grade: 'B', enrollmentOrder: 2 },
  { name: 'Charlie', grade: 'A', enrollmentOrder: 3 },
  { name: 'David', grade: 'C', enrollmentOrder: 4 },
  { name: 'Eve', grade: 'B', enrollmentOrder: 5 },
  { name: 'Frank', grade: 'A', enrollmentOrder: 6 }
];

// 按成绩排序，成绩相同时保持原有顺序
const sortedByGrade = stableMergeSort(students, (a, b) => {
  // 按字母顺序比较成绩（A > B > C）
  return a.grade.localeCompare(b.grade);
});

console.log('按成绩排序（稳定）:', sortedByGrade);
// 可以看到所有成绩为A的学生（Alice, Charlie, Frank）保持了原有的相对顺序
```

稳定排序在以下场景特别有用：

1. **多级排序**：先按一个条件排序，再按另一个条件排序
2. **保持用户意图**：如用户手动调整过的项目顺序
3. **动画过渡**：在数据可视化中，稳定排序可以使元素位置变化更可预测，便于实现平滑过渡

除了归并排序，其他稳定的排序算法还包括：
- 插入排序
- 冒泡排序
- 计数排序
- 基数排序

而不稳定的排序算法包括：
- 快速排序
- 堆排序
- 选择排序

```javascript
/**
 * @description 搜索结果多维度排序
 * @param {Array} results - 搜索结果数组
 * @param {Object} weights - 各维度的权重，如{relevance: 0.6, date: 0.4}
 * @returns {Array} - 排序后的结果
 */
function sortSearchResults(results, weights) {
  return [...results].sort((a, b) => {
    // 计算加权得分
    const scoreA = calculateScore(a, weights);
    const scoreB = calculateScore(b, weights);

    // 降序排列（得分高的排前面）
    return scoreB - scoreA;
  });
}

/**
 * @description 计算单个结果的加权得分
 * @param {Object} item - 搜索结果项
 * @param {Object} weights - 权重对象
 * @returns {number} - 加权得分
 */
function calculateScore(item, weights) {
  let score = 0;

  // 相关性得分 (0-1)
  if ('relevance' in weights) {
    score += item.relevance * weights.relevance;
  }

  // 日期得分 (将日期转换为0-1的分数，越新越高)
  if ('date' in weights) {
    const now = new Date();
    const itemDate = new Date(item.date);
    const ageInDays = (now - itemDate) / (1000 * 60 * 60 * 24);
    const dateScore = Math.max(0, 1 - ageInDays / 365); // 一年以内的文档
    score += dateScore * weights.date;
  }

  return score;
}
```

### 3. 自动完成/提示功能

在输入框的自动完成功能中，需要对推荐结果进行排序，通常基于匹配度和使用频率。

```javascript
/**
 * @description 自动完成推荐结果排序
 * @param {string} input - 用户输入
 * @param {Array} suggestions - 候选推荐项
 * @returns {Array} - 排序后的推荐结果
 */
function sortAutocompleteSuggestions(input, suggestions) {
  const lowerInput = input.toLowerCase();

  // 计算每个推荐项的得分
  const scoredSuggestions = suggestions.map(item => {
    const text = item.text.toLowerCase();
    let score = 0;

    // 1. 精确匹配开头（最高优先级）
    if (text.startsWith(lowerInput)) {
      score += 100;
    }
    // 2. 包含输入文本
    else if (text.includes(lowerInput)) {
      score += 50;
    }

    // 3. 考虑历史使用频率
    score += (item.frequency || 0) * 0.5;

    return { ...item, score };
  });

  // 按得分降序排序
  return scoredSuggestions
    .filter(item => item.score > 0) // 只返回有相关性的结果
    .sort((a, b) => b.score - a.score);
}
```

### 4. 拖拽排序

在支持拖拽排序的列表中，需要在用户交互后重新排序元素。

```javascript
/**
 * @description 处理列表拖拽排序
 * @param {Array} list - 原列表数据
 * @param {number} fromIndex - 拖拽项的原始索引
 * @param {number} toIndex - 拖拽项的目标索引
 * @returns {Array} - 重新排序后的列表
 */
function handleDragSort(list, fromIndex, toIndex) {
  const result = [...list];
  const [removed] = result.splice(fromIndex, 1);
  result.splice(toIndex, 0, removed);
  return result;
}

// 使用示例（React组件中）
/*
const [items, setItems] = useState(['项目1', '项目2', '项目3', '项目4']);

const onDragEnd = (result) => {
  // 拖拽结束时调用
  if (!result.destination) return;

  const newItems = handleDragSort(
    items,
    result.source.index,
    result.destination.index
  );

  setItems(newItems);
};
*/
```

### 5. 前端排序与后端排序的选择

在实际开发中，需要根据数据量和性能要求选择在前端还是后端进行排序。

```javascript
/**
 * @description 智能排序策略选择器
 * @param {Array} data - 数据数组
 * @param {string} key - 排序键
 * @param {string} order - 排序方式
 * @param {Object} options - 配置选项
 * @returns {Promise<Array>} - 排序后的数据
 */
async function smartSort(data, key, order, options = {}) {
  const {
    threshold = 1000, // 前端排序的数据量阈值
    apiEndpoint = '/api/sort', // 后端排序API
    forceClient = false, // 强制前端排序
    forceServer = false // 强制后端排序
  } = options;

  // 强制选择排序位置
  if (forceClient) {
    return clientSideSort(data, key, order);
  }

  if (forceServer) {
    return serverSideSort(data, key, order, apiEndpoint);
  }

  // 根据数据量智能选择
  if (data.length <= threshold) {
    return clientSideSort(data, key, order);
  } else {
    return serverSideSort(data, key, order, apiEndpoint);
  }
}

// 前端排序实现
function clientSideSort(data, key, order) {
  console.log('使用前端排序');
  return Promise.resolve([...data].sort((a, b) => {
    const compareResult = a[key] < b[key] ? -1 : a[key] > b[key] ? 1 : 0;
    return order === 'asc' ? compareResult : -compareResult;
  }));
}

// 后端排序实现
async function serverSideSort(data, key, order, apiEndpoint) {
  console.log('使用后端排序');
  try {
    // 这里只是示例，实际应用中可能只需要发送必要的参数
    const response = await fetch(apiEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data, key, order })
    });

    if (!response.ok) {
      throw new Error('排序请求失败');
    }

    return await response.json();
  } catch (error) {
    console.error('后端排序失败，回退到前端排序', error);
    return clientSideSort(data, key, order);
  }
}
```

## 算法选择指南

在前端开发中，选择合适的排序算法需要考虑以下因素：

1. **数据规模**：数据量大小直接影响算法选择
2. **数据特征**：数据是否接近有序、是否有大量重复元素等
3. **稳定性要求**：是否需要保持相等元素的相对顺序
4. **空间限制**：是否有额外空间使用的限制
5. **实现复杂度**：在时间紧迫的情况下，可能优先考虑实现简单的算法

### 常见场景的算法选择

| 场景 | 推荐算法 | 理由 |
|------|---------|------|
| 小数据量（<50） | 插入排序 | 常数因子小，实现简单 |
| 接近有序的数据 | 插入排序 | 时间复杂度接近O(n) |
| 大数据量通用场景 | 快速排序 | 平均性能最佳，原地排序 |
| 对稳定性有要求 | 归并排序 | 稳定的O(n log n)算法 |
| 外部排序（数据量超过内存） | 归并排序 | 可以分块处理 |
| 包含多种数据类型 | Array.sort() + 比较函数 | 浏览器优化，处理复杂情况 |
| 有大量重复元素 | 三路快排 | 有效处理重复元素 |

### JavaScript内置排序方法的选择

在实际开发中，通常使用JavaScript的内置方法：

```javascript
// 1. Array.prototype.sort()
// 优点：内置、方便、浏览器优化
// 缺点：不同浏览器实现可能不同
const sortedArray = array.sort((a, b) => a - b);

// 2. Lodash的_.sortBy()
// 优点：API简洁，支持多重排序
// 缺点：需要引入额外库
// const sortedArray = _.sortBy(array, item => item.value);

// 3. 自定义排序
// 优点：完全控制排序逻辑
// 缺点：需要自己实现和维护
function customSort(array) {
  // 根据需求选择合适的排序算法实现
}
```

### 排序算法可视化资源

以下是一些帮助理解排序算法的可视化资源：

1. [VisuAlgo - 排序算法可视化](https://visualgo.net/en/sorting)
2. [排序算法动画演示](https://www.toptal.com/developers/sorting-algorithms)
3. [USF排序算法可视化](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

### 5. 归并排序

归并排序是一种分治算法，它将数组分成两半，递归地排序两半，然后将结果合并起来。

```javascript
/**
 * @description 归并排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(mergeSort(arr)); // [2, 3, 4, 5, 8]
 */
function mergeSort(arr) {
  // 基本情况：数组长度为0或1时已经排序好
  if (arr.length <= 1) return arr;

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  // 递归排序两半
  return merge(mergeSort(left), mergeSort(right));
}

/**
 * @description 合并两个已排序的数组
 * @param {number[]} left - 左侧已排序数组
 * @param {number[]} right - 右侧已排序数组
 * @returns {number[]} - 合并后的已排序数组
 */
function merge(left, right) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较两个数组的元素，将较小的元素加入结果数组
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 将剩余元素加入结果数组
  return result
    .concat(left.slice(leftIndex))
    .concat(right.slice(rightIndex));
}

// 调用示例
const mergeExample = [5, 3, 8, 4, 2];
console.log("原始数组:", mergeExample);
console.log("归并排序后:", mergeSort([...mergeExample]));
// 原始数组: [5, 3, 8, 4, 2]
// 归并排序后: [2, 3, 4, 5, 8]

// 执行过程分析
// 分割：[5, 3, 8, 4, 2] → [5, 3] 和 [8, 4, 2]
// 继续分割：[5, 3] → [5] 和 [3]、[8, 4, 2] → [8] 和 [4, 2]
// 继续分割：[4, 2] → [4] 和 [2]
// 合并：[3, 5]、[2, 4, 8]
// 最终合并：[2, 3, 4, 5, 8]
```

**时间复杂度**：
- 最好情况：O(n log n)
- 最坏情况：O(n log n)
- 平均情况：O(n log n)

**空间复杂度**：O(n)

**稳定性**：稳定

### 6. 快速排序

快速排序是一种分治算法，它选择一个元素作为基准，将数组分为两个子数组，小于基准的元素和大于基准的元素，然后递归地排序两个子数组。

```javascript
/**
 * @description 快速排序实现
 * @param {number[]} arr - 待排序的数组
 * @param {number} [left=0] - 排序的起始索引
 * @param {number} [right=arr.length-1] - 排序的结束索引
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(quickSort(arr)); // [2, 3, 4, 5, 8]
 */
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 基本情况：如果子数组长度为1或0，则已经排序好
  if (left < right) {
    // 获取分区点
    const pivotIndex = partition(arr, left, right);

    // 递归地排序两个子数组
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }

  return arr;
}

/**
 * @description 分区函数，用于确定基准元素的最终位置
 * @param {number[]} arr - 待排序的数组
 * @param {number} left - 分区的起始索引
 * @param {number} right - 分区的结束索引
 * @returns {number} - 基准元素的最终索引
 */
function partition(arr, left, right) {
  // 选择最右边的元素作为基准
  const pivot = arr[right];
  // i指向小于基准元素区域的末尾
  let i = left - 1;

  // 遍历区间内的元素
  for (let j = left; j < right; j++) {
    // 如果当前元素小于等于基准元素
    if (arr[j] <= pivot) {
      // 将其放到小元素区域的末尾
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 将基准元素放到正确的位置
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}

// 调用示例
const quickExample = [5, 3, 8, 4, 2, 7, 1, 6];
console.log("原始数组:", quickExample);
console.log("快速排序后:", quickSort([...quickExample]));
// 原始数组: [5, 3, 8, 4, 2, 7, 1, 6]
// 快速排序后: [1, 2, 3, 4, 5, 6, 7, 8]

// 执行过程分析（以[5, 3, 8, 4, 2]为例）
// 1. 选择基准pivot=2（最右元素）
// 2. 第一次分区：
//    - 初始状态：[5, 3, 8, 4, 2]，pivot=2
//    - 遍历过程：
//      j=0: 5>2，不交换，i=-1
//      j=1: 3>2，不交换，i=-1
//      j=2: 8>2，不交换，i=-1
//      j=3: 4>2，不交换，i=-1
//    - 最后将pivot放到正确位置：[2, 3, 8, 4, 5]，pivotIndex=0
// 3. 递归左侧子数组（空）
// 4. 递归右侧子数组[3, 8, 4, 5]
//    - 选择基准pivot=5
//    - 分区结果：[3, 4, 5, 8]，pivotIndex=2
// 5. 递归处理[3, 4]和[8]
//    - 处理[3, 4]，基准pivot=4
//    - 分区结果：[3, 4]，pivotIndex=1
// 6. 继续递归直到所有子数组都处理完
// 7. 最终结果：[2, 3, 4, 5, 8]

/**
 * @description 优化版快速排序（使用随机基准点）
 * @param {number[]} arr - 待排序的数组
 * @param {number} [left=0] - 排序的起始索引
 * @param {number} [right=arr.length-1] - 排序的结束索引
 * @returns {number[]} - 排序后的数组
 */
function optimizedQuickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    // 获取随机基准点
    const pivotIndex = randomizedPartition(arr, left, right);

    optimizedQuickSort(arr, left, pivotIndex - 1);
    optimizedQuickSort(arr, pivotIndex + 1, right);
  }

  return arr;
}

/**
 * @description 使用随机选择基准元素的分区函数
 * @param {number[]} arr - 待排序的数组
 * @param {number} left - 分区的起始索引
 * @param {number} right - 分区的结束索引
 * @returns {number} - 基准元素的最终索引
 */
function randomizedPartition(arr, left, right) {
  // 随机选择一个基准点
  const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
  // 将随机选择的元素与最右元素交换
  [arr[randomIndex], arr[right]] = [arr[right], arr[randomIndex]];

  // 调用标准分区过程
  return partition(arr, left, right);
}

// 比较两种快速排序算法
const arrToSort = Array.from({length: 1000}, () => Math.floor(Math.random() * 1000));
const arrToSort2 = [...arrToSort];

console.time('标准快速排序');
quickSort([...arrToSort]);
console.timeEnd('标准快速排序');

console.time('优化快速排序');
optimizedQuickSort([...arrToSort2]);
console.timeEnd('优化快速排序');

// 示例输出:
// 标准快速排序: 0.721ms
// 优化快速排序: 0.683ms
```

**时间复杂度**：
- 最好情况：O(n log n)，每次都能均匀分割
- 最坏情况：O(n²)，当数组已经有序或逆序时（可通过随机选择基准点优化）
- 平均情况：O(n log n)

**空间复杂度**：O(log n)，递归调用栈的深度

**稳定性**：不稳定

## 前端应用场景

排序算法在前端开发中有着广泛的应用，了解不同排序算法的特点可以帮助我们在实际开发中选择最合适的方案。

### 1. 数据表格排序

在前端开发中，数据表格是最常见的需要排序的场景。用户通常可以点击表头对某一列数据进行排序。

```javascript
/**
 * @description 表格数据排序函数
 * @param {Array} data - 表格数据数组
 * @param {string} key - 排序的键名
 * @param {string} order - 排序方式，'asc'或'desc'
 * @returns {Array} - 排序后的数组
 */
function sortTableData(data, key, order = 'asc') {
  return [...data].sort((a, b) => {
    // 处理不同数据类型
    if (typeof a[key] === 'string') {
      // 字符串排序，考虑本地化比较
      const compareResult = a[key].localeCompare(b[key]);
      return order === 'asc' ? compareResult : -compareResult;
    } else {
      // 数字排序
      const compareResult = a[key] - b[key];
      return order === 'asc' ? compareResult : -compareResult;
    }
  });
}

// 使用示例
const users = [
  { id: 1, name: '张三', age: 28, score: 85 },
  { id: 2, name: '李四', age: 22, score: 90 },
  { id: 3, name: '王五', age: 25, score: 85 },
  { id: 4, name: '赵六', age: 30, score: 78 }
];

// 按年龄升序排序
const sortedByAge = sortTableData(users, 'age', 'asc');
console.log('按年龄升序:', sortedByAge);

// 按姓名降序排序
const sortedByName = sortTableData(users, 'name', 'desc');
console.log('按姓名降序:', sortedByName);
```

#### 多字段排序实现

在复杂的数据表格中，经常需要实现多字段排序功能，例如先按部门排序，再按工资排序：

```javascript
/**
 * @description 多字段表格排序函数
 * @param {Array} data - 表格数据数组
 * @param {Array} sortFields - 排序字段配置数组，格式为[{field, order}]
 * @returns {Array} - 排序后的数组
 */
function multiFieldSort(data, sortFields) {
  return [...data].sort((a, b) => {
    // 遍历排序字段配置
    for (const { field, order } of sortFields) {
      // 获取当前字段的值
      const aValue = a[field];
      const bValue = b[field];

      // 跳过值相等的情况
      if (aValue === bValue) continue;

      // 根据字段类型和排序方向进行比较
      if (typeof aValue === 'string') {
        const result = aValue.localeCompare(bValue);
        return order === 'asc' ? result : -result;
      } else {
        return order === 'asc' ? aValue - bValue : bValue - aValue;
      }
    }

    // 所有字段都相等
    return 0;
  });
}

// 使用示例
const employees = [
  { id: 1, name: '张三', department: '技术部', salary: 15000 },
  { id: 2, name: '李四', department: '市场部', salary: 12000 },
  { id: 3, name: '王五', department: '技术部', salary: 18000 },
  { id: 4, name: '赵六', department: '市场部', salary: 12000 },
  { id: 5, name: '钱七', department: '技术部', salary: 15000 }
];

// 先按部门升序，再按薪资降序排序
const sortConfig = [
  { field: 'department', order: 'asc' },
  { field: 'salary', order: 'desc' }
];

const sortedEmployees = multiFieldSort(employees, sortConfig);
console.log('多字段排序结果:', sortedEmployees);
// 输出结果：先按部门分组，同部门内按薪资从高到低排序
```

### 2. 搜索结果排序

在搜索功能中，通常需要根据相关性、时间等多个维度对结果进行排序。

```javascript
/**
 * @description 搜索结果排序函数
 * @param {Array} results - 搜索结果数组
 * @param {Object} options - 排序选项
 * @returns {Array} - 排序后的结果
 */
function sortSearchResults(results, options = {}) {
  const {
    relevanceWeight = 0.6,  // 相关性权重
    dateWeight = 0.3,       // 日期权重
    popularityWeight = 0.1, // 热度权重
    sortBy = 'combined'     // 排序方式：combined, relevance, date, popularity
  } = options;

  return [...results].sort((a, b) => {
    if (sortBy === 'relevance') {
      return b.relevanceScore - a.relevanceScore;
    } else if (sortBy === 'date') {
      return new Date(b.date) - new Date(a.date);
    } else if (sortBy === 'popularity') {
      return b.views - a.views;
    } else {
      // 综合排序 - 计算加权分数
      const scoreA = (a.relevanceScore * relevanceWeight) +
                    (new Date(a.date).getTime() / 8.64e7 * dateWeight) +
                    (a.views / 1000 * popularityWeight);

      const scoreB = (b.relevanceScore * relevanceWeight) +
                    (new Date(b.date).getTime() / 8.64e7 * dateWeight) +
                    (b.views / 1000 * popularityWeight);

      return scoreB - scoreA;
    }
  });
}

// 使用示例
const searchResults = [
  { id: 1, title: '前端开发基础', relevanceScore: 0.8, date: '2023-05-15', views: 1200 },
  { id: 2, title: '高级JavaScript技巧', relevanceScore: 0.9, date: '2022-11-20', views: 3500 },
  { id: 3, title: 'React性能优化', relevanceScore: 0.7, date: '2023-06-10', views: 800 },
  { id: 4, title: 'Vue3新特性解析', relevanceScore: 0.85, date: '2023-04-05', views: 2200 }
];

// 默认综合排序
const defaultSorted = sortSearchResults(searchResults);
console.log('综合排序结果:', defaultSorted);

// 仅按相关性排序
const relevanceSorted = sortSearchResults(searchResults, { sortBy: 'relevance' });
console.log('相关性排序结果:', relevanceSorted);

// 自定义权重的综合排序
const customSorted = sortSearchResults(searchResults, {
  relevanceWeight: 0.4,
  dateWeight: 0.5,
  popularityWeight: 0.1
});
console.log('自定义权重排序结果:', customSorted);
```

### 3. 拖拽排序实现

在许多前端应用中，需要实现列表项的拖拽排序功能，这也涉及到排序算法的应用。

```javascript
/**
 * @description 拖拽排序组件示例
 */
class DraggableList {
  constructor(containerId, items) {
    this.container = document.getElementById(containerId);
    this.items = items;
    this.draggedItem = null;
    this.draggedIndex = -1;

    this.render();
    this.addEventListeners();
  }

  render() {
    this.container.innerHTML = '';

    this.items.forEach((item, index) => {
      const element = document.createElement('div');
      element.className = 'draggable-item';
      element.setAttribute('draggable', 'true');
      element.setAttribute('data-index', index);
      element.textContent = item.text;

      this.container.appendChild(element);
    });
  }

  addEventListeners() {
    const items = this.container.querySelectorAll('.draggable-item');

    items.forEach(item => {
      // 开始拖拽
      item.addEventListener('dragstart', (e) => {
        this.draggedItem = item;
        this.draggedIndex = parseInt(item.getAttribute('data-index'));
        setTimeout(() => {
          item.classList.add('dragging');
        }, 0);
      });

      // 拖拽结束
      item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
        this.draggedItem = null;
        this.draggedIndex = -1;
      });

      // 拖拽经过其他元素
      item.addEventListener('dragover', (e) => {
        e.preventDefault();
      });

      // 放置
      item.addEventListener('drop', (e) => {
        e.preventDefault();
        if (this.draggedItem) {
          const targetIndex = parseInt(item.getAttribute('data-index'));

          // 执行排序操作
          this.reorderItems(this.draggedIndex, targetIndex);

          // 重新渲染列表
          this.render();
          this.addEventListeners();
        }
      });
    });
  }

  /**
   * 重新排序数组元素
   * @param {number} fromIndex - 起始索引
   * @param {number} toIndex - 目标索引
   */
  reorderItems(fromIndex, toIndex) {
    // 保存被拖拽的元素
    const itemToMove = this.items[fromIndex];

    // 从数组中移除该元素
    this.items.splice(fromIndex, 1);

    // 在新位置插入该元素
    this.items.splice(toIndex, 0, itemToMove);
  }

  // 获取当前排序后的数据
  getItems() {
    return this.items;
  }
}

// 使用示例
const todoItems = [
  { id: 1, text: '完成项目文档' },
  { id: 2, text: '修复页面布局问题' },
  { id: 3, text: '实现新功能' },
  { id: 4, text: '代码审查' },
  { id: 5, text: '部署应用' }
];

// 初始化拖拽列表
// HTML结构: <div id="todo-list"></div>
const todoList = new DraggableList('todo-list', todoItems);

// 获取排序后的数据
console.log('排序后的待办事项:', todoList.getItems());
```

### 4. 自动完成/提示功能

在搜索框的自动完成功能中，需要对推荐结果进行排序，通常是根据匹配度和历史数据。

```javascript
/**
 * @description 自动完成推荐排序
 * @param {string} query - 用户输入的查询字符串
 * @param {Array} suggestions - 候选推荐项数组
 * @param {Object} options - 排序选项
 * @returns {Array} - 排序后的推荐结果
 */
function sortAutocompleteSuggestions(query, suggestions, options = {}) {
  const {
    maxResults = 5,
    useHistory = true,
    historicalSearches = []
  } = options;

  // 计算字符串匹配度分数
  function calculateMatchScore(suggestion, query) {
    const text = suggestion.text.toLowerCase();
    const searchQuery = query.toLowerCase();

    // 完全匹配得分最高
    if (text === searchQuery) return 1;

    // 前缀匹配得分次之
    if (text.startsWith(searchQuery)) return 0.8;

    // 包含匹配再次之
    if (text.includes(searchQuery)) {
      // 单词边界匹配得分更高
      const words = text.split(/\s+/);
      for (const word of words) {
        if (word.startsWith(searchQuery)) return 0.7;
      }
      return 0.5;
    }

    // 编辑距离计算模糊匹配度
    // 这里使用简化版，实际可以用Levenshtein距离算法
    let matchCount = 0;
    for (let i = 0; i < searchQuery.length; i++) {
      if (text.includes(searchQuery[i])) matchCount++;
    }
    return matchCount / searchQuery.length * 0.3;
  }

  // 为每个推荐项计算综合分数
  const scoredSuggestions = suggestions.map(suggestion => {
    // 基础匹配分数
    let score = calculateMatchScore(suggestion, query);

    // 考虑历史搜索频率
    if (useHistory) {
      const historyItem = historicalSearches.find(h => h.text === suggestion.text);
      if (historyItem) {
        // 历史搜索频率加权
        score += Math.min(historyItem.frequency / 10, 0.5);
      }
    }

    // 考虑推荐项自身权重
    if (suggestion.weight) {
      score += suggestion.weight * 0.2;
    }

    return { ...suggestion, score };
  });

  // 按分数排序并限制结果数量
  return scoredSuggestions
    .sort((a, b) => b.score - a.score)
    .slice(0, maxResults);
}

// 使用示例
const userQuery = 'jav';

const allSuggestions = [
  { id: 1, text: 'JavaScript基础教程' },
  { id: 2, text: 'Java编程入门' },
  { id: 3, text: 'JavaScript框架比较' },
  { id: 4, text: 'Python vs JavaScript' },
  { id: 5, text: 'JavaScript设计模式' },
  { id: 6, text: 'Java虚拟机原理' },
  { id: 7, text: 'TypeScript和JavaScript区别' },
  { id: 8, text: '如何学习JavaScript' }
];

const historicalSearches = [
  { text: 'JavaScript基础教程', frequency: 5 },
  { text: 'JavaScript设计模式', frequency: 3 },
  { text: 'Java编程入门', frequency: 2 }
];

// 获取排序后的推荐结果
const sortedSuggestions = sortAutocompleteSuggestions(userQuery, allSuggestions, {
  maxResults: 4,
  useHistory: true,
  historicalSearches
});

console.log('推荐结果:', sortedSuggestions);
```

### 5. 前端排序与后端排序选择

在实际开发中，需要权衡何时使用前端排序，何时使用后端排序。

```javascript
/**
 * @description 前端/后端排序选择辅助函数
 * @param {Array} data - 需要排序的数据
 * @param {Object} options - 排序选项
 * @returns {Object} - 排序策略建议
 */
function determineSortingStrategy(data, options = {}) {
  const {
    dataSize = data.length,
    isInitialLoad = true,
    sortFrequency = 'low', // 'low', 'medium', 'high'
    networkCondition = 'good', // 'poor', 'good', 'excellent'
    serverCapability = 'normal', // 'limited', 'normal', 'powerful'
    clientDevice = 'desktop' // 'mobile', 'desktop', 'powerful'
  } = options;

  // 决策因素评分
  let frontendScore = 0;
  let backendScore = 0;

  // 1. 数据量评估
  if (dataSize < 1000) {
    frontendScore += 3;
  } else if (dataSize < 10000) {
    frontendScore += 1;
    backendScore += 1;
  } else {
    backendScore += 3;
  }

  // 2. 是否初次加载
  if (isInitialLoad) {
    backendScore += 2; // 初次加载通常由后端预排序更高效
  } else {
    frontendScore += 1; // 后续交互排序可以在前端进行
  }

  // 3. 排序频率
  if (sortFrequency === 'high') {
    frontendScore += 2; // 高频排序在前端进行可减少请求
  } else if (sortFrequency === 'medium') {
    frontendScore += 1;
  } else {
    backendScore += 1; // 低频排序可以接受网络延迟
  }

  // 4. 网络状况
  if (networkCondition === 'poor') {
    frontendScore += 2; // 网络不佳时前端排序可减少请求
  } else if (networkCondition === 'excellent') {
    backendScore += 1;
  }

  // 5. 服务器能力
  if (serverCapability === 'powerful') {
    backendScore += 2;
  } else if (serverCapability === 'limited') {
    frontendScore += 2;
  }

  // 6. 客户端设备
  if (clientDevice === 'powerful') {
    frontendScore += 2;
  } else if (clientDevice === 'mobile') {
    backendScore += 1;
  }

  // 决策结果
  const recommendation = {
    strategy: frontendScore > backendScore ? 'frontend' : 'backend',
    frontendScore,
    backendScore,
    reasons: []
  };

  // 添加决策理由
  if (dataSize >= 10000) {
    recommendation.reasons.push('数据量较大，后端排序更高效');
  } else if (dataSize < 1000) {
    recommendation.reasons.push('数据量较小，前端排序响应更快');
  }

  if (sortFrequency === 'high') {
    recommendation.reasons.push('排序频率高，前端排序可减少请求次数');
  }

  if (networkCondition === 'poor') {
    recommendation.reasons.push('网络状况不佳，前端排序可提供更好的用户体验');
  }

  if (clientDevice === 'mobile' && dataSize > 5000) {
    recommendation.reasons.push('移动设备处理大量数据排序可能影响性能');
  }

  return recommendation;
}

// 使用示例
const tableData = Array.from({ length: 8000 }, (_, i) => ({
  id: i + 1,
  name: `Item ${i + 1}`,
  category: ['A', 'B', 'C', 'D'][Math.floor(Math.random() * 4)],
  price: Math.floor(Math.random() * 1000) + 1,
  stock: Math.floor(Math.random() * 100) + 1
}));

// 场景1: 数据表格初始加载
const initialLoadStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: true,
  sortFrequency: 'low',
  networkCondition: 'good',
  serverCapability: 'normal',
  clientDevice: 'desktop'
});
console.log('初始加载排序策略:', initialLoadStrategy);

// 场景2: 用户频繁切换排序条件
const frequentSortingStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: false,
  sortFrequency: 'high',
  networkCondition: 'good',
  serverCapability: 'normal',
  clientDevice: 'desktop'
});
console.log('频繁排序策略:', frequentSortingStrategy);

// 场景3: 移动设备访问
const mobileSortingStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: true,
  sortFrequency: 'medium',
  networkCondition: 'poor',
  serverCapability: 'normal',
  clientDevice: 'mobile'
});
console.log('移动设备排序策略:', mobileSortingStrategy);
```

#### 前端排序与后端排序的选择指南

| 因素 | 前端排序 | 后端排序 |
|------|---------|----------|
| **数据量** | 适合小型数据集(<1000条) | 适合大型数据集(>10000条) |
| **排序频率** | 适合高频排序操作 | 适合低频排序操作 |
| **网络状况** | 适合网络不稳定环境 | 适合网络良好环境 |
| **初始加载** | 不太适合 | 非常适合 |
| **分页数据** | 仅适合当前页数据 | 适合跨页排序 |
| **客户端性能** | 依赖客户端性能 | 不依赖客户端性能 |
| **实现复杂度** | 简单，使用Array.sort即可 | 需要后端API支持 |
| **用户体验** | 即时响应，无加载状态 | 有网络延迟，需要加载状态 |

#### 混合策略最佳实践

在实际项目中，通常采用混合策略：

1. **初始加载**：使用后端排序，与数据获取同时进行
2. **本地交互**：对当前页数据使用前端排序
3. **复杂排序**：多字段排序、模糊匹配等复杂排序使用后端实现
4. **全局排序**：需要对全部数据排序时使用后端排序
5. **缓存策略**：对常用排序结果进行缓存，减少重复计算

## 面试常见问题

### 1. 请解释一下JavaScript中Array.sort()的工作原理，以及它的时间复杂度是多少？

**答案**：

JavaScript中的`Array.sort()`方法的实现因浏览器而异，但大多数现代浏览器采用以下策略：

- 对于小数组（通常少于10-20个元素），使用**插入排序**（时间复杂度O(n²)）
- 对于大数组，使用**快速排序**的变种或**TimSort**（结合了归并排序和插入排序的混合算法）

因此，`Array.sort()`的平均时间复杂度为O(n log n)，但在最坏情况下可能达到O(n²)。

需要注意的是，如果不提供比较函数，`Array.sort()`会将元素转换为字符串，然后按照Unicode编码进行比较，这可能导致意外的排序结果，特别是对数字排序时：

```javascript
// 不提供比较函数的数字排序
const numbers = [10, 5, 40, 25, 1000, 1];
console.log(numbers.sort()); // [1, 10, 1000, 25, 40, 5]

// 正确的数字排序
console.log(numbers.sort((a, b) => a - b)); // [1, 5, 10, 25, 40, 1000]
```

### 2. 在前端开发中，如何优化大数据量表格的排序性能？

**答案**：

优化大数据量表格排序性能的策略包括：

1. **虚拟滚动**：只渲染可视区域的数据，减少DOM操作

```javascript
function createVirtualizedTable(data, containerSelector) {
  const container = document.querySelector(containerSelector);
  const rowHeight = 40; // 每行高度
  const visibleRows = Math.ceil(container.clientHeight / rowHeight);
  let scrollTop = 0;
  let sortedData = [...data];

  // 设置容器总高度
  function updateTotalHeight() {
    container.style.height = `${data.length * rowHeight}px`;
  }

  // 渲染可见行
  function renderVisibleRows() {
    const startIndex = Math.floor(scrollTop / rowHeight);
    const endIndex = Math.min(startIndex + visibleRows + 2, data.length);

    container.innerHTML = '';
    for (let i = startIndex; i < endIndex; i++) {
      const row = document.createElement('div');
      row.className = 'table-row';
      row.style.position = 'absolute';
      row.style.top = `${i * rowHeight}px`;
      row.style.height = `${rowHeight}px`;
      row.textContent = JSON.stringify(sortedData[i]);
      container.appendChild(row);
    }
  }

  // 排序函数
  function sortData(key, direction = 'asc') {
    sortedData = [...data].sort((a, b) => {
      return direction === 'asc' ? a[key] - b[key] : b[key] - a[key];
    });
    renderVisibleRows();
  }

  // 监听滚动事件
  container.addEventListener('scroll', () => {
    scrollTop = container.scrollTop;
    renderVisibleRows();
  });

  updateTotalHeight();
  renderVisibleRows();

  return { sortData };
}
```

2. **Web Worker**：将排序操作放在后台线程中执行，避免阻塞UI

```javascript
// main.js
const worker = new Worker('sort-worker.js');

worker.onmessage = function(e) {
  const { sortedData, requestId } = e.data;
  // 更新UI显示排序后的数据
  updateTableUI(sortedData);
};

function sortTable(data, sortKey, sortOrder) {
  const requestId = Date.now();
  worker.postMessage({
    data,
    sortKey,
    sortOrder,
    requestId
  });
}

// sort-worker.js
self.onmessage = function(e) {
  const { data, sortKey, sortOrder, requestId } = e.data;

  const sortedData = [...data].sort((a, b) => {
    if (sortOrder === 'asc') {
      return a[sortKey] > b[sortKey] ? 1 : -1;
    } else {
      return a[sortKey] < b[sortKey] ? 1 : -1;
    }
  });

  self.postMessage({ sortedData, requestId });
};
```

3. **分页排序**：只对当前页数据进行排序，减少计算量
4. **预排序缓存**：缓存常用排序结果，避免重复计算
5. **防抖处理**：对于用户频繁切换排序条件的情况，使用防抖处理
6. **索引优化**：为大数据集创建索引，加速查找和排序

### 3. 请比较快速排序和归并排序的优缺点，以及它们在前端应用中的适用场景。

**答案**：

**快速排序**：

优点：
- 平均情况下性能优秀，时间复杂度O(n log n)
- 原地排序，空间复杂度O(log n)（递归调用栈）
- 缓存友好，局部性好

缺点：
- 最坏情况下时间复杂度为O(n²)
- 不稳定排序（相等元素的相对位置可能改变）

**归并排序**：

优点：
- 稳定排序（相等元素的相对位置不变）
- 最好、最坏、平均情况下时间复杂度都是O(n log n)
- 适合处理链表等非随机访问的数据结构

缺点：
- 需要额外O(n)的空间复杂度
- 对于小数组，常数因子较大

**适用场景**：

快速排序适用于：
- 内存受限但CPU资源充足的场景
- 对排序稳定性没有要求的场景
- 数据分布较为随机的场景

```javascript
// 前端表格大数据排序，使用快速排序
function quickSortTable(data, key) {
  if (data.length <= 5000) {
    // 数据量不大，直接在主线程排序
    return quickSort(data, key);
  } else {
    // 数据量大，使用Web Worker
    return new Promise(resolve => {
      const worker = new Worker('quicksort-worker.js');
      worker.onmessage = e => {
        resolve(e.data);
        worker.terminate();
      };
      worker.postMessage({ data, key });
    });
  }
}
```

归并排序适用于：
- 需要稳定排序的场景（如保持用户的初始排序偏好）
- 外部排序（数据太大，无法全部加载到内存）
- 对排序结果有可预测性要求的场景

```javascript
// 用户交互历史记录排序，使用归并排序保持相对顺序
function sortUserInteractions(interactions, timestamp) {
  // 使用归并排序保持相同时间戳的交互顺序不变
  return mergeSort(interactions, (a, b) => a[timestamp] - b[timestamp]);
}
```

### 4. 如何实现一个支持多字段排序的数据表格？

**答案**：

实现多字段排序的数据表格需要考虑以下几点：

1. 定义排序优先级
2. 实现比较函数支持多字段比较
3. 提供用户界面支持多字段排序设置

```javascript
/**
 * @description 多字段排序函数
 * @param {Array} data - 要排序的数据数组
 * @param {Array} sortFields - 排序字段配置数组，格式为[{field, direction}]
 * @returns {Array} - 排序后的数组
 */
function multiFieldSort(data, sortFields) {
  return [...data].sort((a, b) => {
    // 依次比较每个排序字段
    for (const { field, direction } of sortFields) {
      // 获取字段值
      const valueA = getNestedValue(a, field);
      const valueB = getNestedValue(b, field);

      // 跳过相等的值
      if (valueA === valueB) continue;

      // 根据字段类型和排序方向比较
      const compareResult = compareValues(valueA, valueB);
      return direction === 'asc' ? compareResult : -compareResult;
    }

    // 所有字段都相等
    return 0;
  });
}

// 获取嵌套对象的值（支持 'user.profile.name' 这样的路径）
function getNestedValue(obj, path) {
  return path.split('.').reduce((o, key) => (o && o[key] !== undefined) ? o[key] : null, obj);
}

// 根据值类型进行比较
function compareValues(a, b) {
  // 处理null和undefined
  if (a === null || a === undefined) return -1;
  if (b === null || b === undefined) return 1;

  // 根据类型比较
  if (typeof a === 'string' && typeof b === 'string') {
    return a.localeCompare(b);
  } else if (a instanceof Date && b instanceof Date) {
    return a - b;
  } else {
    return a < b ? -1 : 1;
  }
}

// 使用示例
const users = [
  { name: 'Alice', age: 30, role: 'Admin', lastLogin: new Date('2023-05-10') },
  { name: 'Bob', age: 25, role: 'User', lastLogin: new Date('2023-06-15') },
  { name: 'Charlie', age: 30, role: 'User', lastLogin: new Date('2023-05-20') },
  { name: 'David', age: 28, role: 'Admin', lastLogin: new Date('2023-06-10') },
  { name: 'Alice', age: 22, role: 'User', lastLogin: new Date('2023-06-05') }
];

// 按角色升序，年龄降序，姓名升序排序
const sortedUsers = multiFieldSort(users, [
  { field: 'role', direction: 'asc' },
  { field: 'age', direction: 'desc' },
  { field: 'name', direction: 'asc' }
]);

console.log(sortedUsers);
```

在React中实现多字段排序的表格组件：

```jsx
import React, { useState, useMemo } from 'react';

function SortableTable({ data, columns }) {
  const [sortConfig, setSortConfig] = useState([]);

  // 处理列标题点击
  const handleHeaderClick = (field) => {
    setSortConfig(prevSortConfig => {
      // 查找当前字段是否已在排序配置中
      const fieldIndex = prevSortConfig.findIndex(config => config.field === field);

      if (fieldIndex >= 0) {
        // 字段已存在，切换排序方向或移除
        const newConfig = [...prevSortConfig];
        if (newConfig[fieldIndex].direction === 'asc') {
          newConfig[fieldIndex].direction = 'desc';
        } else {
          // 已经是降序，移除此排序字段
          newConfig.splice(fieldIndex, 1);
        }
        return newConfig;
      } else {
        // 添加新的排序字段（按住Shift键添加多字段排序）
        if (window.event && window.event.shiftKey) {
          return [...prevSortConfig, { field, direction: 'asc' }];
        } else {
          // 不按Shift则替换所有排序
          return [{ field, direction: 'asc' }];
        }
      }
    });
  };

  // 排序后的数据
  const sortedData = useMemo(() => {
    if (sortConfig.length === 0) return data;
    return multiFieldSort(data, sortConfig);
  }, [data, sortConfig]);

  // 获取列标题的排序指示器
  const getSortIndicator = (field) => {
    const config = sortConfig.find(config => config.field === field);
    if (!config) return null;

    const index = sortConfig.indexOf(config) + 1;
    return (
      <span className="sort-indicator">
        {config.direction === 'asc' ? '↑' : '↓'}
        {sortConfig.length > 1 && <sup>{index}</sup>}
      </span>
    );
  };

  return (
    <table className="sortable-table">
      <thead>
        <tr>
          {columns.map(column => (
            <th
              key={column.field}
              onClick={() => handleHeaderClick(column.field)}
              className={sortConfig.some(config => config.field === column.field) ? 'sorted' : ''}
            >
              {column.title} {getSortIndicator(column.field)}
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {sortedData.map((row, rowIndex) => (
          <tr key={rowIndex}>
            {columns.map(column => (
              <td key={column.field}>{row[column.field]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

### 5. 如何在不使用Array.sort()的情况下，实现一个稳定的排序算法？

**答案**：

可以实现一个稳定的归并排序算法，它能保证相等元素的相对顺序不变：

```javascript
/**
 * @description 稳定的归并排序实现
 * @param {Array} arr - 要排序的数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 排序后的新数组
 */
function stableMergeSort(arr, compareFn = (a, b) => a - b) {
  // 基本情况：数组长度为0或1时已经排序
  if (arr.length <= 1) return [...arr];

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = stableMergeSort(arr.slice(0, mid), compareFn);
  const right = stableMergeSort(arr.slice(mid), compareFn);

  // 合并两个已排序的数组
  return merge(left, right, compareFn);
}

/**
 * @description 合并两个已排序的数组
 * @param {Array} left - 左侧已排序数组
 * @param {Array} right - 右侧已排序数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 合并后的已排序数组
 */
function merge(left, right, compareFn) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较并合并两个数组
  while (leftIndex < left.length && rightIndex < right.length) {
    // 使用 <= 0 而不是 < 0 来确保稳定性
    // 当比较结果为0（相等）时，优先选择左侧数组的元素
    if (compareFn(left[leftIndex], right[rightIndex]) <= 0) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 添加剩余元素
  return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}

// 使用示例：对对象数组进行稳定排序
const students = [
  { name: 'Alice', grade: 'A', enrollmentOrder: 1 },
  { name: 'Bob', grade: 'B', enrollmentOrder: 2 },
  { name: 'Charlie', grade: 'A', enrollmentOrder: 3 },
  { name: 'David', grade: 'C', enrollmentOrder: 4 },
  { name: 'Eve', grade: 'B', enrollmentOrder: 5 },
  { name: 'Frank', grade: 'A', enrollmentOrder: 6 }
];

// 按成绩排序，成绩相同时保持原有顺序
const sortedByGrade = stableMergeSort(students, (a, b) => {
  // 按字母顺序比较成绩（A > B > C）
  return a.grade.localeCompare(b.grade);
});

console.log('按成绩排序（稳定）:', sortedByGrade);
// 可以看到所有成绩为A的学生（Alice, Charlie, Frank）保持了原有的相对顺序
```

稳定排序在以下场景特别有用：

1. **多级排序**：先按一个条件排序，再按另一个条件排序
2. **保持用户意图**：如用户手动调整过的项目顺序
3. **动画过渡**：在数据可视化中，稳定排序可以使元素位置变化更可预测，便于实现平滑过渡

除了归并排序，其他稳定的排序算法还包括：
- 插入排序
- 冒泡排序
- 计数排序
- 基数排序

而不稳定的排序算法包括：
- 快速排序
- 堆排序
- 选择排序

```javascript
/**
 * @description 搜索结果多维度排序
 * @param {Array} results - 搜索结果数组
 * @param {Object} weights - 各维度的权重，如{relevance: 0.6, date: 0.4}
 * @returns {Array} - 排序后的结果
 */
function sortSearchResults(results, weights) {
  return [...results].sort((a, b) => {
    // 计算加权得分
    const scoreA = calculateScore(a, weights);
    const scoreB = calculateScore(b, weights);

    // 降序排列（得分高的排前面）
    return scoreB - scoreA;
  });
}

/**
 * @description 计算单个结果的加权得分
 * @param {Object} item - 搜索结果项
 * @param {Object} weights - 权重对象
 * @returns {number} - 加权得分
 */
function calculateScore(item, weights) {
  let score = 0;

  // 相关性得分 (0-1)
  if ('relevance' in weights) {
    score += item.relevance * weights.relevance;
  }

  // 日期得分 (将日期转换为0-1的分数，越新越高)
  if ('date' in weights) {
    const now = new Date();
    const itemDate = new Date(item.date);
    const ageInDays = (now - itemDate) / (1000 * 60 * 60 * 24);
    const dateScore = Math.max(0, 1 - ageInDays / 365); // 一年以内的文档
    score += dateScore * weights.date;
  }

  return score;
}
```

### 3. 自动完成/提示功能

在输入框的自动完成功能中，需要对推荐结果进行排序，通常基于匹配度和使用频率。

```javascript
/**
 * @description 自动完成推荐结果排序
 * @param {string} input - 用户输入
 * @param {Array} suggestions - 候选推荐项
 * @returns {Array} - 排序后的推荐结果
 */
function sortAutocompleteSuggestions(input, suggestions) {
  const lowerInput = input.toLowerCase();

  // 计算每个推荐项的得分
  const scoredSuggestions = suggestions.map(item => {
    const text = item.text.toLowerCase();
    let score = 0;

    // 1. 精确匹配开头（最高优先级）
    if (text.startsWith(lowerInput)) {
      score += 100;
    }
    // 2. 包含输入文本
    else if (text.includes(lowerInput)) {
      score += 50;
    }

    // 3. 考虑历史使用频率
    score += (item.frequency || 0) * 0.5;

    return { ...item, score };
  });

  // 按得分降序排序
  return scoredSuggestions
    .filter(item => item.score > 0) // 只返回有相关性的结果
    .sort((a, b) => b.score - a.score);
}
```

### 4. 拖拽排序

在支持拖拽排序的列表中，需要在用户交互后重新排序元素。

```javascript
/**
 * @description 处理列表拖拽排序
 * @param {Array} list - 原列表数据
 * @param {number} fromIndex - 拖拽项的原始索引
 * @param {number} toIndex - 拖拽项的目标索引
 * @returns {Array} - 重新排序后的列表
 */
function handleDragSort(list, fromIndex, toIndex) {
  const result = [...list];
  const [removed] = result.splice(fromIndex, 1);
  result.splice(toIndex, 0, removed);
  return result;
}

// 使用示例（React组件中）
/*
const [items, setItems] = useState(['项目1', '项目2', '项目3', '项目4']);

const onDragEnd = (result) => {
  // 拖拽结束时调用
  if (!result.destination) return;

  const newItems = handleDragSort(
    items,
    result.source.index,
    result.destination.index
  );

  setItems(newItems);
};
*/
```

### 5. 前端排序与后端排序的选择

在实际开发中，需要根据数据量和性能要求选择在前端还是后端进行排序。

```javascript
/**
 * @description 智能排序策略选择器
 * @param {Array} data - 数据数组
 * @param {string} key - 排序键
 * @param {string} order - 排序方式
 * @param {Object} options - 配置选项
 * @returns {Promise<Array>} - 排序后的数据
 */
async function smartSort(data, key, order, options = {}) {
  const {
    threshold = 1000, // 前端排序的数据量阈值
    apiEndpoint = '/api/sort', // 后端排序API
    forceClient = false, // 强制前端排序
    forceServer = false // 强制后端排序
  } = options;

  // 强制选择排序位置
  if (forceClient) {
    return clientSideSort(data, key, order);
  }

  if (forceServer) {
    return serverSideSort(data, key, order, apiEndpoint);
  }

  // 根据数据量智能选择
  if (data.length <= threshold) {
    return clientSideSort(data, key, order);
  } else {
    return serverSideSort(data, key, order, apiEndpoint);
  }
}

// 前端排序实现
function clientSideSort(data, key, order) {
  console.log('使用前端排序');
  return Promise.resolve([...data].sort((a, b) => {
    const compareResult = a[key] < b[key] ? -1 : a[key] > b[key] ? 1 : 0;
    return order === 'asc' ? compareResult : -compareResult;
  }));
}

// 后端排序实现
async function serverSideSort(data, key, order, apiEndpoint) {
  console.log('使用后端排序');
  try {
    // 这里只是示例，实际应用中可能只需要发送必要的参数
    const response = await fetch(apiEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data, key, order })
    });

    if (!response.ok) {
      throw new Error('排序请求失败');
    }

    return await response.json();
  } catch (error) {
    console.error('后端排序失败，回退到前端排序', error);
    return clientSideSort(data, key, order);
  }
}
```

## 算法选择指南

在前端开发中，选择合适的排序算法需要考虑以下因素：

1. **数据规模**：数据量大小直接影响算法选择
2. **数据特征**：数据是否接近有序、是否有大量重复元素等
3. **稳定性要求**：是否需要保持相等元素的相对顺序
4. **空间限制**：是否有额外空间使用的限制
5. **实现复杂度**：在时间紧迫的情况下，可能优先考虑实现简单的算法

### 常见场景的算法选择

| 场景 | 推荐算法 | 理由 |
|------|---------|------|
| 小数据量（<50） | 插入排序 | 常数因子小，实现简单 |
| 接近有序的数据 | 插入排序 | 时间复杂度接近O(n) |
| 大数据量通用场景 | 快速排序 | 平均性能最佳，原地排序 |
| 对稳定性有要求 | 归并排序 | 稳定的O(n log n)算法 |
| 外部排序（数据量超过内存） | 归并排序 | 可以分块处理 |
| 包含多种数据类型 | Array.sort() + 比较函数 | 浏览器优化，处理复杂情况 |
| 有大量重复元素 | 三路快排 | 有效处理重复元素 |

### JavaScript内置排序方法的选择

在实际开发中，通常使用JavaScript的内置方法：

```javascript
// 1. Array.prototype.sort()
// 优点：内置、方便、浏览器优化
// 缺点：不同浏览器实现可能不同
const sortedArray = array.sort((a, b) => a - b);

// 2. Lodash的_.sortBy()
// 优点：API简洁，支持多重排序
// 缺点：需要引入额外库
// const sortedArray = _.sortBy(array, item => item.value);

// 3. 自定义排序
// 优点：完全控制排序逻辑
// 缺点：需要自己实现和维护
function customSort(array) {
  // 根据需求选择合适的排序算法实现
}
```

### 排序算法可视化资源

以下是一些帮助理解排序算法的可视化资源：

1. [VisuAlgo - 排序算法可视化](https://visualgo.net/en/sorting)
2. [排序算法动画演示](https://www.toptal.com/developers/sorting-algorithms)
3. [USF排序算法可视化](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

**优化方法**：
1. 随机选择基准点（如上示例）
2. 三数取中法（取左中右三个元素的中间值作为基准）
3. 双基准快速排序
4. 对小规模子数组使用插入排序
5. 尾递归优化

### 7. 堆排序

堆排序是一种基于二叉堆的排序算法，它首先构建一个最大堆（或最小堆），然后将堆顶元素与末尾元素交换，调整堆结构，重复此过程。

```javascript
/**
 * @description 堆排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(heapSort(arr)); // [2, 3, 4, 5, 8]
 */
function heapSort(arr) {
  const len = arr.length;

  // 第一步：构建最大堆
  // 从最后一个非叶子节点开始，自底向上构建最大堆
  for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
    heapify(arr, len, i);
  }

  // 第二步：堆排序
  // 依次将堆顶元素（最大值）与末尾元素交换，并重新调整堆结构
  for (let i = len - 1; i > 0; i--) {
    // 将堆顶元素（当前最大值）与末尾元素交换
    [arr[0], arr[i]] = [arr[i], arr[0]];

    // 重新调整剩余元素的堆结构，使其满足最大堆特性
    heapify(arr, i, 0);
  }

  return arr;
}

/**
 * @description 调整堆结构的核心函数
 * @param {number[]} arr - 待调整的数组
 * @param {number} n - 堆的大小
 * @param {number} i - 当前需要调整的节点索引
 */
function heapify(arr, n, i) {
  // 初始化最大值为当前节点
  let largest = i;
  // 计算左子节点的索引
  const left = 2 * i + 1;
  // 计算右子节点的索引
  const right = 2 * i + 2;

  // 如果左子节点存在且大于当前最大值，更新最大值索引
  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }

  // 如果右子节点存在且大于当前最大值，更新最大值索引
  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }

  // 如果最大值不是当前节点，交换节点并继续调整堆
  if (largest !== i) {
    // 交换节点
    [arr[i], arr[largest]] = [arr[largest], arr[i]];

    // 递归调整受影响的子树
    heapify(arr, n, largest);
  }
}

// 调用示例
const heapExample = [5, 3, 8, 4, 2, 9, 1];
console.log("原始数组:", heapExample);
console.log("堆排序后:", heapSort([...heapExample]));
// 原始数组: [5, 3, 8, 4, 2, 9, 1]
// 堆排序后: [1, 2, 3, 4, 5, 8, 9]

// 执行过程分析（以[5, 3, 8, 4, 2]为例）
// 1. 构建最大堆:
//    初始数组: [5, 3, 8, 4, 2]
//    最后一个非叶子节点索引: Math.floor(5/2)-1 = 1
//
//    - 对节点1(值为3)进行heapify:
//      比较3与其子节点4的值，4 > 3，交换
//      结果: [5, 4, 8, 3, 2]
//
//    - 对节点0(值为5)进行heapify:
//      比较5与其子节点8和4的值，8 > 5，交换5与8
//      结果: [8, 4, 5, 3, 2]
//      继续调整子树，无需更多交换
//
// 2. 堆排序过程:
//    - 第1次：交换堆顶8与末尾元素2
//      结果: [2, 4, 5, 3, 8]
//      对节点0(值为2)进行heapify，重建堆
//      结果: [5, 4, 2, 3, 8]
//
//    - 第2次：交换堆顶5与末尾元素3
//      结果: [3, 4, 2, 5, 8]
//      对节点0(值为3)进行heapify，重建堆
//      结果: [4, 3, 2, 5, 8]
//
//    - 第3次：交换堆顶4与末尾元素2
//      结果: [2, 3, 4, 5, 8]
//      对节点0(值为2)进行heapify，重建堆
//      结果: [3, 2, 4, 5, 8]
//
//    - 第4次：交换堆顶3与末尾元素2
//      最终结果: [2, 3, 4, 5, 8]

// 性能测试
function testHeapSort() {
  // 生成不同大小的随机数组
  const sizes = [1000, 10000, 100000];

  for (const size of sizes) {
    const randomArray = Array.from({ length: size }, () =>
      Math.floor(Math.random() * size * 10)
    );

    const sortedArray = [...randomArray].sort((a, b) => a - b);
    const reversedArray = [...sortedArray].reverse();

    console.log(`\n测试大小为 ${size} 的数组：`);

    // 随机数组
    console.time(`随机数组 (${size} 个元素)`);
    heapSort([...randomArray]);
    console.timeEnd(`随机数组 (${size} 个元素)`);

    // 已排序数组
    console.time(`已排序数组 (${size} 个元素)`);
    heapSort([...sortedArray]);
    console.timeEnd(`已排序数组 (${size} 个元素)`);

    // 逆序数组
    console.time(`逆序数组 (${size} 个元素)`);
    heapSort([...reversedArray]);
    console.timeEnd(`逆序数组 (${size} 个元素)`);
  }
}

// 取消注释下行运行性能测试
// testHeapSort();

// 示例输出:
// 测试大小为 1000 的数组：
// 随机数组 (1000 个元素): 1.231ms
// 已排序数组 (1000 个元素): 1.124ms
// 逆序数组 (1000 个元素): 1.198ms
//
// 测试大小为 10000 的数组：
// 随机数组 (10000 个元素): 13.657ms
// 已排序数组 (10000 个元素): 13.245ms
// 逆序数组 (10000 个元素): 13.421ms
```

**时间复杂度**：
- 最好情况：O(n log n)
- 最坏情况：O(n log n)
- 平均情况：O(n log n)

**空间复杂度**：O(1)，原地排序算法

**稳定性**：不稳定

## 前端应用场景

排序算法在前端开发中有着广泛的应用，了解不同排序算法的特点可以帮助我们在实际开发中选择最合适的方案。

### 1. 数据表格排序

在前端开发中，数据表格是最常见的需要排序的场景。用户通常可以点击表头对某一列数据进行排序。

```javascript
/**
 * @description 表格数据排序函数
 * @param {Array} data - 表格数据数组
 * @param {string} key - 排序的键名
 * @param {string} order - 排序方式，'asc'或'desc'
 * @returns {Array} - 排序后的数组
 */
function sortTableData(data, key, order = 'asc') {
  return [...data].sort((a, b) => {
    // 处理不同数据类型
    if (typeof a[key] === 'string') {
      // 字符串排序，考虑本地化比较
      const compareResult = a[key].localeCompare(b[key]);
      return order === 'asc' ? compareResult : -compareResult;
    } else {
      // 数字排序
      const compareResult = a[key] - b[key];
      return order === 'asc' ? compareResult : -compareResult;
    }
  });
}

// 使用示例
const users = [
  { id: 1, name: '张三', age: 28, score: 85 },
  { id: 2, name: '李四', age: 22, score: 90 },
  { id: 3, name: '王五', age: 25, score: 85 },
  { id: 4, name: '赵六', age: 30, score: 78 }
];

// 按年龄升序排序
const sortedByAge = sortTableData(users, 'age', 'asc');
console.log('按年龄升序:', sortedByAge);

// 按姓名降序排序
const sortedByName = sortTableData(users, 'name', 'desc');
console.log('按姓名降序:', sortedByName);
```

#### 多字段排序实现

在复杂的数据表格中，经常需要实现多字段排序功能，例如先按部门排序，再按工资排序：

```javascript
/**
 * @description 多字段表格排序函数
 * @param {Array} data - 表格数据数组
 * @param {Array} sortFields - 排序字段配置数组，格式为[{field, order}]
 * @returns {Array} - 排序后的数组
 */
function multiFieldSort(data, sortFields) {
  return [...data].sort((a, b) => {
    // 遍历排序字段配置
    for (const { field, order } of sortFields) {
      // 获取当前字段的值
      const aValue = a[field];
      const bValue = b[field];

      // 跳过值相等的情况
      if (aValue === bValue) continue;

      // 根据字段类型和排序方向进行比较
      if (typeof aValue === 'string') {
        const result = aValue.localeCompare(bValue);
        return order === 'asc' ? result : -result;
      } else {
        return order === 'asc' ? aValue - bValue : bValue - aValue;
      }
    }

    // 所有字段都相等
    return 0;
  });
}

// 使用示例
const employees = [
  { id: 1, name: '张三', department: '技术部', salary: 15000 },
  { id: 2, name: '李四', department: '市场部', salary: 12000 },
  { id: 3, name: '王五', department: '技术部', salary: 18000 },
  { id: 4, name: '赵六', department: '市场部', salary: 12000 },
  { id: 5, name: '钱七', department: '技术部', salary: 15000 }
];

// 先按部门升序，再按薪资降序排序
const sortConfig = [
  { field: 'department', order: 'asc' },
  { field: 'salary', order: 'desc' }
];

const sortedEmployees = multiFieldSort(employees, sortConfig);
console.log('多字段排序结果:', sortedEmployees);
// 输出结果：先按部门分组，同部门内按薪资从高到低排序
```

### 2. 搜索结果排序

在搜索功能中，通常需要根据相关性、时间等多个维度对结果进行排序。

```javascript
/**
 * @description 搜索结果排序函数
 * @param {Array} results - 搜索结果数组
 * @param {Object} options - 排序选项
 * @returns {Array} - 排序后的结果
 */
function sortSearchResults(results, options = {}) {
  const {
    relevanceWeight = 0.6,  // 相关性权重
    dateWeight = 0.3,       // 日期权重
    popularityWeight = 0.1, // 热度权重
    sortBy = 'combined'     // 排序方式：combined, relevance, date, popularity
  } = options;

  return [...results].sort((a, b) => {
    if (sortBy === 'relevance') {
      return b.relevanceScore - a.relevanceScore;
    } else if (sortBy === 'date') {
      return new Date(b.date) - new Date(a.date);
    } else if (sortBy === 'popularity') {
      return b.views - a.views;
    } else {
      // 综合排序 - 计算加权分数
      const scoreA = (a.relevanceScore * relevanceWeight) +
                    (new Date(a.date).getTime() / 8.64e7 * dateWeight) +
                    (a.views / 1000 * popularityWeight);

      const scoreB = (b.relevanceScore * relevanceWeight) +
                    (new Date(b.date).getTime() / 8.64e7 * dateWeight) +
                    (b.views / 1000 * popularityWeight);

      return scoreB - scoreA;
    }
  });
}

// 使用示例
const searchResults = [
  { id: 1, title: '前端开发基础', relevanceScore: 0.8, date: '2023-05-15', views: 1200 },
  { id: 2, title: '高级JavaScript技巧', relevanceScore: 0.9, date: '2022-11-20', views: 3500 },
  { id: 3, title: 'React性能优化', relevanceScore: 0.7, date: '2023-06-10', views: 800 },
  { id: 4, title: 'Vue3新特性解析', relevanceScore: 0.85, date: '2023-04-05', views: 2200 }
];

// 默认综合排序
const defaultSorted = sortSearchResults(searchResults);
console.log('综合排序结果:', defaultSorted);

// 仅按相关性排序
const relevanceSorted = sortSearchResults(searchResults, { sortBy: 'relevance' });
console.log('相关性排序结果:', relevanceSorted);

// 自定义权重的综合排序
const customSorted = sortSearchResults(searchResults, {
  relevanceWeight: 0.4,
  dateWeight: 0.5,
  popularityWeight: 0.1
});
console.log('自定义权重排序结果:', customSorted);
```

### 3. 拖拽排序实现

在许多前端应用中，需要实现列表项的拖拽排序功能，这也涉及到排序算法的应用。

```javascript
/**
 * @description 拖拽排序组件示例
 */
class DraggableList {
  constructor(containerId, items) {
    this.container = document.getElementById(containerId);
    this.items = items;
    this.draggedItem = null;
    this.draggedIndex = -1;

    this.render();
    this.addEventListeners();
  }

  render() {
    this.container.innerHTML = '';

    this.items.forEach((item, index) => {
      const element = document.createElement('div');
      element.className = 'draggable-item';
      element.setAttribute('draggable', 'true');
      element.setAttribute('data-index', index);
      element.textContent = item.text;

      this.container.appendChild(element);
    });
  }

  addEventListeners() {
    const items = this.container.querySelectorAll('.draggable-item');

    items.forEach(item => {
      // 开始拖拽
      item.addEventListener('dragstart', (e) => {
        this.draggedItem = item;
        this.draggedIndex = parseInt(item.getAttribute('data-index'));
        setTimeout(() => {
          item.classList.add('dragging');
        }, 0);
      });

      // 拖拽结束
      item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
        this.draggedItem = null;
        this.draggedIndex = -1;
      });

      // 拖拽经过其他元素
      item.addEventListener('dragover', (e) => {
        e.preventDefault();
      });

      // 放置
      item.addEventListener('drop', (e) => {
        e.preventDefault();
        if (this.draggedItem) {
          const targetIndex = parseInt(item.getAttribute('data-index'));

          // 执行排序操作
          this.reorderItems(this.draggedIndex, targetIndex);

          // 重新渲染列表
          this.render();
          this.addEventListeners();
        }
      });
    });
  }

  /**
   * 重新排序数组元素
   * @param {number} fromIndex - 起始索引
   * @param {number} toIndex - 目标索引
   */
  reorderItems(fromIndex, toIndex) {
    // 保存被拖拽的元素
    const itemToMove = this.items[fromIndex];

    // 从数组中移除该元素
    this.items.splice(fromIndex, 1);

    // 在新位置插入该元素
    this.items.splice(toIndex, 0, itemToMove);
  }

  // 获取当前排序后的数据
  getItems() {
    return this.items;
  }
}

// 使用示例
const todoItems = [
  { id: 1, text: '完成项目文档' },
  { id: 2, text: '修复页面布局问题' },
  { id: 3, text: '实现新功能' },
  { id: 4, text: '代码审查' },
  { id: 5, text: '部署应用' }
];

// 初始化拖拽列表
// HTML结构: <div id="todo-list"></div>
const todoList = new DraggableList('todo-list', todoItems);

// 获取排序后的数据
console.log('排序后的待办事项:', todoList.getItems());
```

### 4. 自动完成/提示功能

在搜索框的自动完成功能中，需要对推荐结果进行排序，通常是根据匹配度和历史数据。

```javascript
/**
 * @description 自动完成推荐排序
 * @param {string} query - 用户输入的查询字符串
 * @param {Array} suggestions - 候选推荐项数组
 * @param {Object} options - 排序选项
 * @returns {Array} - 排序后的推荐结果
 */
function sortAutocompleteSuggestions(query, suggestions, options = {}) {
  const {
    maxResults = 5,
    useHistory = true,
    historicalSearches = []
  } = options;

  // 计算字符串匹配度分数
  function calculateMatchScore(suggestion, query) {
    const text = suggestion.text.toLowerCase();
    const searchQuery = query.toLowerCase();

    // 完全匹配得分最高
    if (text === searchQuery) return 1;

    // 前缀匹配得分次之
    if (text.startsWith(searchQuery)) return 0.8;

    // 包含匹配再次之
    if (text.includes(searchQuery)) {
      // 单词边界匹配得分更高
      const words = text.split(/\s+/);
      for (const word of words) {
        if (word.startsWith(searchQuery)) return 0.7;
      }
      return 0.5;
    }

    // 编辑距离计算模糊匹配度
    // 这里使用简化版，实际可以用Levenshtein距离算法
    let matchCount = 0;
    for (let i = 0; i < searchQuery.length; i++) {
      if (text.includes(searchQuery[i])) matchCount++;
    }
    return matchCount / searchQuery.length * 0.3;
  }

  // 为每个推荐项计算综合分数
  const scoredSuggestions = suggestions.map(suggestion => {
    // 基础匹配分数
    let score = calculateMatchScore(suggestion, query);

    // 考虑历史搜索频率
    if (useHistory) {
      const historyItem = historicalSearches.find(h => h.text === suggestion.text);
      if (historyItem) {
        // 历史搜索频率加权
        score += Math.min(historyItem.frequency / 10, 0.5);
      }
    }

    // 考虑推荐项自身权重
    if (suggestion.weight) {
      score += suggestion.weight * 0.2;
    }

    return { ...suggestion, score };
  });

  // 按分数排序并限制结果数量
  return scoredSuggestions
    .sort((a, b) => b.score - a.score)
    .slice(0, maxResults);
}

// 使用示例
const userQuery = 'jav';

const allSuggestions = [
  { id: 1, text: 'JavaScript基础教程' },
  { id: 2, text: 'Java编程入门' },
  { id: 3, text: 'JavaScript框架比较' },
  { id: 4, text: 'Python vs JavaScript' },
  { id: 5, text: 'JavaScript设计模式' },
  { id: 6, text: 'Java虚拟机原理' },
  { id: 7, text: 'TypeScript和JavaScript区别' },
  { id: 8, text: '如何学习JavaScript' }
];

const historicalSearches = [
  { text: 'JavaScript基础教程', frequency: 5 },
  { text: 'JavaScript设计模式', frequency: 3 },
  { text: 'Java编程入门', frequency: 2 }
];

// 获取排序后的推荐结果
const sortedSuggestions = sortAutocompleteSuggestions(userQuery, allSuggestions, {
  maxResults: 4,
  useHistory: true,
  historicalSearches
});

console.log('推荐结果:', sortedSuggestions);
```

### 5. 前端排序与后端排序选择

在实际开发中，需要权衡何时使用前端排序，何时使用后端排序。

```javascript
/**
 * @description 前端/后端排序选择辅助函数
 * @param {Array} data - 需要排序的数据
 * @param {Object} options - 排序选项
 * @returns {Object} - 排序策略建议
 */
function determineSortingStrategy(data, options = {}) {
  const {
    dataSize = data.length,
    isInitialLoad = true,
    sortFrequency = 'low', // 'low', 'medium', 'high'
    networkCondition = 'good', // 'poor', 'good', 'excellent'
    serverCapability = 'normal', // 'limited', 'normal', 'powerful'
    clientDevice = 'desktop' // 'mobile', 'desktop', 'powerful'
  } = options;

  // 决策因素评分
  let frontendScore = 0;
  let backendScore = 0;

  // 1. 数据量评估
  if (dataSize < 1000) {
    frontendScore += 3;
  } else if (dataSize < 10000) {
    frontendScore += 1;
    backendScore += 1;
  } else {
    backendScore += 3;
  }

  // 2. 是否初次加载
  if (isInitialLoad) {
    backendScore += 2; // 初次加载通常由后端预排序更高效
  } else {
    frontendScore += 1; // 后续交互排序可以在前端进行
  }

  // 3. 排序频率
  if (sortFrequency === 'high') {
    frontendScore += 2; // 高频排序在前端进行可减少请求
  } else if (sortFrequency === 'medium') {
    frontendScore += 1;
  } else {
    backendScore += 1; // 低频排序可以接受网络延迟
  }

  // 4. 网络状况
  if (networkCondition === 'poor') {
    frontendScore += 2; // 网络不佳时前端排序可减少请求
  } else if (networkCondition === 'excellent') {
    backendScore += 1;
  }

  // 5. 服务器能力
  if (serverCapability === 'powerful') {
    backendScore += 2;
  } else if (serverCapability === 'limited') {
    frontendScore += 2;
  }

  // 6. 客户端设备
  if (clientDevice === 'powerful') {
    frontendScore += 2;
  } else if (clientDevice === 'mobile') {
    backendScore += 1;
  }

  // 决策结果
  const recommendation = {
    strategy: frontendScore > backendScore ? 'frontend' : 'backend',
    frontendScore,
    backendScore,
    reasons: []
  };

  // 添加决策理由
  if (dataSize >= 10000) {
    recommendation.reasons.push('数据量较大，后端排序更高效');
  } else if (dataSize < 1000) {
    recommendation.reasons.push('数据量较小，前端排序响应更快');
  }

  if (sortFrequency === 'high') {
    recommendation.reasons.push('排序频率高，前端排序可减少请求次数');
  }

  if (networkCondition === 'poor') {
    recommendation.reasons.push('网络状况不佳，前端排序可提供更好的用户体验');
  }

  if (clientDevice === 'mobile' && dataSize > 5000) {
    recommendation.reasons.push('移动设备处理大量数据排序可能影响性能');
  }

  return recommendation;
}

// 使用示例
const tableData = Array.from({ length: 8000 }, (_, i) => ({
  id: i + 1,
  name: `Item ${i + 1}`,
  category: ['A', 'B', 'C', 'D'][Math.floor(Math.random() * 4)],
  price: Math.floor(Math.random() * 1000) + 1,
  stock: Math.floor(Math.random() * 100) + 1
}));

// 场景1: 数据表格初始加载
const initialLoadStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: true,
  sortFrequency: 'low',
  networkCondition: 'good',
  serverCapability: 'normal',
  clientDevice: 'desktop'
});
console.log('初始加载排序策略:', initialLoadStrategy);

// 场景2: 用户频繁切换排序条件
const frequentSortingStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: false,
  sortFrequency: 'high',
  networkCondition: 'good',
  serverCapability: 'normal',
  clientDevice: 'desktop'
});
console.log('频繁排序策略:', frequentSortingStrategy);

// 场景3: 移动设备访问
const mobileSortingStrategy = determineSortingStrategy(tableData, {
  isInitialLoad: true,
  sortFrequency: 'medium',
  networkCondition: 'poor',
  serverCapability: 'normal',
  clientDevice: 'mobile'
});
console.log('移动设备排序策略:', mobileSortingStrategy);
```

#### 前端排序与后端排序的选择指南

| 因素 | 前端排序 | 后端排序 |
|------|---------|----------|
| **数据量** | 适合小型数据集(<1000条) | 适合大型数据集(>10000条) |
| **排序频率** | 适合高频排序操作 | 适合低频排序操作 |
| **网络状况** | 适合网络不稳定环境 | 适合网络良好环境 |
| **初始加载** | 不太适合 | 非常适合 |
| **分页数据** | 仅适合当前页数据 | 适合跨页排序 |
| **客户端性能** | 依赖客户端性能 | 不依赖客户端性能 |
| **实现复杂度** | 简单，使用Array.sort即可 | 需要后端API支持 |
| **用户体验** | 即时响应，无加载状态 | 有网络延迟，需要加载状态 |

#### 混合策略最佳实践

在实际项目中，通常采用混合策略：

1. **初始加载**：使用后端排序，与数据获取同时进行
2. **本地交互**：对当前页数据使用前端排序
3. **复杂排序**：多字段排序、模糊匹配等复杂排序使用后端实现
4. **全局排序**：需要对全部数据排序时使用后端排序
5. **缓存策略**：对常用排序结果进行缓存，减少重复计算

## 面试常见问题

### 1. 请解释一下JavaScript中Array.sort()的工作原理，以及它的时间复杂度是多少？

**答案**：

JavaScript中的`Array.sort()`方法的实现因浏览器而异，但大多数现代浏览器采用以下策略：

- 对于小数组（通常少于10-20个元素），使用**插入排序**（时间复杂度O(n²)）
- 对于大数组，使用**快速排序**的变种或**TimSort**（结合了归并排序和插入排序的混合算法）

因此，`Array.sort()`的平均时间复杂度为O(n log n)，但在最坏情况下可能达到O(n²)。

需要注意的是，如果不提供比较函数，`Array.sort()`会将元素转换为字符串，然后按照Unicode编码进行比较，这可能导致意外的排序结果，特别是对数字排序时：

```javascript
// 不提供比较函数的数字排序
const numbers = [10, 5, 40, 25, 1000, 1];
console.log(numbers.sort()); // [1, 10, 1000, 25, 40, 5]

// 正确的数字排序
console.log(numbers.sort((a, b) => a - b)); // [1, 5, 10, 25, 40, 1000]
```

### 2. 在前端开发中，如何优化大数据量表格的排序性能？

**答案**：

优化大数据量表格排序性能的策略包括：

1. **虚拟滚动**：只渲染可视区域的数据，减少DOM操作

```javascript
function createVirtualizedTable(data, containerSelector) {
  const container = document.querySelector(containerSelector);
  const rowHeight = 40; // 每行高度
  const visibleRows = Math.ceil(container.clientHeight / rowHeight);
  let scrollTop = 0;
  let sortedData = [...data];

  // 设置容器总高度
  function updateTotalHeight() {
    container.style.height = `${data.length * rowHeight}px`;
  }

  // 渲染可见行
  function renderVisibleRows() {
    const startIndex = Math.floor(scrollTop / rowHeight);
    const endIndex = Math.min(startIndex + visibleRows + 2, data.length);

    container.innerHTML = '';
    for (let i = startIndex; i < endIndex; i++) {
      const row = document.createElement('div');
      row.className = 'table-row';
      row.style.position = 'absolute';
      row.style.top = `${i * rowHeight}px`;
      row.style.height = `${rowHeight}px`;
      row.textContent = JSON.stringify(sortedData[i]);
      container.appendChild(row);
    }
  }

  // 排序函数
  function sortData(key, direction = 'asc') {
    sortedData = [...data].sort((a, b) => {
      return direction === 'asc' ? a[key] - b[key] : b[key] - a[key];
    });
    renderVisibleRows();
  }

  // 监听滚动事件
  container.addEventListener('scroll', () => {
    scrollTop = container.scrollTop;
    renderVisibleRows();
  });

  updateTotalHeight();
  renderVisibleRows();

  return { sortData };
}
```

2. **Web Worker**：将排序操作放在后台线程中执行，避免阻塞UI

```javascript
// main.js
const worker = new Worker('sort-worker.js');

worker.onmessage = function(e) {
  const { sortedData, requestId } = e.data;
  // 更新UI显示排序后的数据
  updateTableUI(sortedData);
};

function sortTable(data, sortKey, sortOrder) {
  const requestId = Date.now();
  worker.postMessage({
    data,
    sortKey,
    sortOrder,
    requestId
  });
}

// sort-worker.js
self.onmessage = function(e) {
  const { data, sortKey, sortOrder, requestId } = e.data;

  const sortedData = [...data].sort((a, b) => {
    if (sortOrder === 'asc') {
      return a[sortKey] > b[sortKey] ? 1 : -1;
    } else {
      return a[sortKey] < b[sortKey] ? 1 : -1;
    }
  });

  self.postMessage({ sortedData, requestId });
};
```

3. **分页排序**：只对当前页数据进行排序，减少计算量
4. **预排序缓存**：缓存常用排序结果，避免重复计算
5. **防抖处理**：对于用户频繁切换排序条件的情况，使用防抖处理
6. **索引优化**：为大数据集创建索引，加速查找和排序

### 3. 请比较快速排序和归并排序的优缺点，以及它们在前端应用中的适用场景。

**答案**：

**快速排序**：

优点：
- 平均情况下性能优秀，时间复杂度O(n log n)
- 原地排序，空间复杂度O(log n)（递归调用栈）
- 缓存友好，局部性好

缺点：
- 最坏情况下时间复杂度为O(n²)
- 不稳定排序（相等元素的相对位置可能改变）

**归并排序**：

优点：
- 稳定排序（相等元素的相对位置不变）
- 最好、最坏、平均情况下时间复杂度都是O(n log n)
- 适合处理链表等非随机访问的数据结构

缺点：
- 需要额外O(n)的空间复杂度
- 对于小数组，常数因子较大

**适用场景**：

快速排序适用于：
- 内存受限但CPU资源充足的场景
- 对排序稳定性没有要求的场景
- 数据分布较为随机的场景

```javascript
// 前端表格大数据排序，使用快速排序
function quickSortTable(data, key) {
  if (data.length <= 5000) {
    // 数据量不大，直接在主线程排序
    return quickSort(data, key);
  } else {
    // 数据量大，使用Web Worker
    return new Promise(resolve => {
      const worker = new Worker('quicksort-worker.js');
      worker.onmessage = e => {
        resolve(e.data);
        worker.terminate();
      };
      worker.postMessage({ data, key });
    });
  }
}
```

归并排序适用于：
- 需要稳定排序的场景（如保持用户的初始排序偏好）
- 外部排序（数据太大，无法全部加载到内存）
- 对排序结果有可预测性要求的场景

```javascript
// 用户交互历史记录排序，使用归并排序保持相对顺序
function sortUserInteractions(interactions, timestamp) {
  // 使用归并排序保持相同时间戳的交互顺序不变
  return mergeSort(interactions, (a, b) => a[timestamp] - b[timestamp]);
}
```

### 4. 如何实现一个支持多字段排序的数据表格？

**答案**：

实现多字段排序的数据表格需要考虑以下几点：

1. 定义排序优先级
2. 实现比较函数支持多字段比较
3. 提供用户界面支持多字段排序设置

```javascript
/**
 * @description 多字段排序函数
 * @param {Array} data - 要排序的数据数组
 * @param {Array} sortFields - 排序字段配置数组，格式为[{field, direction}]
 * @returns {Array} - 排序后的数组
 */
function multiFieldSort(data, sortFields) {
  return [...data].sort((a, b) => {
    // 依次比较每个排序字段
    for (const { field, direction } of sortFields) {
      // 获取字段值
      const valueA = getNestedValue(a, field);
      const valueB = getNestedValue(b, field);

      // 跳过相等的值
      if (valueA === valueB) continue;

      // 根据字段类型和排序方向比较
      const compareResult = compareValues(valueA, valueB);
      return direction === 'asc' ? compareResult : -compareResult;
    }

    // 所有字段都相等
    return 0;
  });
}

// 获取嵌套对象的值（支持 'user.profile.name' 这样的路径）
function getNestedValue(obj, path) {
  return path.split('.').reduce((o, key) => (o && o[key] !== undefined) ? o[key] : null, obj);
}

// 根据值类型进行比较
function compareValues(a, b) {
  // 处理null和undefined
  if (a === null || a === undefined) return -1;
  if (b === null || b === undefined) return 1;

  // 根据类型比较
  if (typeof a === 'string' && typeof b === 'string') {
    return a.localeCompare(b);
  } else if (a instanceof Date && b instanceof Date) {
    return a - b;
  } else {
    return a < b ? -1 : 1;
  }
}

// 使用示例
const users = [
  { name: 'Alice', age: 30, role: 'Admin', lastLogin: new Date('2023-05-10') },
  { name: 'Bob', age: 25, role: 'User', lastLogin: new Date('2023-06-15') },
  { name: 'Charlie', age: 30, role: 'User', lastLogin: new Date('2023-05-20') },
  { name: 'David', age: 28, role: 'Admin', lastLogin: new Date('2023-06-10') },
  { name: 'Alice', age: 22, role: 'User', lastLogin: new Date('2023-06-05') }
];

// 按角色升序，年龄降序，姓名升序排序
const sortedUsers = multiFieldSort(users, [
  { field: 'role', direction: 'asc' },
  { field: 'age', direction: 'desc' },
  { field: 'name', direction: 'asc' }
]);

console.log(sortedUsers);
```

在React中实现多字段排序的表格组件：

```jsx
import React, { useState, useMemo } from 'react';

function SortableTable({ data, columns }) {
  const [sortConfig, setSortConfig] = useState([]);

  // 处理列标题点击
  const handleHeaderClick = (field) => {
    setSortConfig(prevSortConfig => {
      // 查找当前字段是否已在排序配置中
      const fieldIndex = prevSortConfig.findIndex(config => config.field === field);

      if (fieldIndex >= 0) {
        // 字段已存在，切换排序方向或移除
        const newConfig = [...prevSortConfig];
        if (newConfig[fieldIndex].direction === 'asc') {
          newConfig[fieldIndex].direction = 'desc';
        } else {
          // 已经是降序，移除此排序字段
          newConfig.splice(fieldIndex, 1);
        }
        return newConfig;
      } else {
        // 添加新的排序字段（按住Shift键添加多字段排序）
        if (window.event && window.event.shiftKey) {
          return [...prevSortConfig, { field, direction: 'asc' }];
        } else {
          // 不按Shift则替换所有排序
          return [{ field, direction: 'asc' }];
        }
      }
    });
  };

  // 排序后的数据
  const sortedData = useMemo(() => {
    if (sortConfig.length === 0) return data;
    return multiFieldSort(data, sortConfig);
  }, [data, sortConfig]);

  // 获取列标题的排序指示器
  const getSortIndicator = (field) => {
    const config = sortConfig.find(config => config.field === field);
    if (!config) return null;

    const index = sortConfig.indexOf(config) + 1;
    return (
      <span className="sort-indicator">
        {config.direction === 'asc' ? '↑' : '↓'}
        {sortConfig.length > 1 && <sup>{index}</sup>}
      </span>
    );
  };

  return (
    <table className="sortable-table">
      <thead>
        <tr>
          {columns.map(column => (
            <th
              key={column.field}
              onClick={() => handleHeaderClick(column.field)}
              className={sortConfig.some(config => config.field === column.field) ? 'sorted' : ''}
            >
              {column.title} {getSortIndicator(column.field)}
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {sortedData.map((row, rowIndex) => (
          <tr key={rowIndex}>
            {columns.map(column => (
              <td key={column.field}>{row[column.field]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

### 5. 如何在不使用Array.sort()的情况下，实现一个稳定的排序算法？

**答案**：

可以实现一个稳定的归并排序算法，它能保证相等元素的相对顺序不变：

```javascript
/**
 * @description 稳定的归并排序实现
 * @param {Array} arr - 要排序的数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 排序后的新数组
 */
function stableMergeSort(arr, compareFn = (a, b) => a - b) {
  // 基本情况：数组长度为0或1时已经排序
  if (arr.length <= 1) return [...arr];

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = stableMergeSort(arr.slice(0, mid), compareFn);
  const right = stableMergeSort(arr.slice(mid), compareFn);

  // 合并两个已排序的数组
  return merge(left, right, compareFn);
}

/**
 * @description 合并两个已排序的数组
 * @param {Array} left - 左侧已排序数组
 * @param {Array} right - 右侧已排序数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 合并后的已排序数组
 */
function merge(left, right, compareFn) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较并合并两个数组
  while (leftIndex < left.length && rightIndex < right.length) {
    // 使用 <= 0 而不是 < 0 来确保稳定性
    // 当比较结果为0（相等）时，优先选择左侧数组的元素
    if (compareFn(left[leftIndex], right[rightIndex]) <= 0) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 添加剩余元素
  return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}

// 使用示例：对对象数组进行稳定排序
const students = [
  { name: 'Alice', grade: 'A', enrollmentOrder: 1 },
  { name: 'Bob', grade: 'B', enrollmentOrder: 2 },
  { name: 'Charlie', grade: 'A', enrollmentOrder: 3 },
  { name: 'David', grade: 'C', enrollmentOrder: 4 },
  { name: 'Eve', grade: 'B', enrollmentOrder: 5 },
  { name: 'Frank', grade: 'A', enrollmentOrder: 6 }
];

// 按成绩排序，成绩相同时保持原有顺序
const sortedByGrade = stableMergeSort(students, (a, b) => {
  // 按字母顺序比较成绩（A > B > C）
  return a.grade.localeCompare(b.grade);
});

console.log('按成绩排序（稳定）:', sortedByGrade);
// 可以看到所有成绩为A的学生（Alice, Charlie, Frank）保持了原有的相对顺序
```

稳定排序在以下场景特别有用：

1. **多级排序**：先按一个条件排序，再按另一个条件排序
2. **保持用户意图**：如用户手动调整过的项目顺序
3. **动画过渡**：在数据可视化中，稳定排序可以使元素位置变化更可预测，便于实现平滑过渡

除了归并排序，其他稳定的排序算法还包括：
- 插入排序
- 冒泡排序
- 计数排序
- 基数排序

而不稳定的排序算法包括：
- 快速排序
- 堆排序
- 选择排序

```javascript
/**
 * @description 搜索结果多维度排序
 * @param {Array} results - 搜索结果数组
 * @param {Object} weights - 各维度的权重，如{relevance: 0.6, date: 0.4}
 * @returns {Array} - 排序后的结果
 */
function sortSearchResults(results, weights) {
  return [...results].sort((a, b) => {
    // 计算加权得分
    const scoreA = calculateScore(a, weights);
    const scoreB = calculateScore(b, weights);

    // 降序排列（得分高的排前面）
    return scoreB - scoreA;
  });
}

/**
 * @description 计算单个结果的加权得分
 * @param {Object} item - 搜索结果项
 * @param {Object} weights - 权重对象
 * @returns {number} - 加权得分
 */
function calculateScore(item, weights) {
  let score = 0;

  // 相关性得分 (0-1)
  if ('relevance' in weights) {
    score += item.relevance * weights.relevance;
  }

  // 日期得分 (将日期转换为0-1的分数，越新越高)
  if ('date' in weights) {
    const now = new Date();
    const itemDate = new Date(item.date);
    const ageInDays = (now - itemDate) / (1000 * 60 * 60 * 24);
    const dateScore = Math.max(0, 1 - ageInDays / 365); // 一年以内的文档
    score += dateScore * weights.date;
  }

  return score;
}
```

### 3. 自动完成/提示功能

在输入框的自动完成功能中，需要对推荐结果进行排序，通常基于匹配度和使用频率。

```javascript
/**
 * @description 自动完成推荐结果排序
 * @param {string} input - 用户输入
 * @param {Array} suggestions - 候选推荐项
 * @returns {Array} - 排序后的推荐结果
 */
function sortAutocompleteSuggestions(input, suggestions) {
  const lowerInput = input.toLowerCase();

  // 计算每个推荐项的得分
  const scoredSuggestions = suggestions.map(item => {
    const text = item.text.toLowerCase();
    let score = 0;

    // 1. 精确匹配开头（最高优先级）
    if (text.startsWith(lowerInput)) {
      score += 100;
    }
    // 2. 包含输入文本
    else if (text.includes(lowerInput)) {
      score += 50;
    }

    // 3. 考虑历史使用频率
    score += (item.frequency || 0) * 0.5;

    return { ...item, score };
  });

  // 按得分降序排序
  return scoredSuggestions
    .filter(item => item.score > 0) // 只返回有相关性的结果
    .sort((a, b) => b.score - a.score);
}
```

### 4. 拖拽排序

在支持拖拽排序的列表中，需要在用户交互后重新排序元素。

```javascript
/**
 * @description 处理列表拖拽排序
 * @param {Array} list - 原列表数据
 * @param {number} fromIndex - 拖拽项的原始索引
 * @param {number} toIndex - 拖拽项的目标索引
 * @returns {Array} - 重新排序后的列表
 */
function handleDragSort(list, fromIndex, toIndex) {
  const result = [...list];
  const [removed] = result.splice(fromIndex, 1);
  result.splice(toIndex, 0, removed);
  return result;
}

// 使用示例（React组件中）
/*
const [items, setItems] = useState(['项目1', '项目2', '项目3', '项目4']);

const onDragEnd = (result) => {
  // 拖拽结束时调用
  if (!result.destination) return;

  const newItems = handleDragSort(
    items,
    result.source.index,
    result.destination.index
  );

  setItems(newItems);
};
*/
```

### 5. 前端排序与后端排序的选择

在实际开发中，需要根据数据量和性能要求选择在前端还是后端进行排序。

```javascript
/**
 * @description 智能排序策略选择器
 * @param {Array} data - 数据数组
 * @param {string} key - 排序键
 * @param {string} order - 排序方式
 * @param {Object} options - 配置选项
 * @returns {Promise<Array>} - 排序后的数据
 */
async function smartSort(data, key, order, options = {}) {
  const {
    threshold = 1000, // 前端排序的数据量阈值
    apiEndpoint = '/api/sort', // 后端排序API
    forceClient = false, // 强制前端排序
    forceServer = false // 强制后端排序
  } = options;

  // 强制选择排序位置
  if (forceClient) {
    return clientSideSort(data, key, order);
  }

  if (forceServer) {
    return serverSideSort(data, key, order, apiEndpoint);
  }

  // 根据数据量智能选择
  if (data.length <= threshold) {
    return clientSideSort(data, key, order);
  } else {
    return serverSideSort(data, key, order, apiEndpoint);
  }
}

// 前端排序实现
function clientSideSort(data, key, order) {
  console.log('使用前端排序');
  return Promise.resolve([...data].sort((a, b) => {
    const compareResult = a[key] < b[key] ? -1 : a[key] > b[key] ? 1 : 0;
    return order === 'asc' ? compareResult : -compareResult;
  }));
}

// 后端排序实现
async function serverSideSort(data, key, order, apiEndpoint) {
  console.log('使用后端排序');
  try {
    // 这里只是示例，实际应用中可能只需要发送必要的参数
    const response = await fetch(apiEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data, key, order })
    });

    if (!response.ok) {
      throw new Error('排序请求失败');
    }

    return await response.json();
  } catch (error) {
    console.error('后端排序失败，回退到前端排序', error);
    return clientSideSort(data, key, order);
  }
}
```

## 算法选择指南

在前端开发中，选择合适的排序算法需要考虑以下因素：

1. **数据规模**：数据量大小直接影响算法选择
2. **数据特征**：数据是否接近有序、是否有大量重复元素等
3. **稳定性要求**：是否需要保持相等元素的相对顺序
4. **空间限制**：是否有额外空间使用的限制
5. **实现复杂度**：在时间紧迫的情况下，可能优先考虑实现简单的算法

### 常见场景的算法选择

| 场景 | 推荐算法 | 理由 |
|------|---------|------|
| 小数据量（<50） | 插入排序 | 常数因子小，实现简单 |
| 接近有序的数据 | 插入排序 | 时间复杂度接近O(n) |
| 大数据量通用场景 | 快速排序 | 平均性能最佳，原地排序 |
| 对稳定性有要求 | 归并排序 | 稳定的O(n log n)算法 |
| 外部排序（数据量超过内存） | 归并排序 | 可以分块处理 |
| 包含多种数据类型 | Array.sort() + 比较函数 | 浏览器优化，处理复杂情况 |
| 有大量重复元素 | 三路快排 | 有效处理重复元素 |

### JavaScript内置排序方法的选择

在实际开发中，通常使用JavaScript的内置方法：

```javascript
// 1. Array.prototype.sort()
// 优点：内置、方便、浏览器优化
// 缺点：不同浏览器实现可能不同
const sortedArray = array.sort((a, b) => a - b);

// 2. Lodash的_.sortBy()
// 优点：API简洁，支持多重排序
// 缺点：需要引入额外库
// const sortedArray = _.sortBy(array, item => item.value);

// 3. 自定义排序
// 优点：完全控制排序逻辑
// 缺点：需要自己实现和维护
function customSort(array) {
  // 根据需求选择合适的排序算法实现
}
```

### 排序算法可视化资源

以下是一些帮助理解排序算法的可视化资源：

1. [VisuAlgo - 排序算法可视化](https://visualgo.net/en/sorting)
2. [排序算法动画演示](https://www.toptal.com/developers/sorting-algorithms)
3. [USF排序算法可视化](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

**堆排序的特点**：
1. 不受输入数据的影响，最好、最坏、平均时间复杂度都是O(n log n)
2. 空间复杂度低，是一种原地排序算法
3. 适合处理大数据量的排序
4. 对于部分排序的数据没有优化，性能不如快速排序
5. 实现复杂度高于简单排序算法（如冒泡、插入）

### 8. 计数排序

计数排序是一种非比较排序算法，它使用一个额外的数组来存储元素的出现次数，然后根据这个计数数组重建排序后的数组。

```javascript
/**
 * @description 计数排序实现
 * @param {number[]} arr - 待排序的数组（假设元素都是非负整数）
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2, 5, 3, 1];
 * console.log(countingSort(arr)); // [1, 2, 3, 3, 4, 5, 5, 8]
 */
function countingSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值
  const max = Math.max(...arr);

  // 创建计数数组，长度为max+1（包含0到max）
  const counts = new Array(max + 1).fill(0);

  // 统计每个元素出现的次数
  for (let i = 0; i < arr.length; i++) {
    counts[arr[i]]++;
  }

  // 根据计数数组重建排序后的数组
  const result = [];
  for (let i = 0; i <= max; i++) {
    // 将该元素加入结果数组counts[i]次
    while (counts[i] > 0) {
      result.push(i);
      counts[i]--;
    }
  }

  return result;
}

/**
 * @description 优化版计数排序实现（使用前缀和，保持稳定性）
 * @param {number[]} arr - 待排序的数组（假设元素都是非负整数）
 * @returns {number[]} - 排序后的数组
 */
function stableCountingSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值
  const max = Math.max(...arr);

  // 创建计数数组
  const counts = new Array(max + 1).fill(0);

  // 统计每个元素出现的次数
  for (let i = 0; i < arr.length; i++) {
    counts[arr[i]]++;
  }

  // 将counts转换为累加数组（前缀和），表示小于等于索引i的元素个数
  for (let i = 1; i <= max; i++) {
    counts[i] += counts[i - 1];
  }

  // 创建结果数组
  const result = new Array(arr.length);

  // 从后向前遍历原数组，保持稳定性
  for (let i = arr.length - 1; i >= 0; i--) {
    // counts[arr[i]]是arr[i]应该放置的位置（索引+1）
    // 所以实际索引是counts[arr[i]]-1
    result[counts[arr[i]] - 1] = arr[i];
    counts[arr[i]]--; // 减少计数，以处理重复元素
  }

  return result;
}

// 调用示例
const countingExample = [5, 3, 8, 4, 2, 5, 3, 1];
console.log("原始数组:", countingExample);
console.log("计数排序后:", countingSort([...countingExample]));
console.log("稳定计数排序后:", stableCountingSort([...countingExample]));
// 原始数组: [5, 3, 8, 4, 2, 5, 3, 1]
// 计数排序后: [1, 2, 3, 3, 4, 5, 5, 8]
// 稳定计数排序后: [1, 2, 3, 3, 4, 5, 5, 8]

// 执行过程分析（以[5, 3, 8, 4, 2]为例）
// 基本计数排序:
// 1. 找到最大值: max = 8
// 2. 创建计数数组: counts = [0, 0, 0, 0, 0, 0, 0, 0, 0]（长度为9）
// 3. 统计每个元素出现次数:
//    - counts[5]++ → [0, 0, 0, 0, 0, 1, 0, 0, 0]
//    - counts[3]++ → [0, 0, 0, 1, 0, 1, 0, 0, 0]
//    - counts[8]++ → [0, 0, 0, 1, 0, 1, 0, 0, 1]
//    - counts[4]++ → [0, 0, 0, 1, 1, 1, 0, 0, 1]
//    - counts[2]++ → [0, 0, 1, 1, 1, 1, 0, 0, 1]
// 4. 重建排序后的数组:
//    - 添加1个2: [2]
//    - 添加1个3: [2, 3]
//    - 添加1个4: [2, 3, 4]
//    - 添加1个5: [2, 3, 4, 5]
//    - 添加1个8: [2, 3, 4, 5, 8]
//
// 稳定计数排序:
// 1. 找到最大值: max = 8
// 2. 创建计数数组和计算频率同上
// 3. 计算前缀和:
//    - counts[0] = 0
//    - counts[1] = 0 + 0 = 0
//    - counts[2] = 0 + 1 = 1
//    - counts[3] = 1 + 1 = 2
//    - counts[4] = 2 + 1 = 3
//    - counts[5] = 3 + 1 = 4
//    - counts[6] = 4 + 0 = 4
//    - counts[7] = 4 + 0 = 4
//    - counts[8] = 4 + 1 = 5
// 4. 从后向前遍历原数组:
//    - arr[4] = 2, counts[2] = 1, result[0] = 2, counts[2]--
//    - arr[3] = 4, counts[4] = 3, result[2] = 4, counts[4]--
//    - arr[2] = 8, counts[8] = 5, result[4] = 8, counts[8]--
//    - arr[1] = 3, counts[3] = 2, result[1] = 3, counts[3]--
//    - arr[0] = 5, counts[5] = 4, result[3] = 5, counts[5]--
// 5. 最终结果: [2, 3, 4, 5, a8]

// 性能测试
function compareCountingSorts() {
  const sizes = [10000, 100000];
  const maxValues = [100, 1000, 10000];

  for (const size of sizes) {
    for (const maxValue of maxValues) {
      // 生成随机数组，元素大小在0到maxValue之间
      const randomArray = Array.from({ length: size }, () =>
        Math.floor(Math.random() * (maxValue + 1))
      );

      console.log(`\n测试大小为 ${size} 的数组，元素范围为 0-${maxValue}：`);

      // JavaScript内置排序
      console.time('JavaScript内置排序');
      [...randomArray].sort((a, b) => a - b);
      console.timeEnd('JavaScript内置排序');

      // 基本计数排序
      console.time('基本计数排序');
      countingSort([...randomArray]);
      console.timeEnd('基本计数排序');

      // 稳定计数排序
      console.time('稳定计数排序');
      stableCountingSort([...randomArray]);
      console.timeEnd('稳定计数排序');
    }
  }
}

// 取消注释下行运行性能测试
// compareCountingSorts();

// 示例输出:
// 测试大小为 10000 的数组，元素范围为 0-100：
// JavaScript内置排序: 2.564ms
// 基本计数排序: 0.425ms
// 稳定计数排序: 0.622ms
//
// 测试大小为 10000 的数组，元素范围为 0-1000：
// JavaScript内置排序: 2.427ms
// 基本计数排序: 1.186ms
// 稳定计数排序: 1.354ms
//
// 测试大小为 100000 的数组，元素范围为 0-100：
// JavaScript内置排序: 31.275ms
// 基本计数排序: 2.684ms
// 稳定计数排序: 3.842ms
```

**时间复杂度**：O(n + k)，其中k是数组中的最大值

**空间复杂度**：O(k)

**稳定性**：
- 基本实现：稳定
- 优化实现：稳定

**适用场景**：
1. 适合对整数进行排序
2. 特别适合当数据范围（k）相对较小时
3. 当需要O(n)时间复杂度时
4. 不适合数据范围非常大的情况（如排序浮点数）

### 9. 桶排序

桶排序是将数据分到有限数量的桶里，每个桶再分别排序（可能使用别的排序算法或递归使用桶排序）。

```javascript
/**
 * @description 桶排序实现
 * @param {number[]} arr - 待排序的数组
 * @param {number} [bucketSize=5] - 每个桶的大小
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2, 7, 1, 6];
 * console.log(bucketSort(arr)); // [1, 2, 3, 4, 5, 6, 7, 8]
 */
function bucketSort(arr, bucketSize = 5) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值和最小值
  const min = Math.min(...arr);
  const max = Math.max(...arr);

  // 计算桶的数量
  const bucketCount = Math.floor((max - min) / bucketSize) + 1;
  const buckets = new Array(bucketCount);

  // 初始化桶
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = [];
  }

  // 将元素分配到桶中
  for (let i = 0; i < arr.length; i++) {
    const bucketIndex = Math.floor((arr[i] - min) / bucketSize);
    buckets[bucketIndex].push(arr[i]);
  }

  // 对每个桶进行排序，并合并结果
  const result = [];
  for (let i = 0; i < bucketCount; i++) {
    // 使用插入排序对每个桶进行排序
    insertionSort(buckets[i]);
    result.push(...buckets[i]);
  }

  return result;
}

/**
 * @description 优化版桶排序（处理均匀分布的数据）
 * @param {number[]} arr - 待排序的数组
 * @param {number} [bucketCount=10] - 桶的数量
 * @returns {number[]} - 排序后的数组
 */
function optimizedBucketSort(arr, bucketCount = 10) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值和最小值
  const min = Math.min(...arr);
  const max = Math.max(...arr);

  // 桶的大小
  const bucketSize = (max - min) / bucketCount + 1;
  const buckets = new Array(bucketCount);

  // 初始化桶
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = [];
  }

  // 将元素分配到桶中
  for (const num of arr) {
    const bucketIndex = Math.floor((num - min) / bucketSize);
    buckets[bucketIndex].push(num);
  }

  // 对每个桶进行排序，并合并结果
  const result = [];
  for (const bucket of buckets) {
    if (bucket.length > 0) {
      // 使用更高效的排序方法
      bucket.sort((a, b) => a - b);
      result.push(...bucket);
    }
  }

  return result;
}

// 调用示例
const bucketExample = [5, 3, 8, 4, 2, 7, 1, 6];
console.log("原始数组:", bucketExample);
console.log("桶排序后:", bucketSort([...bucketExample]));
console.log("优化桶排序后:", optimizedBucketSort([...bucketExample]));
// 原始数组: [5, 3, 8, 4, 2, 7, 1, 6]
// 桶排序后: [1, 2, 3, 4, 5, 6, 7, 8]
// 优化桶排序后: [1, 2, 3, 4, 5, 6, 7, 8]

// 执行过程分析（以[5, 3, 8, 4, 2, 7, 1, 6]为例，桶大小为3）
// 1. 找到最大值max=8和最小值min=1
// 2. 计算桶的数量：bucketCount = Math.floor((8 - 1) / 3) + 1 = 3
// 3. 创建3个空桶
// 4. 将元素分配到桶中：
//    - 桶0 (1-3): [1, 2, 3]
//    - 桶1 (4-6): [5, 4, 6]
//    - 桶2 (7-9): [8, 7]
// 5. 对每个桶排序:
//    - 桶0: [1, 2, 3]
//    - 桶1: [4, 5, 6]
//    - 桶2: [7, 8]
// 6. 合并结果: [1, 2, 3, 4, 5, 6, 7, 8]

// 性能测试
function compareBucketSorts() {
  // 生成三种分布的数组
  function generateArrays(size) {
    // 均匀分布
    const uniform = Array.from({ length: size }, () =>
      Math.random() * 1000
    );

    // 聚集分布（元素集中在某些范围）
    const clustered = [];
    for (let i = 0; i < size; i++) {
      // 80%的元素在0-200范围内，20%在800-1000范围内
      if (Math.random() < 0.8) {
        clustered.push(Math.random() * 200);
      } else {
        clustered.push(800 + Math.random() * 200);
      }
    }

    // 倾斜分布（大部分元素小，少数元素大）
    const skewed = Array.from({ length: size }, () =>
      Math.pow(Math.random(), 2) * 1000
    );

    return { uniform, clustered, skewed };
  }

  const sizes = [10000];

  for (const size of sizes) {
    const { uniform, clustered, skewed } = generateArrays(size);

    console.log(`\n测试大小为 ${size} 的均匀分布数组：`);
    testSortingAlgorithms(uniform);

    console.log(`\n测试大小为 ${size} 的聚集分布数组：`);
    testSortingAlgorithms(clustered);

    console.log(`\n测试大小为 ${size} 的倾斜分布数组：`);
    testSortingAlgorithms(skewed);
  }

  function testSortingAlgorithms(arr) {
    // JavaScript内置排序
    console.time('JavaScript内置排序');
    [...arr].sort((a, b) => a - b);
    console.timeEnd('JavaScript内置排序');

    // 基本桶排序（固定桶大小）
    console.time('基本桶排序');
    bucketSort([...arr]);
    console.timeEnd('基本桶排序');

    // 优化桶排序（固定桶数量）
    console.time('优化桶排序');
    optimizedBucketSort([...arr]);
    console.timeEnd('优化桶排序');

    // 不同桶数量的测试
    for (const count of [5, 20, 50]) {
      console.time(`桶排序(${count}个桶)`);
      optimizedBucketSort([...arr], count);
      console.timeEnd(`桶排序(${count}个桶)`);
    }
  }
}

// 取消注释下行运行性能测试
// compareBucketSorts();

// 示例输出:
// 测试大小为 10000 的均匀分布数组：
// JavaScript内置排序: 3.127ms
// 基本桶排序: 8.354ms
// 优化桶排序: 5.216ms
// 桶排序(5个桶): 5.032ms
// 桶排序(20个桶): 3.874ms
// 桶排序(50个桶): 3.245ms
//
// 测试大小为 10000 的聚集分布数组：
// JavaScript内置排序: 2.851ms
// 基本桶排序: 6.234ms
// 优化桶排序: 4.723ms
// 桶排序(5个桶): 6.857ms
// 桶排序(20个桶): 4.125ms
// 桶排序(50个桶): 3.567ms
```

**时间复杂度**：
- 平均情况：O(n + k)，其中k是桶的数量
- 最坏情况：O(n²)，当所有元素都被分到同一个桶中时

**空间复杂度**：O(n + k)

**稳定性**：取决于桶内排序算法的稳定性

**桶排序的优化策略**：
1. 根据数据分布特性选择合适的桶数量
2. 对均匀分布的数据，使用更多的桶来提高性能
3. 根据数据范围动态调整桶的大小
4. 结合其他高效排序算法作为桶内排序方法
5. 对于大数据量，可以并行处理不同的桶

### 10. 基数排序

基数排序是一种非比较型整数排序算法，它按照位数来排序，从最低位开始，依次按位数进行排序，直到最高位。

```javascript
/**
 * @description 基数排序实现（仅适用于非负整数）
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [170, 45, 75, 90, 802, 24, 2, 66];
 * console.log(radixSort(arr)); // [2, 24, 45, 66, 75, 90, 170, 802]
 */
function radixSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出最大值，确定最大位数
  const max = Math.max(...arr);
  let maxDigits = 0;
  while (Math.pow(10, maxDigits) <= max) {
    maxDigits++;
  }

  // 按照每一位进行计数排序
  let result = [...arr];
  for (let digit = 0; digit < maxDigits; digit++) {
    // 创建10个桶（对应0-9）
    const buckets = Array.from({ length: 10 }, () => []);

    // 将元素分配到桶中
    for (let i = 0; i < result.length; i++) {
      // 获取当前位的值
      const digitValue = Math.floor(result[i] / Math.pow(10, digit)) % 10;
      buckets[digitValue].push(result[i]);
    }

    // 合并桶中的元素
    result = [].concat(...buckets);
  }

  return result;
}

/**
 * @description 基数排序的优化实现（减少创建数组的开销）
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 */
function optimizedRadixSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出最大值
  const max = Math.max(...arr);

  // 当前基数（从个位开始）
  let radix = 1;

  // 结果数组，初始为原数组的副本
  const result = [...arr];

  // 临时数组，用于存储排序结果
  const temp = new Array(arr.length);

  // 当前基数小于最大值时继续排序
  while (radix <= max) {
    // 计数数组，记录每个数字出现的次数
    const count = new Array(10).fill(0);

    // 统计每个数字出现的次数
    for (let i = 0; i < result.length; i++) {
      const digit = Math.floor(result[i] / radix) % 10;
      count[digit]++;
    }

    // 将count转换为累加数组
    for (let i = 1; i < 10; i++) {
      count[i] += count[i - 1];
    }

    // 从后向前遍历，保持稳定性
    for (let i = result.length - 1; i >= 0; i--) {
      const digit = Math.floor(result[i] / radix) % 10;
      temp[count[digit] - 1] = result[i];
      count[digit]--;
    }

    // 将临时数组的值复制回结果数组
    for (let i = 0; i < result.length; i++) {
      result[i] = temp[i];
    }

    // 进位，处理下一个数位
    radix *= 10;
  }

  return result;
}

// 调用示例
const radixExample = [170, 45, 75, 90, 802, 24, 2, 66];
console.log("原始数组:", radixExample);
console.log("基数排序后:", radixSort([...radixExample]));
console.log("优化基数排序后:", optimizedRadixSort([...radixExample]));
// 原始数组: [170, 45, 75, 90, 802, 24, 2, 66]
// 基数排序后: [2, 24, 45, 66, 75, 90, 170, 802]
// 优化基数排序后: [2, 24, 45, 66, 75, 90, 170, 802]

// 执行过程分析（以[170, 45, 75, 90, 802, 24, 2, 66]为例）
// 1. 找到最大值802，确定最大位数为3
// 2. 第一轮：按个位数排序
//    - 桶0: [170, 90]
//    - 桶2: [802, 2]
//    - 桶4: [24]
//    - 桶5: [45, 75]
//    - 桶6: [66]
//    - 合并结果: [170, 90, 802, 2, 24, 45, 75, 66]
// 3. 第二轮：按十位数排序
//    - 桶0: [802, 2]
//    - 桶2: [24]
//    - 桶4: [45]
//    - 桶6: [66]
//    - 桶7: [170, 75]
//    - 桶9: [90]
//    - 合并结果: [802, 2, 24, 45, 66, 170, 75, 90]
// 4. 第三轮：按百位数排序
//    - 桶0: [2, 24, 45, 66, 75, 90]
//    - 桶1: [170]
//    - 桶8: [802]
//    - 合并结果: [2, 24, 45, 66, 75, 90, 170, 802]

// 性能测试
function compareRadixSorts() {
  const sizes = [10000, 100000];
  const maxValues = [999, 9999, 99999];

  for (const size of sizes) {
    for (const maxValue of maxValues) {
      // 生成随机数组，元素大小在0到maxValue之间
      const randomArray = Array.from({ length: size }, () =>
        Math.floor(Math.random() * (maxValue + 1))
      );

      console.log(`\n测试大小为 ${size} 的数组，元素范围为 0-${maxValue}：`);

      // JavaScript内置排序
      console.time('JavaScript内置排序');
      [...randomArray].sort((a, b) => a - b);
      console.timeEnd('JavaScript内置排序');

      // 基本基数排序
      console.time('基本基数排序');
      radixSort([...randomArray]);
      console.timeEnd('基本基数排序');

      // 优化基数排序
      console.time('优化基数排序');
      optimizedRadixSort([...randomArray]);
      console.timeEnd('优化基数排序');
    }
  }
}

// 取消注释下行运行性能测试
// compareRadixSorts();

// 示例输出:
// 测试大小为 10000 的数组，元素范围为 0-999：
// JavaScript内置排序: 2.954ms
// 基本基数排序: 3.845ms
// 优化基数排序: 2.431ms
//
// 测试大小为 10000 的数组，元素范围为 0-9999：
// JavaScript内置排序: 3.175ms
// 基本基数排序: 5.231ms
// 优化基数排序: 3.842ms
//
// 测试大小为 100000 的数组，元素范围为 0-999：
// JavaScript内置排序: 34.215ms
// 基本基数排序: 32.567ms
// 优化基数排序: 23.654ms
```

**时间复杂度**：O(d * (n + k))，其中d是最大位数，k是基数（这里是10）

**空间复杂度**：O(n + k)

**稳定性**：稳定

**基数排序的特点**：
1. 适用于整数和字符串等可以按位比较的数据
2. 当数据位数较少时效率很高
3. 不需要比较元素的大小，只需要按位进行计数排序
4. 对于数值范围大但位数少的数据特别有效
5. 具有稳定性，适合对具有多个排序关键字的记录进行排序

**基数排序的局限性**：
1. 只适用于可以按位比较的数据类型
2. 对于负数需要特殊处理
3. 对于浮点数排序需要转换为整数
4. 当数据位数很多时，性能可能不如比较排序算法

## 排序算法的比较

| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 |
|---------|--------------|---------|---------|-----------|-------|
| 冒泡排序 | O(n²) | O(n) | O(n²) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 插入排序 | O(n²) | O(n) | O(n²) | O(1) | 稳定 |
| 希尔排序 | O(n log² n) | O(n log² n) | O(n²) | O(1) | 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不稳定 |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 |
| 计数排序 | O(n + k) | O(n + k) | O(n + k) | O(k) | 稳定 |
| 桶排序 | O(n + k) | O(n + k) | O(n²) | O(n + k) | 取决于桶内排序算法 |
| 基数排序 | O(d * (n + k)) | O(d * (n + k)) | O(d * (n + k)) | O(n + k) | 稳定 |

## 面试常见问题

### 1. 快速排序和归并排序的区别是什么？各自的优缺点？

**答**：

快速排序和归并排序都是高效的比较排序算法，时间复杂度为O(n log n)，但它们的工作原理、性能特点和适用场景有所不同。

**工作原理比较**：

```javascript
/**
 * @description 快速排序实现
 */
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    // 分区过程 - 选择基准并将数组分为两部分
    const pivotIndex = partition(arr, left, right);

    // 递归排序两个子数组
    quickSort(arr, left, pivotIndex - 1);  // 排序基准左侧
    quickSort(arr, pivotIndex + 1, right); // 排序基准右侧
  }
  return arr;
}

function partition(arr, left, right) {
  // 选择最右元素为基准
  const pivot = arr[right];
  let i = left - 1;

  // 将小于基准的元素移到左侧
  for (let j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 将基准放到正确位置
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}

/**
 * @description 归并排序实现
 */
function mergeSort(arr) {
  // 基本情况 - 数组长度为0或1时已排序
  if (arr.length <= 1) return arr;

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  // 递归排序两半，然后合并
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较两个数组的元素，将较小的元素添加到结果数组
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 添加剩余元素
  return result.concat(
    left.slice(leftIndex),
    right.slice(rightIndex)
  );
}
```

**主要区别**：

| 特性 | 快速排序 | 归并排序 |
|------|----------|----------|
| **分治策略** | 先分区，后递归处理 | 先递归分割，后合并 |
| **原地排序** | 是（空间复杂度O(log n)） | 否（需要额外O(n)空间） |
| **稳定性** | 不稳定 | 稳定 |
| **时间复杂度** | 最好/平均：O(n log n)<br>最坏：O(n²) | 稳定在O(n log n) |
| **适用场景** | 随机访问数据<br>内存受限环境 | 链表排序<br>稳定性要求高 |
| **缓存效率** | 高（局部性好） | 一般 |
| **并行潜力** | 较低 | 高 |

**优缺点分析**：

**快速排序**：
- **优点**：
  - 原地排序，空间效率高
  - 平均情况下非常快
  - 缓存友好，局部性好
  - 常数因子小，实际性能常优于其他O(n log n)算法
- **缺点**：
  - 最坏情况下时间复杂度为O(n²)
  - 对于已排序或近乎排序的数据表现不佳
  - 不稳定排序，相等元素的相对位置可能改变
  - 对于小数组，递归开销较大

**归并排序**：
- **优点**：
  - 稳定排序，保持相等元素的相对顺序
  - 时间复杂度稳定在O(n log n)，不受输入数据分布影响
  - 适合外部排序和链表排序
  - 易于并行化实现
- **缺点**：
  - 需要额外O(n)的空间
  - 对于小数组，常数因子较大
  - 缓存效率不如快速排序
  - 不是原地排序，空间效率较低

**性能比较**：

```javascript
// 性能测试比较
function comparePerformance() {
  const sizes = [1000, 10000, 100000];

  for (const size of sizes) {
    console.log(`\n测试大小为 ${size} 的数组：`);

    // 生成三种测试数组
    const random = Array.from({ length: size }, () => Math.floor(Math.random() * size));
    const nearSorted = Array.from({ length: size }, (_, i) => i + Math.floor(Math.random() * 10 - 5));
    const reversed = Array.from({ length: size }, (_, i) => size - i);

    // 测试随机数组
    console.log("随机数组：");
    testAlgorithms(random);

    // 测试近乎排序的数组
    console.log("近乎排序的数组：");
    testAlgorithms(nearSorted);

    // 测试逆序数组
    console.log("逆序数组：");
    testAlgorithms(reversed);
  }

  function testAlgorithms(arr) {
    // 快速排序测试
    const quickArr = [...arr];
    console.time('快速排序');
    quickSort(quickArr);
    console.timeEnd('快速排序');

    // 归并排序测试
    const mergeArr = [...arr];
    console.time('归并排序');
    mergeSort(mergeArr);
    console.timeEnd('归并排序');
  }
}

// 输出示例 (仅供参考，实际性能因环境而异)
// 测试大小为 10000 的数组：
// 随机数组：
// 快速排序: 5.212ms
// 归并排序: 8.354ms
// 近乎排序的数组：
// 快速排序: 12.571ms (性能下降)
// 归并排序: 7.921ms
// 逆序数组：
// 快速排序: 15.324ms (性能显著下降)
// 归并排序: 8.234ms (性能稳定)
```

**在实际应用中的选择**：

1. **选择快速排序的情况**：
   - 内存空间有限
   - 对原地排序有要求
   - 数据是随机分布的
   - 排序稳定性不重要
   - 追求平均情况下的最佳性能

2. **选择归并排序的情况**：
   - 要求排序稳定性
   - 对时间复杂度最坏情况有严格要求
   - 处理链表等顺序访问的数据结构
   - 可以使用额外的内存空间
   - 需要外部排序（如大文件排序）

**前端开发中的应用**：
- 在前端处理中小型数据集时，两种算法都适用
- 对于需要稳定排序的UI元素（如表格排序），归并排序更合适
- 对于频繁排序的操作，快速排序通常性能更好
- 实际项目中，可以考虑混合策略：小数组使用插入排序，大数组根据数据特性选择快速排序或归并排序

## 学习资源

- [JavaScript数据结构 - 排序算法](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting) - GitHub上的JS实现
- [排序算法可视化](https://visualgo.net/en/sorting) - 排序算法的可视化演示
- [LeetCode排序题集](https://leetcode.com/tag/sorting/) - 相关算法练习
- [前端进阶之道 - 排序算法](https://juejin.cn/post/6844903814134104078) - 前端视角的排序算法讲解
- [JavaScript排序算法详解](https://www.freecodecamp.org/news/sorting-algorithms-explained/) - FreeCodeCamp上的教程

## JavaScript内置排序

JavaScript提供了内置的`Array.prototype.sort()`方法，它接受一个可选的比较函数作为参数：

```javascript
/**
 * @description 演示JavaScript内置排序方法的用法
 */
function demonstrateJavaScriptSort() {
  console.log("=== JavaScript内置排序示例 ===");

  // 1. 基本用法 - 默认按字典序排序
const fruits = ['banana', 'apple', 'orange', 'grape'];
  fruits.sort();
  console.log("默认字符串排序:", fruits);
  // 输出: ['apple', 'banana', 'grape', 'orange']

  // 2. 数字排序 - 需要提供比较函数
  const numbers = [10, 5, 8, 2, 1, 100];

  // 错误的数字排序方式（会按字符串比较）
  const wrongSorted = [...numbers].sort();
  console.log("错误的数字排序:", wrongSorted);
  // 输出: [1, 10, 100, 2, 5, 8] - 按字符串排序！

  // 正确的数字排序方式
  const correctSorted = [...numbers].sort((a, b) => a - b);
  console.log("正确的数字排序(升序):", correctSorted);
  // 输出: [1, 2, 5, 8, 10, 100]

  const descendingSorted = [...numbers].sort((a, b) => b - a);
  console.log("降序排序:", descendingSorted);
  // 输出: [100, 10, 8, 5, 2, 1]

  // 3. 对象排序
const people = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 20 },
    { name: 'David', age: 25 }
];

// 按年龄排序
  const byAge = [...people].sort((a, b) => a.age - b.age);
  console.log("按年龄排序:", byAge.map(p => `${p.name}(${p.age})`).join(', '));
  // 输出: Charlie(20), Alice(25), David(25), Bob(30)

// 按名字排序
  const byName = [...people].sort((a, b) => a.name.localeCompare(b.name));
  console.log("按名字排序:", byName.map(p => p.name).join(', '));
  // 输出: Alice, Bob, Charlie, David

  // 4. 多条件排序
  // 先按年龄，再按名字
  const multiCriteria = [...people].sort((a, b) => {
    if (a.age !== b.age) {
      return a.age - b.age;
    }
    return a.name.localeCompare(b.name);
  });
  console.log("多条件排序:", multiCriteria.map(p => `${p.name}(${p.age})`).join(', '));
  // 输出: Charlie(20), Alice(25), David(25), Bob(30)

  // 5. 自定义排序逻辑
  const items = ['Item 1', 'item 2', 'Item 10', 'item 11'];

  // 不区分大小写，按数字正确排序
  items.sort((a, b) => {
    // 提取数字部分
    const numA = parseInt(a.match(/\d+/)[0]);
    const numB = parseInt(b.match(/\d+/)[0]);

    // 如果数字不同，按数字排序
    if (numA !== numB) {
      return numA - numB;
    }

    // 否则不区分大小写排序
    return a.toLowerCase().localeCompare(b.toLowerCase());
  });

  console.log("自定义排序:", items);
  // 输出: ['Item 1', 'item 2', 'Item 10', 'item 11']
}

// 调用示例
// demonstrateJavaScriptSort();
```

不同浏览器实现的排序算法可能不同，但大多数现代浏览器使用的是一种混合排序算法，如TimSort（归并排序和插入排序的混合）或IntroSort（快速排序、堆排序和插入排序的混合）。

**JavaScript内置排序的特点**：

1. **算法实现**：
   - **V8引擎(Chrome, Node.js)**：对于长度小于等于10的数组使用插入排序，对于长度大于10的数组使用快速排序或TimSort（V8版本7.0及以后）
   - **SpiderMonkey(Firefox)**：使用归并排序
   - **JavaScriptCore(Safari)**：使用归并排序的变体
   - **Chakra(旧版Edge)**：使用快速排序的变体

2. **稳定性**：在ES2019(ES10)规范之后，明确要求排序算法是稳定的。但不同浏览器实现可能有差异。

3. **默认行为**：默认按Unicode码点排序（字符串比较），对数字需要提供比较函数。

4. **性能特点**：
   - 对小数组（通常<10）使用插入排序
   - 对大数组使用O(n log n)的算法（快速排序或TimSort）
   - 现代浏览器会根据数组特性自适应选择排序算法

**前端排序最佳实践**：

1. **数字排序**：
   ```javascript
   // ✅ 正确方法
   numbers.sort((a, b) => a - b);

   // ❌ 错误方法（按字符串排序）
   numbers.sort();
   ```

2. **字符串排序**：
   ```javascript
   // 区分大小写排序
   strings.sort();

   // 不区分大小写排序
   strings.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

   // 国际化支持（考虑不同语言的排序规则）
   strings.sort((a, b) => a.localeCompare(b, 'zh-CN')); // 中文排序
   ```

3. **对象排序**：
   ```javascript
   // 按单个属性排序
   users.sort((a, b) => a.age - b.age);

   // 按多个属性排序
   users.sort((a, b) => {
     // 首先按角色排序
     const roleOrder = { admin: 1, user: 2, guest: 3 };
     if (roleOrder[a.role] !== roleOrder[b.role]) {
       return roleOrder[a.role] - roleOrder[b.role];
     }
     // 角色相同则按名字排序
     return a.name.localeCompare(b.name);
   });
   ```

4. **性能优化**：
   ```javascript
   // 对于频繁排序的场景，缓存排序函数
   const sortByAge = (a, b) => a.age - b.age;
   users.sort(sortByAge);

   // 对于大数据集，考虑仅排序可见部分
   const visibleData = allData.slice(offset, offset + pageSize);
   visibleData.sort((a, b) => a - b);
   ```

5. **前端表格排序**：
   ```javascript
   // 表格排序功能示例
   function sortTable(tableId, columnIndex) {
     const table = document.getElementById(tableId);
     const tbody = table.querySelector('tbody');
     const rows = Array.from(tbody.querySelectorAll('tr'));

     // 获取当前排序方向
     const sortDirection = tbody.dataset.sortDirection === 'asc' ? 'desc' : 'asc';
     tbody.dataset.sortDirection = sortDirection;

     // 排序行
     rows.sort((rowA, rowB) => {
       const cellA = rowA.cells[columnIndex].textContent.trim();
       const cellB = rowB.cells[columnIndex].textContent.trim();

       // 尝试作为数字比较
       const numA = parseFloat(cellA);
       const numB = parseFloat(cellB);

       if (!isNaN(numA) && !isNaN(numB)) {
         return sortDirection === 'asc' ? numA - numB : numB - numA;
       }

       // 否则作为字符串比较
       return sortDirection === 'asc'
         ? cellA.localeCompare(cellB)
         : cellB.localeCompare(cellA);
     });

     // 重新插入排序后的行
     rows.forEach(row => tbody.appendChild(row));
   }
   ```

6. **稳定排序示例**：
   ```javascript
   // 稳定多条件排序（先按提交时间排序，再按分数排序）
   const submissions = [
     { name: 'Alice', score: 85, time: '10:15' },
     { name: 'Bob', score: 90, time: '10:10' },
     { name: 'Charlie', score: 85, time: '10:05' },
     { name: 'David', score: 90, time: '10:20' }
   ];

   // 先按提交时间排序
   submissions.sort((a, b) => a.time.localeCompare(b.time));

   // 再按分数排序（稳定排序保持同分数下的时间顺序）
   submissions.sort((a, b) => b.score - a.score);

   // 结果:
   // Bob: 90分 (10:10)
   // David: 90分 (10:20)
   // Charlie: 85分 (10:05)
   // Alice: 85分 (10:15)
   ```

## 面试常见问题

### 2. 如何优化快速排序以避免最坏情况？

**答**：

快速排序最坏情况（O(n²)）通常发生在数组已排序或几乎排序，或者有大量重复元素的情况下，因为这会导致分区极度不平衡。下面是几种常用的优化策略及其实现：

#### 1. 随机选择基准元素

最简单有效的优化是随机选择基准元素，而不是总是选择第一个或最后一个元素：

```javascript
/**
 * @description 使用随机基准的快速排序
 */
function randomizedQuickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = randomizedPartition(arr, left, right);
    randomizedQuickSort(arr, left, pivotIndex - 1);
    randomizedQuickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

function randomizedPartition(arr, left, right) {
  // 随机选择基准点
  const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
  // 将随机选择的元素与最右元素交换
  [arr[randomIndex], arr[right]] = [arr[right], arr[randomIndex]];

  // 执行标准分区过程
  return partition(arr, left, right);
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left - 1;

  for (let j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}
```

#### 2. 三数取中法（Median-of-three）

这种方法取左端、中间、右端三个元素的中间值作为基准，减少选择到最值的可能性：

```javascript
/**
 * @description 使用三数取中法的快速排序
 */
function medianOfThreeQuickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = medianOfThreePartition(arr, left, right);
    medianOfThreeQuickSort(arr, left, pivotIndex - 1);
    medianOfThreeQuickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

function medianOfThreePartition(arr, left, right) {
  // 选择左中右三个位置的中间值作为基准
  const mid = Math.floor((left + right) / 2);

  // 对三个元素进行排序
  if (arr[left] > arr[mid]) [arr[left], arr[mid]] = [arr[mid], arr[left]];
  if (arr[left] > arr[right]) [arr[left], arr[right]] = [arr[right], arr[left]];
  if (arr[mid] > arr[right]) [arr[mid], arr[right]] = [arr[right], arr[mid]];

  // 将中间值（现在在arr[mid]）与右边前一个元素交换
  // 这样可以把基准放在倒数第二个位置，有助于分区过程
  [arr[mid], arr[right - 1]] = [arr[right - 1], arr[mid]];

  // 基准是arr[right - 1]
  const pivot = arr[right - 1];

  // 分区过程（从left+1到right-2，因为left和right已知）
  let i = left;
  for (let j = left + 1; j < right - 1; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 将基准放在正确位置
  [arr[i + 1], arr[right - 1]] = [arr[right - 1], arr[i + 1]];
  return i + 1;
}
```

#### 3. 对小规模子数组使用插入排序

当子数组规模小于某个阈值时，使用插入排序更高效：

```javascript
/**
 * @description 混合使用快速排序和插入排序
 */
function hybridQuickSort(arr, left = 0, right = arr.length - 1) {
  // 小规模数组使用插入排序
  if (right - left < 10) {
    insertionSort(arr, left, right);
    return arr;
  }

  if (left < right) {
    const pivotIndex = randomizedPartition(arr, left, right);
    hybridQuickSort(arr, left, pivotIndex - 1);
    hybridQuickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

function insertionSort(arr, left, right) {
  for (let i = left + 1; i <= right; i++) {
    const key = arr[i];
    let j = i - 1;

    while (j >= left && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
  return arr;
}
```

#### 4. 三路快速排序（处理重复元素）

对于有大量重复元素的数组，三路快速排序将数组分为三部分：小于、等于和大于基准的元素：

```javascript
/**
 * @description 三路快速排序
 */
function threeWayQuickSort(arr, left = 0, right = arr.length - 1) {
  if (right <= left) return;

  // 随机选择基准并交换到首位置
  const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
  [arr[left], arr[randomIndex]] = [arr[randomIndex], arr[left]];
  const pivot = arr[left];

  // 三路分区
  let lt = left;      // arr[left...lt-1] < pivot
  let gt = right;     // arr[gt+1...right] > pivot
  let i = left + 1;   // arr[lt...i-1] == pivot

  while (i <= gt) {
    if (arr[i] < pivot) {
      // 小于基准的元素放到左边
      [arr[lt], arr[i]] = [arr[i], arr[lt]];
      lt++;
      i++;
    } else if (arr[i] > pivot) {
      // 大于基准的元素放到右边
      [arr[i], arr[gt]] = [arr[gt], arr[i]];
      gt--;
      // 注意i不增加，因为交换过来的元素还未处理
    } else {
      // 等于基准的元素留在中间
      i++;
    }
  }

  // 递归处理左右两部分，中间部分（等于基准）已排好序
  threeWayQuickSort(arr, left, lt - 1);
  threeWayQuickSort(arr, gt + 1, right);

  return arr;
}
```

#### 5. 尾递归优化

通过尾递归优化减少递归调用栈的深度，降低栈溢出风险：

```javascript
/**
 * @description 尾递归优化的快速排序
 */
function tailRecursiveQuickSort(arr, left = 0, right = arr.length - 1) {
  while (left < right) {
    const pivotIndex = partition(arr, left, right);

    // 递归处理较小的子数组
    // 迭代处理较大的子数组（减少递归深度）
    if (pivotIndex - left < right - pivotIndex) {
      tailRecursiveQuickSort(arr, left, pivotIndex - 1);
      left = pivotIndex + 1;
    } else {
      tailRecursiveQuickSort(arr, pivotIndex + 1, right);
      right = pivotIndex - 1;
    }
  }
  return arr;
}
```

#### 性能比较分析

```javascript
/**
 * @description 比较不同快速排序优化策略的性能
 */
function compareQuickSortOptimizations() {
  // 生成测试数据
  function generateArrays(size) {
    // 随机数组
    const random = Array.from({ length: size }, () => Math.floor(Math.random() * size));

    // 已排序数组
    const sorted = Array.from({ length: size }, (_, i) => i);

    // 近乎排序的数组
    const nearlySorted = Array.from(sorted);
    for (let i = 0; i < size * 0.1; i++) {
      const j = Math.floor(Math.random() * size);
      const k = Math.floor(Math.random() * size);
      [nearlySorted[j], nearlySorted[k]] = [nearlySorted[k], nearlySorted[j]];
    }

    // 包含大量重复元素的数组
    const repeating = Array.from({ length: size }, () => Math.floor(Math.random() * (size / 10)));

    return { random, sorted, nearlySorted, repeating };
  }

  const size = 10000;
  console.log(`测试大小为 ${size} 的数组：`);

  const arrays = generateArrays(size);

  // 测试不同类型的数组
  for (const [type, array] of Object.entries(arrays)) {
    console.log(`\n${type} 数组：`);

    // 标准快速排序
    test("标准快速排序", () => quickSort([...array]));

    // 随机基准快速排序
    test("随机基准快速排序", () => randomizedQuickSort([...array]));

    // 三数取中快速排序
    test("三数取中快速排序", () => medianOfThreeQuickSort([...array]));

    // 混合快排和插入排序
    test("混合快速插入排序", () => hybridQuickSort([...array]));

    // 三路快速排序
    test("三路快速排序", () => threeWayQuickSort([...array]));

    // 尾递归优化快速排序
    test("尾递归快速排序", () => tailRecursiveQuickSort([...array]));
  }

  function test(name, sortFn) {
    const start = performance.now();
    sortFn();
    const end = performance.now();
    console.log(`${name}: ${(end - start).toFixed(3)}ms`);
  }
}

// 测试结果示例（结果会因环境而异）
// random 数组：
// 标准快速排序: 3.245ms
// 随机基准快速排序: 3.512ms
// 三数取中快速排序: 2.987ms
// 混合快速插入排序: 2.754ms
// 三路快速排序: 3.621ms
// 尾递归快速排序: 3.354ms

// sorted 数组：
// 标准快速排序: 150.325ms (性能大幅下降)
// 随机基准快速排序: 3.487ms
// 三数取中快速排序: 2.876ms
// 混合快速插入排序: 2.654ms
// 三路快速排序: 3.112ms
// 尾递归快速排序: 3.421ms

// repeating 数组：
// 标准快速排序: 21.547ms
// 随机基准快速排序: 10.234ms
// 三数取中快速排序: 8.654ms
// 混合快速插入排序: 7.987ms
// 三路快速排序: 3.325ms (对重复元素效果最好)
// 尾递归快速排序: 9.854ms
```

#### 优化策略适用场景

| 优化策略 | 最适用场景 | 优点 | 缺点 |
|---------|------------|------|------|
| 随机选择基准 | 各种数据分布 | 简单易实现，有效预防最坏情况 | 增加随机数生成开销 |
| 三数取中法 | 近乎排序的数据 | 减少选择不良基准的可能性 | 实现复杂，小数组效果不明显 |
| 混合插入排序 | 包含小规模子数组 | 减少小数组的递归开销 | 需要确定合适的阈值 |
| 三路快速排序 | 大量重复元素 | 高效处理重复元素 | 实现复杂，额外比较开销 |
| 尾递归优化 | 大规模数据 | 减少递归深度，防止栈溢出 | 代码复杂度增加 |

#### 前端项目中的实践建议

1. **一般情况下，随机选择基准元素已经是一个很好的优化**，实现简单且效果显著
2. **对于前端处理的数据集，混合快速排序和插入排序**通常能提供良好的性能
3. **处理用户输入数据（可能部分排序）时**，考虑使用三数取中法
4. **表格排序等UI操作中**，若存在大量重复值（如状态、类别），三路快排更高效
5. **大型数据可视化应用**中，考虑使用尾递归优化防止栈溢出

在实际选择时，可以根据数据特性和应用场景选择最合适的优化策略，或结合多种策略。

### 3. 什么是稳定排序？在什么情况下需要使用稳定排序？

**答**：

#### 稳定排序的定义

**稳定排序**是指排序算法在排序过程中保持相等元素的相对顺序。换句话说，如果排序前数组中有两个相等的元素A和B，且A在B之前，那么排序后A仍然在B之前。

#### 稳定性示例演示

```javascript
/**
 * @description 演示排序算法的稳定性
 */
function demonstrateSortingStability() {
  // 创建一个带有附加信息的数组
  const students = [
    { id: 1, name: "Alice", score: 85 },
    { id: 2, name: "Bob", score: 90 },
    { id: 3, name: "Charlie", score: 85 }, // 与Alice分数相同
    { id: 4, name: "David", score: 75 },
    { id: 5, name: "Eve", score: 90 }      // 与Bob分数相同
  ];

  console.log("原始顺序:");
  students.forEach(s => console.log(`${s.name}: ${s.score}`));

  // 使用稳定排序（JavaScript内置sort是稳定的，从ES2019开始）
  const stableSorted = [...students].sort((a, b) => a.score - b.score);

  console.log("\n稳定排序后 (按分数):");
  stableSorted.forEach(s => console.log(`${s.name}: ${s.score}`));
  // 预期输出:
  // David: 75
  // Alice: 85 (保持在Charlie之前)
  // Charlie: 85
  // Bob: 90 (保持在Eve之前)
  // Eve: 90

  // 手动实现不稳定排序（选择排序）来展示区别
  function unstableSelectionSort(arr) {
    const result = [...arr];
    for (let i = 0; i < result.length; i++) {
      let minIndex = i;

      for (let j = i + 1; j < result.length; j++) {
        if (result[j].score < result[minIndex].score) {
          minIndex = j;
        }
      }

      if (minIndex !== i) {
        [result[i], result[minIndex]] = [result[minIndex], result[i]];
      }
    }
    return result;
  }

  const unstableSorted = unstableSelectionSort(students);

  console.log("\n不稳定排序后 (按分数):");
  unstableSorted.forEach(s => console.log(`${s.name}: ${s.score}`));
  // 可能的输出:
  // David: 75
  // Charlie: 85 (可能与Alice交换了位置)
  // Alice: 85
  // Eve: 90 (可能与Bob交换了位置)
  // Bob: 90
}
```

#### 常见的稳定排序和不稳定排序算法

**稳定的排序算法**：
- 冒泡排序 (Bubble Sort)
- 插入排序 (Insertion Sort)
- 归并排序 (Merge Sort)
- 计数排序 (Counting Sort)
- 桶排序 (Bucket Sort)
- 基数排序 (Radix Sort)

**不稳定的排序算法**：
- 选择排序 (Selection Sort)
- 堆排序 (Heap Sort)
- 快速排序 (Quick Sort)
- 希尔排序 (Shell Sort)

#### 需要使用稳定排序的场景

1. **多级排序**

当需要按照多个条件依次排序，且希望后一次排序不破坏前一次排序的结果时：

```javascript
/**
 * @description 多级排序示例
 */
function multiLevelSortingExample() {
  // 员工数据
  const employees = [
    { id: 1, name: "Zhang", department: "HR", salary: 10000 },
    { id: 2, name: "Wang", department: "IT", salary: 15000 },
    { id: 3, name: "Li", department: "IT", salary: 12000 },
    { id: 4, name: "Liu", department: "Finance", salary: 12000 },
    { id: 5, name: "Chen", department: "HR", salary: 12000 }
  ];

  console.log("原始员工数据:");
  employees.forEach(e => console.log(`${e.id}. ${e.name}, ${e.department}, ¥${e.salary}`));

  // 多级排序 - 先按部门，再按薪资（从高到低）
  // 使用稳定排序，先排序次要条件，再排序主要条件

  // 1. 按薪资排序（次要条件）
  employees.sort((a, b) => b.salary - a.salary);

  // 2. 按部门排序（主要条件）
  employees.sort((a, b) => a.department.localeCompare(b.department));

  console.log("\n按部门和薪资排序后:");
  employees.forEach(e => console.log(`${e.id}. ${e.name}, ${e.department}, ¥${e.salary}`));
  // 预期输出（部门按字母顺序，同部门内按薪资降序）:
  // 4. Liu, Finance, ¥12000
  // 5. Chen, HR, ¥10000
  // 1. Zhang, HR, ¥10000
  // 2. Wang, IT, ¥15000
  // 3. Li, IT, ¥12000

  // 如果使用不稳定排序，同薪资的员工可能顺序混乱
}
```

2. **前端表格排序**

在表格UI组件中实现多列排序时，稳定排序能提供更直观的体验：

```javascript
/**
 * @description 表格排序示例组件
 */
class SortableTable {
  constructor(data) {
    this.originalData = data;
    this.displayData = [...data];
    this.sortCriteria = []; // 保存排序列和方向
  }

  /**
   * 添加排序条件（可多级排序）
   * @param {string} column - 要排序的列名
   * @param {string} direction - 排序方向（'asc' 或 'desc'）
   * @param {boolean} resetPrevious - 是否重置之前的排序条件
   */
  sort(column, direction = 'asc', resetPrevious = false) {
    // 重置排序条件
    if (resetPrevious) {
      this.sortCriteria = [];
    }

    // 添加新的排序条件
    this.sortCriteria.push({ column, direction });

    // 重置数据
    this.displayData = [...this.originalData];

    // 应用排序条件（从后向前应用）
    for (let i = this.sortCriteria.length - 1; i >= 0; i--) {
      const { column, direction } = this.sortCriteria[i];

      this.displayData.sort((a, b) => {
        // 字符串比较
        if (typeof a[column] === 'string') {
          return direction === 'asc'
            ? a[column].localeCompare(b[column])
            : b[column].localeCompare(a[column]);
        }

        // 数值比较
        return direction === 'asc'
          ? a[column] - b[column]
          : b[column] - a[column];
      });
    }

    // 返回排序后数据（实际应用中可能是更新视图）
    return this.displayData;
  }

  // 重置排序
  resetSort() {
    this.sortCriteria = [];
    this.displayData = [...this.originalData];
    return this.displayData;
  }
}

// 表格排序示例
function tableSortingExample() {
  const products = [
    { id: 1, name: "Phone A", category: "Electronics", price: 799, stock: 25 },
    { id: 2, name: "Laptop B", category: "Electronics", price: 1299, stock: 10 },
    { id: 3, name: "Book C", category: "Books", price: 15, stock: 100 },
    { id: 4, name: "Tablet D", category: "Electronics", price: 399, stock: 30 },
    { id: 5, name: "Book E", category: "Books", price: 25, stock: 30 }
  ];

  const table = new SortableTable(products);

  // 先按类别排序
  console.log("按类别排序:");
  console.table(table.sort('category', 'asc', true));

  // 再按价格排序
  console.log("按类别和价格排序:");
  console.table(table.sort('price', 'desc'));

  // 最后按库存排序
  console.log("按类别、价格和库存排序:");
  console.table(table.sort('stock', 'desc'));

  // 预期结果：产品先按类别分组，同类别内按价格降序，同价格按库存降序
}
```

3. **电商产品列表排序**

在电商平台中，用户可能希望产品先按类别分组，再按不同条件排序：

```javascript
/**
 * @description 电商产品列表排序示例
 */
function eCommerceProductSorting() {
  const products = [
    { id: 101, name: "Gaming Laptop", category: "Electronics", price: 1299, rating: 4.5, date: "2023-01-15" },
    { id: 102, name: "Smartphone", category: "Electronics", price: 899, rating: 4.2, date: "2023-02-20" },
    { id: 103, name: "Novel", category: "Books", price: 15, rating: 4.7, date: "2023-01-10" },
    { id: 104, name: "Textbook", category: "Books", price: 50, rating: 3.8, date: "2023-03-05" },
    { id: 105, name: "Bluetooth Speaker", category: "Electronics", price: 89, rating: 4.5, date: "2023-02-15" },
    { id: 106, name: "Cookbook", category: "Books", price: 25, rating: 4.2, date: "2023-01-25" }
  ];

  // 电商界面可能有以下排序选项：
  console.log("所有产品:");
  console.table(products);

  // 1. 按类别分组，然后按评分排序
  function sortByCategoryAndRating(products) {
    return [...products]
      // 先按评分排序（次要条件）
      .sort((a, b) => b.rating - a.rating)
      // 再按类别排序（主要条件）
      .sort((a, b) => a.category.localeCompare(b.category));
  }

  console.log("\n按类别和评分排序:");
  console.table(sortByCategoryAndRating(products));

  // 2. 按类别分组，然后按价格从低到高
  function sortByCategoryAndPrice(products) {
    return [...products]
      .sort((a, b) => a.price - b.price)
      .sort((a, b) => a.category.localeCompare(b.category));
  }

  console.log("\n按类别和价格排序:");
  console.table(sortByCategoryAndPrice(products));

  // 3. 按类别分组，然后按上架时间（最新优先）
  function sortByCategoryAndDate(products) {
    return [...products]
      .sort((a, b) => new Date(b.date) - new Date(a.date))
      .sort((a, b) => a.category.localeCompare(b.category));
  }

  console.log("\n按类别和上架时间排序:");
  console.table(sortByCategoryAndDate(products));
}
```

4. **实现动画效果时保持视觉连续性**

当UI元素需要根据不同属性重新排序时，保持相同元素的原有顺序可以提供更平滑的视觉体验：

```javascript
/**
 * @description 使用稳定排序实现平滑动画过渡
 */
function animatedSortingExample() {
  // 在实际React/Vue应用中的伪代码

  // 假设有一个数据列表和排序状态
  const [items, setItems] = useState([
    { id: 1, name: 'Item A', views: 150, likes: 30 },
    { id: 2, name: 'Item B', views: 200, likes: 30 },
    { id: 3, name: 'Item C', views: 100, likes: 40 },
    // ... 更多项目
  ]);

  // 排序方法
  function sortItems(criteria) {
    // 使用稳定排序
    const sorted = [...items].sort((a, b) => {
      if (a[criteria] === b[criteria]) {
        // 相等情况下，保持原有顺序
        return 0;
      }
      return a[criteria] > b[criteria] ? 1 : -1;
    });

    setItems(sorted);
  }

  // 在组件中渲染
  return (
    <div>
      <div className="sort-buttons">
        <button onClick={() => sortItems('name')}>按名称排序</button>
        <button onClick={() => sortItems('views')}>按浏览量排序</button>
        <button onClick={() => sortItems('likes')}>按点赞数排序</button>
      </div>

      <div className="items-list">
        {items.map(item => (
          <div
            key={item.id}
            className="item"
            style={{
              // 使用CSS动画实现平滑过渡
              transition: 'all 0.5s ease'
            }}
          >
            {item.name} - 浏览: {item.views}, 点赞: {item.likes}
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### 稳定排序的实现思路

要实现一个稳定的排序算法，关键在于确保排序过程中相等元素不会交换位置。以下是一些实现稳定排序的思路：

```javascript
/**
 * @description 稳定的归并排序实现
 */
function stableMergeSort(arr, compareFn) {
  if (arr.length <= 1) return arr;

  const comparator = compareFn || ((a, b) => a - b);
  const mid = Math.floor(arr.length / 2);
  const left = stableMergeSort(arr.slice(0, mid), comparator);
  const right = stableMergeSort(arr.slice(mid), comparator);

  return merge(left, right, comparator);
}

function merge(left, right, comparator) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 关键点：只有在右侧元素严格小于左侧元素时才选择右侧元素
  // 相等情况下优先选择左侧元素，这保证了稳定性
  while (leftIndex < left.length && rightIndex < right.length) {
    if (comparator(right[rightIndex], left[leftIndex]) < 0) {
      result.push(right[rightIndex]);
      rightIndex++;
    } else {
      // 左侧元素小于等于右侧元素时，选择左侧元素
      result.push(left[leftIndex]);
      leftIndex++;
    }
  }

  return result.concat(
    left.slice(leftIndex),
    right.slice(rightIndex)
  );
}
```

#### 在前端开发中的最佳实践

1. **表格组件实现**：
   - 使用稳定排序实现多列排序功能
   - 在排序状态中记录所有排序条件，从后向前应用

2. **多条件排序顺序**：
   - 始终从次要条件开始排序，最后排序主要条件
   - 例如，先排序价格，再排序类别，确保类别内元素按价格有序

3. **动画考虑**：
   - 在需要动画过渡的UI元素排序中，稳定排序提供更好的视觉体验

4. **浏览器兼容性**：
   - 虽然ES2019规范要求`Array.prototype.sort()`是稳定的，但在旧浏览器中可能不是
   - 如需支持旧浏览器，可以考虑自行实现稳定排序算法

5. **性能权衡**：
   - 稳定排序算法（如归并排序）可能比不稳定算法（如快速排序）慢
   - 在处理大量数据时，要权衡稳定性与性能需求
   - 对于小到中等规模数据，稳定性通常比性能更重要

// ... existing code ...