# 树与二叉树

## 基本概念

### 树的定义

树是一种非线性的数据结构，由节点和边组成，没有环路。树具有以下特点：

- 每个节点有零个或多个子节点
- 除了根节点外，每个节点有且只有一个父节点
- 没有环路（即不存在从某个节点出发，经过若干个节点后又回到该节点的路径）
- 任意两个节点之间有且仅有一条路径相连

### 树的基本术语

- **节点（Node）**：树中的基本单位，包含数据和指向子节点的引用
- **根节点（Root）**：树的顶部节点，没有父节点
- **父节点（Parent）**：直接连接到子节点的节点
- **子节点（Child）**：直接连接到父节点的节点
- **叶节点（Leaf）**：没有子节点的节点
- **兄弟节点（Sibling）**：共享同一个父节点的节点
- **深度（Depth）**：从根节点到该节点的边数
- **高度（Height）**：从该节点到最远叶节点的边数
- **层级（Level）**：节点的深度加1
- **度（Degree）**：节点的子节点数量
- **树的度**：树中所有节点的度的最大值
- **森林（Forest）**：多棵互不相交的树的集合

### 二叉树

二叉树是一种特殊的树，每个节点最多有两个子节点，通常称为左子节点和右子节点。

#### 二叉树的类型

1. **满二叉树**：除了叶节点外，每个节点都有两个子节点，所有叶节点都在同一层
2. **完全二叉树**：除了最后一层外，其他层的节点数都达到最大，且最后一层的节点都靠左排列
3. **平衡二叉树**：任意节点的左右子树高度差不超过1
4. **二叉搜索树（BST）**：左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于根节点的值
5. **堆（Heap）**：一种特殊的完全二叉树，分为最大堆和最小堆
   - 最大堆：父节点的值总是大于或等于子节点的值
   - 最小堆：父节点的值总是小于或等于子节点的值

## JavaScript实现

### 二叉树节点

```javascript
/**
 * @description 二叉树节点类
 * @class TreeNode
 */
class TreeNode {
  /**
   * @description 创建一个二叉树节点
   * @param {any} val - 节点存储的值
   */
  constructor(val) {
    this.val = val;      // 节点值
    this.left = null;    // 左子节点引用
    this.right = null;   // 右子节点引用
  }
}

// 创建一个简单的二叉树
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

console.log(root);
/* 输出:
TreeNode {
  val: 1,
  left: TreeNode {
    val: 2,
    left: TreeNode { val: 4, left: null, right: null },
    right: TreeNode { val: 5, left: null, right: null }
  },
  right: TreeNode { val: 3, left: null, right: null }
}
*/

// 可视化表示:
//      1
//     / \
//    2   3
//   / \
//  4   5
```

### 二叉搜索树

左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于根节点的值

```javascript
/**
 * @description 二叉搜索树实现
 * @class BinarySearchTree
 */
class BinarySearchTree {
  constructor() {
    this.root = null;  // 根节点
  }

  /**
   * @description 插入新节点到二叉搜索树
   * @param {any} val - 要插入的值
   * @return {BinarySearchTree|undefined} 返回树本身或undefined（如果值已存在）
   */
  insert(val) {
    const newNode = new TreeNode(val);

    // 如果树为空，新节点就是根节点
    if (!this.root) {
      this.root = newNode;
      return this;
    }

    let current = this.root;

    while (true) {
      // 值已存在，返回undefined
      if (val === current.val) return undefined;

      // 值小于当前节点，向左走
      if (val < current.val) {
        if (!current.left) {
          current.left = newNode;
          return this;
        }
        current = current.left;
      }
      // 值大于当前节点，向右走
      else {
        if (!current.right) {
          current.right = newNode;
          return this;
        }
        current = current.right;
      }
    }
  }

  /**
   * @description 查找指定值的节点
   * @param {any} val - 要查找的值
   * @return {TreeNode|false} 返回找到的节点或false
   */
  find(val) {
    if (!this.root) return false;

    let current = this.root;
    let found = false;

    while (current && !found) {
      if (val < current.val) {
        current = current.left;
      } else if (val > current.val) {
        current = current.right;
      } else {
        found = true;
      }
    }

    if (!found) return false;
    return current;
  }

  /**
   * @description 检查值是否存在于树中
   * @param {any} val - 要检查的值
   * @return {boolean} 值是否存在
   */
  contains(val) {
    if (!this.root) return false;

    let current = this.root;

    while (current) {
      if (val < current.val) {
        current = current.left;
      } else if (val > current.val) {
        current = current.right;
      } else {
        return true;
      }
    }

    return false;
  }

  /**
   * @description 从树中删除指定值的节点
   * @param {any} val - 要删除的值
   * @return {BinarySearchTree} 返回树本身
   */
  remove(val) {
    this.root = this._removeNode(this.root, val);
    return this;
  }

  /**
   * @private
   * @description 辅助方法：递归删除节点
   * @param {TreeNode} node - 当前节点
   * @param {any} val - 要删除的值
   * @return {TreeNode} 返回更新后的节点
   */
  _removeNode(node, val) {
    // 基本情况：空树
    if (node === null) return null;

    // 查找要删除的节点
    if (val < node.val) {
      node.left = this._removeNode(node.left, val);
      return node;
    } else if (val > node.val) {
      node.right = this._removeNode(node.right, val);
      return node;
    }
    // 找到要删除的节点
    else {
      // 情况1：叶节点（没有子节点）
      if (node.left === null && node.right === null) {
        return null;
      }

      // 情况2：只有一个子节点
      if (node.left === null) {
        return node.right;
      } else if (node.right === null) {
        return node.left;
      }

      // 情况3：有两个子节点
      // 找到右子树中的最小值作为后继
      let successor = this._findMinNode(node.right);
      node.val = successor.val;

      // 删除后继节点
      node.right = this._removeNode(node.right, successor.val);
      return node;
    }
  }

  /**
   * @private
   * @description 查找子树中的最小值节点
   * @param {TreeNode} node - 子树的根节点
   * @return {TreeNode} 包含最小值的节点
   */
  _findMinNode(node) {
    while (node && node.left !== null) {
      node = node.left;
    }
    return node;
  }
}

// 使用示例
const bst = new BinarySearchTree();
bst.insert(10);
bst.insert(5);
bst.insert(15);
bst.insert(3);
bst.insert(7);
bst.insert(13);
bst.insert(17);

console.log(bst.contains(7));  // true
console.log(bst.contains(11)); // false

const node = bst.find(15);
console.log(node);
/* 输出:
TreeNode {
  val: 15,
  left: TreeNode { val: 13, left: null, right: null },
  right: TreeNode { val: 17, left: null, right: null }
}
*/

bst.remove(15);
console.log(bst.contains(15)); // false

// 可视化表示（初始状态）:
//        10
//       /  \
//      5    15
//     / \   / \
//    3   7 13  17

// 删除15后:
//        10
//       /  \
//      5    17
//     / \   /
//    3   7 13
```

## 树的遍历

### 深度优先遍历（DFS）

#### 1. 前序遍历（根-左-右）

```javascript
/**
 * @description 二叉树的前序遍历（根-左-右）
 * @param {TreeNode} root - 二叉树根节点
 * @return {any[]} 遍历结果数组
 */
function preOrderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    // 1. 访问根节点
    result.push(node.val);
    // 2. 遍历左子树
    traverse(node.left);
    // 3. 遍历右子树
    traverse(node.right);
  }

  traverse(root);
  return result;
}

// 创建一个测试二叉树
//      1
//     / \
//    2   3
//   / \
//  4   5
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

// 前序遍历
const preOrder = preOrderTraversal(root);
console.log("前序遍历:", preOrder); // [1, 2, 4, 5, 3]

// 执行过程分析:
// 1. 访问根节点1，result = [1]
// 2. 递归遍历左子树
//    a. 访问节点2，result = [1, 2]
//    b. 递归遍历节点2的左子树
//       i. 访问节点4，result = [1, 2, 4]
//       ii. 节点4没有子节点，返回
//    c. 递归遍历节点2的右子树
//       i. 访问节点5，result = [1, 2, 4, 5]
//       ii. 节点5没有子节点，返回
// 3. 递归遍历右子树
//    a. 访问节点3，result = [1, 2, 4, 5, 3]
//    b. 节点3没有子节点，返回

// 非递归实现
function preOrderTraversalIterative(root) {
  const result = [];
  if (!root) return result;

  const stack = [root];

  while (stack.length > 0) {
    const node = stack.pop();
    result.push(node.val);

    // 注意：先右后左压栈，这样出栈时才是先左后右
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }

  return result;
}

console.log("前序遍历(非递归):", preOrderTraversalIterative(root)); // [1, 2, 4, 5, 3]
```

#### 2. 中序遍历（左-根-右）

```javascript
/**
 * @description 二叉树的中序遍历（左-根-右）
 * @param {TreeNode} root - 二叉树根节点
 * @return {any[]} 遍历结果数组
 */
function inOrderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    // 1. 遍历左子树
    traverse(node.left);
    // 2. 访问根节点
    result.push(node.val);
    // 3. 遍历右子树
    traverse(node.right);
  }

  traverse(root);
  return result;
}

// 使用前面创建的测试二叉树
//      1
//     / \
//    2   3
//   / \
//  4   5

// 中序遍历
const inOrder = inOrderTraversal(root);
console.log("中序遍历:", inOrder); // [4, 2, 5, 1, 3]

// 执行过程分析:
// 1. 递归遍历左子树
//    a. 递归遍历节点2的左子树
//       i. 递归遍历节点4的左子树（无）
//       ii. 访问节点4，result = [4]
//       iii. 递归遍历节点4的右子树（无）
//    b. 访问节点2，result = [4, 2]
//    c. 递归遍历节点2的右子树
//       i. 递归遍历节点5的左子树（无）
//       ii. 访问节点5，result = [4, 2, 5]
//       iii. 递归遍历节点5的右子树（无）
// 2. 访问根节点1，result = [4, 2, 5, 1]
// 3. 递归遍历右子树
//    a. 递归遍历节点3的左子树（无）
//    b. 访问节点3，result = [4, 2, 5, 1, 3]
//    c. 递归遍历节点3的右子树（无）

// 非递归实现
function inOrderTraversalIterative(root) {
  const result = [];
  if (!root) return result;

  const stack = [];
  let current = root;

  while (current || stack.length > 0) {
    // 一直遍历到最左叶节点
    while (current) {
      stack.push(current);
      current = current.left;
    }

    // 弹出栈顶元素
    current = stack.pop();
    result.push(current.val);

    // 处理右子树
    current = current.right;
  }

  return result;
}

console.log("中序遍历(非递归):", inOrderTraversalIterative(root)); // [4, 2, 5, 1, 3]
```

#### 3. 后序遍历（左-右-根）

```javascript
/**
 * @description 二叉树的后序遍历（左-右-根）
 * @param {TreeNode} root - 二叉树根节点
 * @return {any[]} 遍历结果数组
 */
function postOrderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    // 1. 遍历左子树
    traverse(node.left);
    // 2. 遍历右子树
    traverse(node.right);
    // 3. 访问根节点
    result.push(node.val);
  }

  traverse(root);
  return result;
}

// 使用前面创建的测试二叉树
//      1
//     / \
//    2   3
//   / \
//  4   5

// 后序遍历
const postOrder = postOrderTraversal(root);
console.log("后序遍历:", postOrder); // [4, 5, 2, 3, 1]

// 执行过程分析:
// 1. 递归遍历左子树
//    a. 递归遍历节点2的左子树
//       i. 递归遍历节点4的左子树（无）
//       ii. 递归遍历节点4的右子树（无）
//       iii. 访问节点4，result = [4]
//    b. 递归遍历节点2的右子树
//       i. 递归遍历节点5的左子树（无）
//       ii. 递归遍历节点5的右子树（无）
//       iii. 访问节点5，result = [4, 5]
//    c. 访问节点2，result = [4, 5, 2]
// 2. 递归遍历右子树
//    a. 递归遍历节点3的左子树（无）
//    b. 递归遍历节点3的右子树（无）
//    c. 访问节点3，result = [4, 5, 2, 3]
// 3. 访问根节点1，result = [4, 5, 2, 3, 1]

// 非递归实现
function postOrderTraversalIterative(root) {
  const result = [];
  if (!root) return result;

  const stack1 = [root];
  const stack2 = [];

  // 第一次遍历：根-右-左 存入stack2
  while (stack1.length > 0) {
    const node = stack1.pop();
    stack2.push(node);

    if (node.left) stack1.push(node.left);
    if (node.right) stack1.push(node.right);
  }

  // 从stack2弹出: 左-右-根
  while (stack2.length > 0) {
    result.push(stack2.pop().val);
  }

  return result;
}

console.log("后序遍历(非递归):", postOrderTraversalIterative(root)); // [4, 5, 2, 3, 1]
```

### 广度优先遍历（BFS）

#### 层序遍历

```javascript
/**
 * @description 二叉树的层序遍历（广度优先）
 * @param {TreeNode} root - 二叉树根节点
 * @return {any[][]} 按层组织的遍历结果数组
 */
function levelOrderTraversal(root) {
  if (!root) return [];

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);

      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }

    result.push(currentLevel);
  }

  return result;
}

// 使用前面创建的测试二叉树
//      1
//     / \
//    2   3
//   / \
//  4   5

// 层序遍历
const levelOrder = levelOrderTraversal(root);
console.log("层序遍历:", levelOrder); // [[1], [2, 3], [4, 5]]

// 执行过程分析:
// 1. 初始队列: [1]
// 2. 处理第1层:
//    a. 当前层级大小: 1
//    b. 处理节点1，添加到当前层: [1]
//    c. 将节点1的子节点加入队列: [2, 3]
//    d. 添加当前层到结果: [[1]]
// 3. 处理第2层:
//    a. 当前层级大小: 2
//    b. 处理节点2，添加到当前层: [2]
//    c. 将节点2的子节点加入队列: [3, 4, 5]
//    d. 处理节点3，添加到当前层: [2, 3]
//    e. 节点3没有子节点
//    f. 添加当前层到结果: [[1], [2, 3]]
// 4. 处理第3层:
//    a. 当前层级大小: 2
//    b. 处理节点4，添加到当前层: [4]
//    c. 节点4没有子节点
//    d. 处理节点5，添加到当前层: [4, 5]
//    e. 节点5没有子节点
//    f. 添加当前层到结果: [[1], [2, 3], [4, 5]]
// 5. 队列为空，遍历结束

// 一维数组版本层序遍历
function levelOrderTraversalFlat(root) {
  if (!root) return [];

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const node = queue.shift();
    result.push(node.val);

    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }

  return result;
}

console.log("层序遍历(一维):", levelOrderTraversalFlat(root)); // [1, 2, 3, 4, 5]
```

## 常见树操作

### 1. 计算树的高度

```javascript
/**
 * @description 计算二叉树的高度（深度）
 * @param {TreeNode} root - 二叉树根节点
 * @return {number} 树的高度
 */
function treeHeight(root) {
  if (!root) return 0;

  const leftHeight = treeHeight(root.left);
  const rightHeight = treeHeight(root.right);

  return Math.max(leftHeight, rightHeight) + 1;
}

// 使用前面创建的测试二叉树
//      1
//     / \
//    2   3
//   / \
//  4   5

const height = treeHeight(root);
console.log("树的高度:", height); // 3

// 执行过程分析:
// 计算节点1的高度:
//   计算节点2的高度:
//     计算节点4的高度:
//       节点4无子节点，高度为1
//     计算节点5的高度:
//       节点5无子节点，高度为1
//     节点2的高度 = max(1, 1) + 1 = 2
//   计算节点3的高度:
//     节点3无子节点，高度为1
//   节点1的高度 = max(2, 1) + 1 = 3

// 迭代方式计算树高度（使用层序遍历）
function treeHeightIterative(root) {
  if (!root) return 0;

  let height = 0;
  const queue = [root];

  while (queue.length > 0) {
    height++; // 每处理一层，高度加1
    const levelSize = queue.length;

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();

      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
  }

  return height;
}

console.log("树的高度(迭代):", treeHeightIterative(root)); // 3
```

### 2. 判断是否为平衡二叉树

```javascript
/**
 * @description 判断一棵二叉树是否为平衡二叉树
 * @param {TreeNode} root - 二叉树根节点
 * @return {boolean} 是否为平衡二叉树
 */
function isBalanced(root) {
  if (!root) return true;

  /**
   * 计算节点高度，同时判断是否平衡
   * @param {TreeNode} node - 当前节点
   * @return {number} 高度（如果不平衡则返回-1）
   */
  function height(node) {
    if (!node) return 0;

    // 递归计算左子树高度
    const leftHeight = height(node.left);
    // 如果左子树不平衡，直接返回-1
    if (leftHeight === -1) return -1;

    // 递归计算右子树高度
    const rightHeight = height(node.right);
    // 如果右子树不平衡，直接返回-1
    if (rightHeight === -1) return -1;

    // 检查当前节点是否满足平衡条件
    if (Math.abs(leftHeight - rightHeight) > 1) return -1;

    // 返回当前节点的高度
    return Math.max(leftHeight, rightHeight) + 1;
  }

  // 高度不为-1表示树是平衡的
  return height(root) !== -1;
}

// 创建一个平衡二叉树
//      1
//     / \
//    2   3
//   / \
//  4   5
const balancedTree = new TreeNode(1);
balancedTree.left = new TreeNode(2);
balancedTree.right = new TreeNode(3);
balancedTree.left.left = new TreeNode(4);
balancedTree.left.right = new TreeNode(5);

console.log("平衡二叉树检测:", isBalanced(balancedTree)); // true

// 创建一个不平衡的二叉树
//      1
//     /
//    2
//   /
//  3
//  /
// 4
const unbalancedTree = new TreeNode(1);
unbalancedTree.left = new TreeNode(2);
unbalancedTree.left.left = new TreeNode(3);
unbalancedTree.left.left.left = new TreeNode(4);

console.log("不平衡二叉树检测:", isBalanced(unbalancedTree)); // false

// 执行过程分析（以平衡树为例）:
// 计算节点1的高度:
//   计算节点2的高度:
//     计算节点4的高度: 返回1
//     计算节点5的高度: 返回1
//     节点2的左右子树高度差为0，返回高度2
//   计算节点3的高度: 返回1
//   节点1的左右子树高度差为1，返回高度3
// 最终结果: 高度为3，不为-1，所以是平衡树

// 执行过程分析（以不平衡树为例）:
// 计算节点1的高度:
//   计算节点2的高度:
//     计算节点3的高度:
//       计算节点4的高度: 返回1
//       节点3右子树为空，高度为0
//       节点3的左右子树高度差为1，返回高度2
//     节点2右子树为空，高度为0
//     节点2的左右子树高度差为2 > 1，返回-1
//   节点1的左子树不平衡，返回-1
// 最终结果: 高度为-1，所以不是平衡树
```

### 3. 判断是否为二叉搜索树

```javascript
/**
 * @description 判断一棵二叉树是否为有效的二叉搜索树
 * @param {TreeNode} root - 二叉树根节点
 * @return {boolean} 是否为有效的二叉搜索树
 */
function isValidBST(root) {
  /**
   * 验证节点值是否在指定范围内
   * @param {TreeNode} node - 当前节点
   * @param {number|null} min - 下界（最小值）
   * @param {number|null} max - 上界（最大值）
   * @return {boolean} 节点及其子树是否符合BST性质
   */
  function validate(node, min, max) {
    // 空节点默认为BST
    if (!node) return true;

    // 检查当前节点值是否在有效范围内
    if ((min !== null && node.val <= min) || (max !== null && node.val >= max)) {
      return false;
    }

    // 递归验证左子树（所有节点值必须 < node.val）
    // 递归验证右子树（所有节点值必须 > node.val）
    return validate(node.left, min, node.val) && validate(node.right, node.val, max);
  }

  return validate(root, null, null);
}

// 创建一个有效的二叉搜索树
//      8
//     / \
//    3   10
//   / \    \
//  1   6    14
//     / \
//    4   7
const validBST = new TreeNode(8);
validBST.left = new TreeNode(3);
validBST.right = new TreeNode(10);
validBST.left.left = new TreeNode(1);
validBST.left.right = new TreeNode(6);
validBST.left.right.left = new TreeNode(4);
validBST.left.right.right = new TreeNode(7);
validBST.right.right = new TreeNode(14);

console.log("有效BST检测:", isValidBST(validBST)); // true

// 创建一个无效的二叉搜索树
//      5
//     / \
//    3   7
//   / \
//  1   6  // 6 > 5，违反BST规则
const invalidBST = new TreeNode(5);
invalidBST.left = new TreeNode(3);
invalidBST.right = new TreeNode(7);
invalidBST.left.left = new TreeNode(1);
invalidBST.left.right = new TreeNode(6); // 这里6 > 5，违反了BST规则

console.log("无效BST检测:", isValidBST(invalidBST)); // false

// 执行过程分析（有效BST检测）:
// 验证根节点8:
//   验证左子树3 (范围: -∞ < x < 8):
//     验证节点1 (范围: -∞ < x < 3): 满足
//     验证节点6 (范围: 3 < x < 8):
//       验证节点4 (范围: 3 < x < 6): 满足
//       验证节点7 (范围: 6 < x < 8): 满足
//   验证右子树10 (范围: 8 < x < ∞):
//     验证节点14 (范围: 10 < x < ∞): 满足
// 所有节点验证通过，返回true

// 执行过程分析（无效BST检测）:
// 验证根节点5:
//   验证左子树3 (范围: -∞ < x < 5):
//     验证节点1 (范围: -∞ < x < 3): 满足
//     验证节点6 (范围: 3 < x < 5): 不满足，因为6 > 5
// 验证失败，返回false

// 使用中序遍历检验BST的另一种方法
function isValidBSTInorder(root) {
  let prev = null;
  let valid = true;

  // 中序遍历一个BST会产生升序序列
  function inorder(node) {
    if (!node || !valid) return;

    inorder(node.left);

    // 如果当前值小于等于前一个值，则不是BST
    if (prev !== null && node.val <= prev) {
      valid = false;
      return;
    }

    prev = node.val;
    inorder(node.right);
  }

  inorder(root);
  return valid;
}

console.log("有效BST检测(中序):", isValidBSTInorder(validBST)); // true
console.log("无效BST检测(中序):", isValidBSTInorder(invalidBST)); // false
```

### 4. 二叉树的最近公共祖先

```javascript
/**
 * @description 查找二叉树中两个节点的最近公共祖先
 * @param {TreeNode} root - 二叉树根节点
 * @param {TreeNode} p - 第一个节点
 * @param {TreeNode} q - 第二个节点
 * @return {TreeNode} 最近公共祖先节点
 */
function lowestCommonAncestor(root, p, q) {
  // 基本情况：如果root为空或者root就是p或q，则返回root
  if (!root || root === p || root === q) return root;

  // 在左子树中查找p或q
  const left = lowestCommonAncestor(root.left, p, q);
  // 在右子树中查找p或q
  const right = lowestCommonAncestor(root.right, p, q);

  // 如果左子树和右子树都找到了，说明p和q分别在左右子树中，root是LCA
  if (left && right) return root;

  // 如果只有左子树找到了，返回左子树的结果
  // 如果只有右子树找到了，返回右子树的结果
  // 如果都没找到，返回null
  return left ? left : right;
}

// 创建一个示例二叉树
//       3
//      / \
//     5   1
//    / \ / \
//   6  2 0  8
//     / \
//    7   4
const tree = new TreeNode(3);
tree.left = new TreeNode(5);
tree.right = new TreeNode(1);
tree.left.left = new TreeNode(6);
tree.left.right = new TreeNode(2);
tree.right.left = new TreeNode(0);
tree.right.right = new TreeNode(8);
tree.left.right.left = new TreeNode(7);
tree.left.right.right = new TreeNode(4);

// 查找节点5和节点1的最近公共祖先
const p = tree.left;        // 节点5
const q = tree.right;       // 节点1
const lca1 = lowestCommonAncestor(tree, p, q);
console.log("节点5和节点1的LCA值:", lca1.val); // 3

// 查找节点5和节点4的最近公共祖先
const r = tree.left.right.right; // 节点4
const lca2 = lowestCommonAncestor(tree, p, r);
console.log("节点5和节点4的LCA值:", lca2.val); // 5

// 执行过程分析（以节点5和节点1为例）:
// 调用LCA(3, 5, 1):
//   递归到左子树: LCA(5, 5, 1)
//     节点5等于p，直接返回5
//   递归到右子树: LCA(1, 5, 1)
//     节点1等于q，直接返回1
//   左子树返回5，右子树返回1，都非空，所以节点3是LCA
// 最终结果: 节点3

// 执行过程分析（以节点5和节点4为例）:
// 调用LCA(3, 5, 4):
//   递归到左子树: LCA(5, 5, 4)
//     节点5等于p，直接返回5
//   递归到右子树: LCA(1, 5, 4)
//     递归到左子树: LCA(0, 5, 4) 返回null
//     递归到右子树: LCA(8, 5, 4) 返回null
//     左右子树都返回null，所以返回null
//   左子树返回5，右子树返回null，所以节点5是LCA
// 最终结果: 节点5

// 迭代方式实现LCA
function lowestCommonAncestorIterative(root, p, q) {
  // 存储从根到p和q的路径
  const pathP = [];
  const pathQ = [];

  // 查找从根到指定节点的路径
  function findPath(node, target, path) {
    if (!node) return false;

    path.push(node);

    if (node === target) return true;

    if (findPath(node.left, target, path) || findPath(node.right, target, path)) {
      return true;
    }

    path.pop();
    return false;
  }

  // 如果找不到路径，说明节点不在树中
  if (!findPath(root, p, pathP) || !findPath(root, q, pathQ)) {
    return null;
  }

  // 查找第一个不同的节点的前一个节点
  let i = 0;
  while (i < pathP.length && i < pathQ.length && pathP[i] === pathQ[i]) {
    i++;
  }

  // 返回公共路径的最后一个节点
  return pathP[i - 1];
}

console.log("节点5和节点1的LCA值(迭代):", lowestCommonAncestorIterative(tree, p, q).val); // 3
console.log("节点5和节点4的LCA值(迭代):", lowestCommonAncestorIterative(tree, p, r).val); // 5
```

### 5. 二叉树的序列化与反序列化

```javascript
/**
 * @description 将二叉树序列化为字符串
 * @param {TreeNode} root - 二叉树根节点
 * @return {string} 序列化后的字符串
 */
function serialize(root) {
  // 处理空树情况
  if (!root) return 'null';

  // 采用前序遍历（根-左-右）序列化树
  const left = serialize(root.left);
  const right = serialize(root.right);

  // 使用逗号作为分隔符
  return `${root.val},${left},${right}`;
}

/**
 * @description 将字符串反序列化为二叉树
 * @param {string} data - 序列化后的字符串
 * @return {TreeNode} 反序列化后的二叉树根节点
 */
function deserialize(data) {
  // 将字符串分割为节点值数组
  const list = data.split(',');

  /**
   * 递归构建二叉树
   * @return {TreeNode} 当前子树的根节点
   */
  function buildTree() {
    // 获取并移除数组的第一个元素
    const val = list.shift();

    // 如果值为'null'，表示空节点
    if (val === 'null') return null;

    // 创建新节点
    const node = new TreeNode(parseInt(val));

    // 递归构建左子树
    node.left = buildTree();
    // 递归构建右子树
    node.right = buildTree();

    return node;
  }

  return buildTree();
}

// 创建一个示例二叉树
//      1
//     / \
//    2   3
//       / \
//      4   5
const sampleTree = new TreeNode(1);
sampleTree.left = new TreeNode(2);
sampleTree.right = new TreeNode(3);
sampleTree.right.left = new TreeNode(4);
sampleTree.right.right = new TreeNode(5);

// 序列化树
const serialized = serialize(sampleTree);
console.log("序列化结果:", serialized);
// 输出: "1,2,null,null,3,4,null,null,5,null,null"

// 反序列化回二叉树
const deserialized = deserialize(serialized);
console.log("反序列化后的树中序遍历:", inOrderTraversal(deserialized));
// 输出: [2, 1, 4, 3, 5]，验证树结构恢复正确

// 执行过程分析（序列化）:
// 序列化节点1:
//   序列化左子树(节点2):
//     序列化节点2的左子树: "null"
//     序列化节点2的右子树: "null"
//     节点2的序列化结果: "2,null,null"
//   序列化右子树(节点3):
//     序列化节点3的左子树(节点4):
//       序列化节点4的左子树: "null"
//       序列化节点4的右子树: "null"
//       节点4的序列化结果: "4,null,null"
//     序列化节点3的右子树(节点5):
//       序列化节点5的左子树: "null"
//       序列化节点5的右子树: "null"
//       节点5的序列化结果: "5,null,null"
//     节点3的序列化结果: "3,4,null,null,5,null,null"
//   节点1的序列化结果: "1,2,null,null,3,4,null,null,5,null,null"

// 执行过程分析（反序列化）:
// 初始list: ["1", "2", "null", "null", "3", "4", "null", "null", "5", "null", "null"]
// 构建树:
//   取值"1"，创建节点1
//   构建左子树:
//     取值"2"，创建节点2
//     构建节点2的左子树:
//       取值"null"，返回null
//     构建节点2的右子树:
//       取值"null"，返回null
//   构建右子树:
//     取值"3"，创建节点3
//     构建节点3的左子树:
//       取值"4"，创建节点4
//       构建节点4的左子树:
//         取值"null"，返回null
//       构建节点4的右子树:
//         取值"null"，返回null
//     构建节点3的右子树:
//       取值"5"，创建节点5
//       构建节点5的左子树:
//         取值"null"，返回null
//       构建节点5的右子树:
//         取值"null"，返回null
// 最终构建出的树与原始树结构相同

// 级别序列化方法（使用BFS）
function serializeBFS(root) {
  if (!root) return "[]";

  const queue = [root];
  const result = [];

  while (queue.length > 0) {
    const node = queue.shift();

    if (node) {
      result.push(node.val);
      queue.push(node.left || null);
      queue.push(node.right || null);
    } else {
      result.push("null");
    }
  }

  // 移除尾部的null
  while (result[result.length - 1] === "null") {
    result.pop();
  }

  return "[" + result.join(",") + "]";
}

function deserializeBFS(data) {
  if (data === "[]") return null;

  // 去除括号并分割
  const values = data.slice(1, -1).split(",");
  if (!values.length) return null;

  const root = new TreeNode(parseInt(values[0]));
  const queue = [root];
  let i = 1;

  while (queue.length > 0 && i < values.length) {
    const node = queue.shift();

    // 处理左子节点
    if (i < values.length && values[i] !== "null") {
      node.left = new TreeNode(parseInt(values[i]));
      queue.push(node.left);
    }
    i++;

    // 处理右子节点
    if (i < values.length && values[i] !== "null") {
      node.right = new TreeNode(parseInt(values[i]));
      queue.push(node.right);
    }
    i++;
  }

  return root;
}

const bfsSerialize = serializeBFS(sampleTree);
console.log("BFS序列化结果:", bfsSerialize);
// 输出类似: "[1,2,3,null,null,4,5]"

const bfsDeserialize = deserializeBFS(bfsSerialize);
console.log("BFS反序列化后的树中序遍历:", inOrderTraversal(bfsDeserialize));
// 输出: [2, 1, 4, 3, 5]，验证树结构恢复正确
```

## 复杂度分析

### 二叉搜索树操作的时间复杂度


| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 说明                                 |
| ---- | -------------- | -------------- | ------------------------------------ |
| 查找 | O(log n)       | O(n)           | 平衡树为O(log n)，退化为链表时为O(n) |
| 插入 | O(log n)       | O(n)           | 平衡树为O(log n)，退化为链表时为O(n) |
| 删除 | O(log n)       | O(n)           | 平衡树为O(log n)，退化为链表时为O(n) |

### 树遍历的时间复杂度


| 遍历方式 | 时间复杂度 | 空间复杂度 | 说明                              |
| -------- | ---------- | ---------- | --------------------------------- |
| 前序遍历 | O(n)       | O(h)       | h为树的高度，最坏情况下为O(n)     |
| 中序遍历 | O(n)       | O(h)       | h为树的高度，最坏情况下为O(n)     |
| 后序遍历 | O(n)       | O(h)       | h为树的高度，最坏情况下为O(n)     |
| 层序遍历 | O(n)       | O(w)       | w为树的最大宽度，最坏情况下为O(n) |

## 平衡树

### AVL树

AVL树是一种自平衡二叉搜索树，任何节点的两个子树的高度差不超过1。当插入或删除节点导致不平衡时，通过旋转操作恢复平衡。

#### AVL树的特点

1. 每个节点的左右子树高度差不超过1
2. 插入和删除操作可能触发旋转以保持平衡
3. 相比普通BST，AVL树保证了O(log n)的查询时间复杂度
4. 旋转操作包括：左旋、右旋、左右旋和右左旋
5. 每个节点通常会记录一个平衡因子或高度值

### 红黑树

红黑树是一种自平衡二叉搜索树，通过节点的颜色（红色或黑色）来维持平衡。红黑树的特性：

1. 每个节点是红色或黑色
2. 根节点是黑色
3. 所有叶节点（NIL节点）是黑色
4. 如果一个节点是红色，则其子节点必须是黑色
5. 从任一节点到其每个叶子节点的所有路径都包含相同数量的黑色节点

#### 红黑树与AVL树的比较


| 特性     | 红黑树                       | AVL树                           |
| -------- | ---------------------------- | ------------------------------- |
| 平衡条件 | 不严格平衡，黑色节点深度相同 | 严格平衡，左右子树高度差不超过1 |
| 插入性能 | 较好，最多3次旋转            | 较差，可能需要O(log n)次旋转    |
| 删除性能 | 较好，最多3次旋转            | 较差，可能需要O(log n)次旋转    |
| 查找性能 | 较好，O(log n)               | 最优，严格O(log n)              |
| 空间开销 | 每个节点需要1位存储颜色      | 每个节点需要存储平衡因子或高度  |
| 应用场景 | 大量插入删除操作的应用       | 查询频繁的应用                  |

### 在JavaScript中实现简化版红黑树示例

```javascript
/**
 * @description 红黑树节点
 * @class RBNode
 */
class RBNode {
  /**
   * @description 创建红黑树节点
   * @param {any} val - 节点值
   * @param {boolean} isRed - 是否为红色节点，默认为红色
   */
  constructor(val, isRed = true) {
    this.val = val;
    this.left = null;
    this.right = null;
    this.isRed = isRed; // true表示红色，false表示黑色
    this.parent = null;
  }
}

// 注意：完整的红黑树实现非常复杂，这里只展示核心概念和部分API
// 实际应用中建议使用成熟的库
```

## 前端应用场景

1. **DOM操作**：浏览器将HTML解析为DOM树，前端开发中经常需要遍历和操作DOM树
2. **虚拟DOM**：React、Vue等框架使用树结构表示虚拟DOM
3. **状态管理**：Redux等状态管理库使用树结构存储应用状态
4. **文件系统**：文件目录结构本质上是一个树
5. **组件树**：前端框架中的组件嵌套形成组件树
6. **抽象语法树（AST）**：JavaScript解析器将代码解析为AST，用于代码转换、压缩等
7. **路由系统**：前端路由通常使用树结构组织路由配置
8. **树形控件**：如菜单、目录、选择器等UI组件

### 前端常见树结构示例

```javascript
// React组件树示例
const App = () => (
  <div>
    <Header />
    <Main>
      <Sidebar />
      <Content>
        <Article />
        <Comments />
      </Content>
    </Main>
    <Footer />
  </div>
);

// 虚拟DOM树示例
const vdom = {
  type: 'div',
  props: { className: 'container' },
  children: [
    { type: 'h1', props: {}, children: ['标题'] },
    {
      type: 'ul',
      props: { className: 'list' },
      children: [
        { type: 'li', props: {}, children: ['项目1'] },
        { type: 'li', props: {}, children: ['项目2'] }
      ]
    }
  ]
};

// 前端路由配置示例
const routes = [
  {
    path: '/',
    component: Home,
    children: [
      { path: 'profile', component: Profile },
      {
        path: 'settings',
        component: Settings,
        children: [
          { path: 'account', component: Account },
          { path: 'notification', component: Notification }
        ]
      }
    ]
  }
];
```

## 经典算法题

### 1. 路径总和

```javascript
/**
 * @description 判断二叉树中是否存在从根到叶子节点的路径，使得路径上所有节点值之和等于目标和
 * @param {TreeNode} root - 二叉树根节点
 * @param {number} targetSum - 目标和
 * @return {boolean} 是否存在满足条件的路径
 */
function hasPathSum(root, targetSum) {
  // 空节点情况
  if (!root) return false;

  // 叶子节点，检查当前值是否等于目标和
  if (!root.left && !root.right) {
    return root.val === targetSum;
  }

  // 递归检查左右子树，目标和减去当前节点值
  return hasPathSum(root.left, targetSum - root.val) ||
         hasPathSum(root.right, targetSum - root.val);
}

// 创建一个示例二叉树
//       5
//      / \
//     4   8
//    /   / \
//   11  13  4
//  / \      \
// 7   2      1
const pathTree = new TreeNode(5);
pathTree.left = new TreeNode(4);
pathTree.right = new TreeNode(8);
pathTree.left.left = new TreeNode(11);
pathTree.left.left.left = new TreeNode(7);
pathTree.left.left.right = new TreeNode(2);
pathTree.right.left = new TreeNode(13);
pathTree.right.right = new TreeNode(4);
pathTree.right.right.right = new TreeNode(1);

// 检查是否存在和为22的路径 (5 -> 4 -> 11 -> 2 = 22)
console.log("存在路径和为22:", hasPathSum(pathTree, 22)); // true

// 检查是否存在和为10的路径
console.log("存在路径和为10:", hasPathSum(pathTree, 10)); // false

// 执行过程分析（路径和为22）:
// 调用hasPathSum(节点5, 22):
//   递归调用左子树: hasPathSum(节点4, 22-5=17)
//     递归调用左子树: hasPathSum(节点11, 17-4=13)
//       递归调用左子树: hasPathSum(节点7, 13-11=2)
//         节点7是叶子节点，7 !== 2，返回false
//       递归调用右子树: hasPathSum(节点2, 13-11=2)
//         节点2是叶子节点，2 === 2，返回true
//       左子树或右子树返回true，所以返回true
//     左子树返回true，所以返回true
//   左子树返回true，所以整体返回true

// 迭代方式实现
function hasPathSumIterative(root, targetSum) {
  if (!root) return false;

  // 使用栈存储节点和当前路径和
  const stack = [{
    node: root,
    sum: root.val
  }];

  while (stack.length > 0) {
    const { node, sum } = stack.pop();

    // 检查是否是叶子节点且路径和等于目标
    if (!node.left && !node.right && sum === targetSum) {
      return true;
    }

    // 将右子节点加入栈
    if (node.right) {
      stack.push({
        node: node.right,
        sum: sum + node.right.val
      });
    }

    // 将左子节点加入栈
    if (node.left) {
      stack.push({
        node: node.left,
        sum: sum + node.left.val
      });
    }
  }

  return false;
}

console.log("存在路径和为22(迭代):", hasPathSumIterative(pathTree, 22)); // true

// 找出所有满足条件的路径
function pathSum(root, targetSum) {
  const result = [];
  const path = [];

  function dfs(node, remainingSum) {
    if (!node) return;

    // 将当前节点加入路径
    path.push(node.val);

    // 检查是否是叶子节点且路径和等于目标
    if (!node.left && !node.right && remainingSum === node.val) {
      result.push([...path]); // 复制一份当前路径加入结果
    }

    // 递归遍历左右子树
    dfs(node.left, remainingSum - node.val);
    dfs(node.right, remainingSum - node.val);

    // 回溯：移除当前节点
    path.pop();
  }

  dfs(root, targetSum);
  return result;
}

console.log("所有路径和为22的路径:", pathSum(pathTree, 22));
// 输出: [[5, 4, 11, 2]]
```

### 2. 二叉树的直径

```javascript
/**
 * @description 计算二叉树的直径（任意两个节点之间的最长路径长度）
 * @param {TreeNode} root - 二叉树根节点
 * @return {number} 二叉树的直径
 */
function diameterOfBinaryTree(root) {
  // 用于存储最大直径
  let diameter = 0;

  /**
   * 计算节点的深度，同时更新直径
   * @param {TreeNode} node - 当前节点
   * @return {number} 节点的深度
   */
  function depth(node) {
    if (!node) return 0;

    // 递归计算左右子树的深度
    const leftDepth = depth(node.left);
    const rightDepth = depth(node.right);

    // 更新直径（左子树深度 + 右子树深度）
    // 这里的直径是指经过当前节点的最长路径的边数
    diameter = Math.max(diameter, leftDepth + rightDepth);

    // 返回当前节点为根的子树的深度
    return Math.max(leftDepth, rightDepth) + 1;
  }

  depth(root);
  return diameter;
}

// 创建一个示例二叉树
//      1
//     / \
//    2   3
//   / \
//  4   5
const diameterTree = new TreeNode(1);
diameterTree.left = new TreeNode(2);
diameterTree.right = new TreeNode(3);
diameterTree.left.left = new TreeNode(4);
diameterTree.left.right = new TreeNode(5);

console.log("二叉树的直径:", diameterOfBinaryTree(diameterTree)); // 3

// 执行过程分析:
// 调用depth(节点1):
//   递归调用左子树: depth(节点2)
//     递归调用左子树: depth(节点4)
//       节点4无子节点，返回深度1
//     递归调用右子树: depth(节点5)
//       节点5无子节点，返回深度1
//     更新diameter = max(0, 1+1) = 2，节点2的深度为max(1,1)+1 = 2
//   递归调用右子树: depth(节点3)
//     节点3无子节点，返回深度1
//   更新diameter = max(2, 2+1) = 3，节点1的深度为max(2,1)+1 = 3
// 最终结果: 直径为3，表示路径4->2->1->3或5->2->1->3的长度

// 另一种计算直径的方式（计算节点数而非边数）
function diameterOfBinaryTreeNodes(root) {
  let maxDiameter = 0;

  function maxDepth(node) {
    if (!node) return 0;

    const leftDepth = maxDepth(node.left);
    const rightDepth = maxDepth(node.right);

    // 更新最大直径（左深度 + 右深度 + 1），+1是因为计算节点数而非边数
    maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth + 1);

    return Math.max(leftDepth, rightDepth) + 1;
  }

  maxDepth(root);
  return maxDiameter === 0 ? 0 : maxDiameter - 1; // 转换为边数
}

console.log("二叉树的直径(计算节点):", diameterOfBinaryTreeNodes(diameterTree)); // 3
```

### 3. 翻转二叉树

```javascript
/**
 * @description 翻转二叉树（将每个节点的左右子树交换）
 * @param {TreeNode} root - 二叉树根节点
 * @return {TreeNode} 翻转后的二叉树根节点
 */
function invertTree(root) {
  // 基本情况：空节点
  if (!root) return null;

  // 交换左右子树
  const temp = root.left;
  root.left = root.right;
  root.right = temp;

  // 递归翻转左右子树
  invertTree(root.left);
  invertTree(root.right);

  // 返回翻转后的根节点
  return root;
}

// 创建一个示例二叉树
//      1
//     / \
//    2   3
//   / \   \
//  4   5   6
const originalTree = new TreeNode(1);
originalTree.left = new TreeNode(2);
originalTree.right = new TreeNode(3);
originalTree.left.left = new TreeNode(4);
originalTree.left.right = new TreeNode(5);
originalTree.right.right = new TreeNode(6);

console.log("原始树的层序遍历:", levelOrderTraversal(originalTree));
// 原始树的层序遍历: [[1], [2, 3], [4, 5, 6]]

// 翻转二叉树
const invertedTree = invertTree(originalTree);
console.log("翻转后的树的层序遍历:", levelOrderTraversal(invertedTree));
// 翻转后的树的层序遍历: [[1], [3, 2], [6, 5, 4]]

// 执行过程分析:
// 调用invertTree(节点1):
//   交换节点1的左右子树: left=节点3, right=节点2
//   递归调用左子树: invertTree(节点3)
//     交换节点3的左右子树: left=节点6, right=null
//     递归调用左子树: invertTree(节点6) - 无子节点，返回节点6
//     递归调用右子树: invertTree(null) - 返回null
//     返回节点3
//   递归调用右子树: invertTree(节点2)
//     交换节点2的左右子树: left=节点5, right=节点4
//     递归调用左子树: invertTree(节点5) - 无子节点，返回节点5
//     递归调用右子树: invertTree(节点4) - 无子节点，返回节点4
//     返回节点2
//   返回节点1
// 最终的翻转树:
//      1
//     / \
//    3   2
//   /   / \
//  6   5   4

// 迭代方式实现翻转二叉树（使用BFS）
function invertTreeIterative(root) {
  if (!root) return null;

  const queue = [root];

  while (queue.length > 0) {
    const node = queue.shift();

    // 交换左右子树
    const temp = node.left;
    node.left = node.right;
    node.right = temp;

    // 将左右子节点加入队列
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }

  return root;
}

// 重建原始树
const originalTree2 = new TreeNode(1);
originalTree2.left = new TreeNode(2);
originalTree2.right = new TreeNode(3);
originalTree2.left.left = new TreeNode(4);
originalTree2.left.right = new TreeNode(5);
originalTree2.right.right = new TreeNode(6);

console.log("使用迭代方式翻转树:");
const invertedTree2 = invertTreeIterative(originalTree2);
console.log("翻转后的树的层序遍历(迭代):", levelOrderTraversal(invertedTree2));
// 翻转后的树的层序遍历(迭代): [[1], [3, 2], [6, 5, 4]]
```

### 4. 对称二叉树

```javascript
/**
 * @description 判断二叉树是否对称（镜像）
 * @param {TreeNode} root - 二叉树根节点
 * @return {boolean} 是否对称
 */
function isSymmetric(root) {
  if (!root) return true;

  /**
   * 判断两个子树是否镜像对称
   * @param {TreeNode} left - 左子树
   * @param {TreeNode} right - 右子树
   * @return {boolean} 是否镜像对称
   */
  function isMirror(left, right) {
    // 如果两个节点都为空，则对称
    if (!left && !right) return true;
    // 如果只有一个节点为空，则不对称
    if (!left || !right) return false;

    // 两个节点的值相等，且左节点的左子树与右节点的右子树对称，
    // 左节点的右子树与右节点的左子树对称
    return (left.val === right.val) &&
           isMirror(left.left, right.right) &&
           isMirror(left.right, right.left);
  }

  // 判断根节点的左右子树是否镜像对称
  return isMirror(root.left, root.right);
}

// 创建一个对称的二叉树
//      1
//     / \
//    2   2
//   / \ / \
//  3  4 4  3
const symmetricTree = new TreeNode(1);
symmetricTree.left = new TreeNode(2);
symmetricTree.right = new TreeNode(2);
symmetricTree.left.left = new TreeNode(3);
symmetricTree.left.right = new TreeNode(4);
symmetricTree.right.left = new TreeNode(4);
symmetricTree.right.right = new TreeNode(3);

console.log("对称二叉树检测:", isSymmetric(symmetricTree)); // true

// 创建一个非对称的二叉树
//      1
//     / \
//    2   2
//     \   \
//      3    3
const asymmetricTree = new TreeNode(1);
asymmetricTree.left = new TreeNode(2);
asymmetricTree.right = new TreeNode(2);
asymmetricTree.left.right = new TreeNode(3);
asymmetricTree.right.right = new TreeNode(3);

console.log("非对称二叉树检测:", isSymmetric(asymmetricTree)); // false

// 执行过程分析（对称树）:
// 调用isMirror(左子树2, 右子树2):
//   比较值: 2 === 2 ✓
//   递归调用: isMirror(左子树的左子树3, 右子树的右子树3)
//     比较值: 3 === 3 ✓
//     递归调用: isMirror(null, null) ✓
//     递归调用: isMirror(null, null) ✓
//   递归调用: isMirror(左子树的右子树4, 右子树的左子树4)
//     比较值: 4 === 4 ✓
//     递归调用: isMirror(null, null) ✓
//     递归调用: isMirror(null, null) ✓
// 所有递归调用均返回true，所以返回true

// 执行过程分析（非对称树）:
// 调用isMirror(左子树2, 右子树2):
//   比较值: 2 === 2 ✓
//   递归调用: isMirror(左子树的左子树null, 右子树的右子树3)
//     一个节点为null，一个不为null，返回false ✗
// 子树不对称，返回false

// 迭代方式判断二叉树是否对称
function isSymmetricIterative(root) {
  if (!root) return true;

  const queue = [[root.left, root.right]];

  while (queue.length > 0) {
    const [left, right] = queue.shift();

    // 如果两个节点都为null，继续检查
    if (!left && !right) continue;

    // 如果只有一个节点为null或者值不相等，返回false
    if (!left || !right || left.val !== right.val) return false;

    // 将需要比较的节点对入队
    queue.push([left.left, right.right]);
    queue.push([left.right, right.left]);
  }

  return true;
}

console.log("对称二叉树检测(迭代):", isSymmetricIterative(symmetricTree)); // true
console.log("非对称二叉树检测(迭代):", isSymmetricIterative(asymmetricTree)); // false
```

### 5. 什么是平衡二叉树？如何判断一棵树是否平衡？

**答**：
平衡二叉树是一种特殊的二叉树，其中任意节点的左右子树高度差不超过1。最常见的平衡二叉树是AVL树和红黑树。

平衡二叉树的特点：

1. 任意节点的左右子树高度差不超过1
2. 保证树的高度接近log(n)，其中n是节点数量
3. 避免了普通二叉搜索树退化为链表的问题
4. 保证了搜索、插入和删除操作的O(log n)时间复杂度

判断一棵树是否平衡的方法：

```javascript
/**
 * @description 判断一棵二叉树是否为平衡二叉树
 * @param {TreeNode} root - 二叉树根节点
 * @return {boolean} 是否为平衡二叉树
 */
function isBalanced(root) {
  // 返回值为-1表示不平衡，否则返回树的高度
  function getHeight(node) {
    if (!node) return 0;

    // 计算左右子树高度
    const leftHeight = getHeight(node.left);
    if (leftHeight === -1) return -1;

    const rightHeight = getHeight(node.right);
    if (rightHeight === -1) return -1;

    // 检查高度差
    if (Math.abs(leftHeight - rightHeight) > 1) return -1;

    // 返回当前子树的高度
    return Math.max(leftHeight, rightHeight) + 1;
  }

  return getHeight(root) !== -1;
}

// 创建一个平衡的二叉树
//      1
//     / \
//    2   3
//   /     \
//  4       5
const balancedTree = new TreeNode(1);
balancedTree.left = new TreeNode(2);
balancedTree.right = new TreeNode(3);
balancedTree.left.left = new TreeNode(4);
balancedTree.right.right = new TreeNode(5);

// 创建一个不平衡的二叉树
//      1
//     /
//    2
//   /
//  3
// /
//4
const unbalancedTree = new TreeNode(1);
unbalancedTree.left = new TreeNode(2);
unbalancedTree.left.left = new TreeNode(3);
unbalancedTree.left.left.left = new TreeNode(4);

console.log("平衡树检测:", isBalanced(balancedTree)); // true
console.log("不平衡树检测:", isBalanced(unbalancedTree)); // false
```

**平衡二叉树的应用**：

1. 数据库索引结构（B树、B+树是平衡树的变种）
2. 实现高效的查找、插入和删除操作的集合和映射
3. 网络路由算法
4. 在前端应用中：
   - JavaScript引擎中的对象属性查找
   - 复杂UI组件中的高效数据结构
   - 大型数据可视化中的数据组织

**平衡树的性能优势**：
一个平衡的BST与不平衡的BST在性能上有显著差异：


| 操作 | 平衡BST  | 不平衡BST（最坏情况） |
| ---- | -------- | --------------------- |
| 查找 | O(log n) | O(n)                  |
| 插入 | O(log n) | O(n)                  |
| 删除 | O(log n) | O(n)                  |

当处理大量数据时，这种差异会非常明显。例如，对于包含1000个节点的树，平均查找次数在平衡树中约为10次，而在最坏情况的不平衡树中可能需要1000次。

### 6. 红黑树和AVL树的区别是什么？各自的优缺点？

**答**：
红黑树和AVL树都是自平衡二叉搜索树，但它们在平衡条件、性能特点和应用场景上有所不同。

**区别**：


| 特性     | 红黑树                                                                                                                                             | AVL树                                       |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| 平衡条件 | 不严格平衡，黑色节点深度相同                                                                                                                       | 严格平衡，任意节点的左右子树高度差不超过1   |
| 旋转操作 | 插入最多3次旋转，删除最多3次旋转                                                                                                                   | 插入最多2次旋转，删除可能需要O(log n)次旋转 |
| 树高度   | 最坏情况下为2log(n)                                                                                                                                | 最坏情况下为1.44log(n)                      |
| 节点结构 | 需要额外的颜色标记（1位）                                                                                                                          | 需要存储平衡因子或高度                      |
| 颜色规则 | 1. 节点是红色或黑色<br>2. 根是黑色<br>3. 所有叶子(NIL)是黑色<br>4. 红色节点的子节点都是黑色<br>5. 从任一节点到叶子的所有路径包含相同数量的黑色节点 | 没有颜色，只需满足平衡条件                  |

**优缺点**：

**红黑树**：

- 优点：
  - 插入和删除操作更高效（旋转次数少）
  - 实际应用中性能非常好
  - 内存占用略少
- 缺点：
  - 查找操作稍慢（因为树高度可能更大）
  - 实现更复杂
  - 树高度可能达到2log(n)

**AVL树**：

- 优点：
  - 更严格的平衡条件，查找性能最优
  - 树高度更小，最差情况为1.44log(n)
  - 实现相对简单
- 缺点：
  - 插入和删除时可能需要更多旋转操作
  - 频繁插入删除场景下性能不如红黑树

```javascript
// 红黑树简化示例（不完整，仅展示核心概念）
class RBNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
    this.color = "RED"; // "RED" or "BLACK"
    this.parent = null;
  }
}

class RedBlackTree {
  constructor() {
    this.root = null;
    // 完整实现非常复杂，包含左旋、右旋、颜色调整等操作
  }
}

// AVL树简化示例
class AVLNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
    this.height = 1; // 用于计算平衡因子
  }
}

class AVLTree {
  constructor() {
    this.root = null;
  }

  // 获取节点高度
  height(node) {
    return node ? node.height : 0;
  }

  // 计算平衡因子
  balanceFactor(node) {
    return node ? this.height(node.left) - this.height(node.right) : 0;
  }

  // 更新节点高度
  updateHeight(node) {
    if (node) {
      node.height = 1 + Math.max(this.height(node.left), this.height(node.right));
    }
  }

  // 在实际实现中还需要左旋、右旋、左右旋、右左旋等平衡操作
}
```

**应用场景选择**：

- 选择红黑树：

  - 频繁插入删除的场景（如Java的TreeMap、TreeSet）
  - 实时系统中的调度
  - Linux内核中的进程调度
  - JavaScript引擎中的对象属性存储
- 选择AVL树：

  - 查询频繁而插入删除较少的场景
  - 数据库索引
  - 一次构建多次查询的静态数据结构

在前端开发中，JavaScript引擎的对象属性查找通常使用类似红黑树的数据结构，因为它在保持较好查询性能的同时，具有更高效的属性修改操作。

### 7. 如何在二叉搜索树中查找第k小的元素？

**答**：
在二叉搜索树中查找第k小的元素，可以利用二叉搜索树的一个重要特性：中序遍历会按升序访问节点。因此，中序遍历到第k个节点即可找到第k小的元素。

有两种实现方式：

#### 方法一：使用中序遍历（递归）

```javascript
/**
 * @description 查找二叉搜索树中第k小的元素
 * @param {TreeNode} root - 二叉搜索树根节点
 * @param {number} k - 目标位置（从1开始计数）
 * @return {number} 第k小的元素的值
 */
function kthSmallest(root, k) {
  let count = 0;
  let result = null;

  // 中序遍历
  function inorder(node) {
    if (!node || result !== null) return;

    // 遍历左子树
    inorder(node.left);

    // 处理当前节点
    count++;
    if (count === k) {
      result = node.val;
      return;
    }

    // 遍历右子树
    inorder(node.right);
  }

  inorder(root);
  return result;
}

// 创建一个示例BST
//      5
//     / \
//    3   6
//   / \
//  2   4
//  /
// 1
const bst = new TreeNode(5);
bst.left = new TreeNode(3);
bst.right = new TreeNode(6);
bst.left.left = new TreeNode(2);
bst.left.right = new TreeNode(4);
bst.left.left.left = new TreeNode(1);

console.log("第1小的元素:", kthSmallest(bst, 1)); // 1
console.log("第3小的元素:", kthSmallest(bst, 3)); // 3
console.log("第5小的元素:", kthSmallest(bst, 5)); // 5

// 执行过程分析（k=3）:
// 中序遍历路径: 1 -> 2 -> 3 -> 4 -> 5 -> 6
// 访问节点1，count=1，k=3，继续遍历
// 访问节点2，count=2，k=3，继续遍历
// 访问节点3，count=3，k=3，找到结果，返回3
```

#### 方法二：使用迭代方式

```javascript
/**
 * @description 使用迭代方式查找二叉搜索树中第k小的元素
 * @param {TreeNode} root - 二叉搜索树根节点
 * @param {number} k - 目标位置（从1开始计数）
 * @return {number} 第k小的元素的值
 */
function kthSmallestIterative(root, k) {
  const stack = [];
  let node = root;
  let count = 0;

  while (node || stack.length > 0) {
    // 一直向左走到底
    while (node) {
      stack.push(node);
      node = node.left;
    }

    // 弹出栈顶元素并处理
    node = stack.pop();
    count++;

    // 找到第k小的元素
    if (count === k) {
      return node.val;
    }

    // 向右走一步
    node = node.right;
  }

  return null; // 未找到
}

console.log("第1小的元素(迭代):", kthSmallestIterative(bst, 1)); // 1
console.log("第3小的元素(迭代):", kthSmallestIterative(bst, 3)); // 3
console.log("第5小的元素(迭代):", kthSmallestIterative(bst, 5)); // 5
```

#### 方法三：优化版（带节点计数）

如果BST需要频繁查询第k小元素，可以在每个节点维护一个计数，表示其左子树的节点数量，这样可以在O(h)时间内找到第k小元素，其中h是树的高度。

```javascript
// 增强的节点结构
class TreeNodeWithCount {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
    this.leftCount = 0; // 左子树节点数量
  }
}

// 构建带计数的BST
function buildBSTWithCount(nums) {
  function insert(root, val) {
    if (!root) return new TreeNodeWithCount(val);

    if (val <= root.val) {
      root.leftCount++; // 增加左子树计数
      root.left = insert(root.left, val);
    } else {
      root.right = insert(root.right, val);
    }

    return root;
  }

  let root = null;
  for (const num of nums) {
    root = insert(root, num);
  }

  return root;
}

// 使用节点计数查找第k小元素
function kthSmallestOptimized(root, k) {
  let node = root;

  while (node) {
    const leftCount = node.leftCount;

    if (leftCount + 1 === k) {
      // 当前节点就是第k小的元素
      return node.val;
    } else if (k <= leftCount) {
      // 第k小的元素在左子树中
      node = node.left;
    } else {
      // 第k小的元素在右子树中
      // 调整k，因为左子树和当前节点都排除了
      k -= (leftCount + 1);
      node = node.right;
    }
  }

  return null;
}

// 构建测试树
const bstWithCount = buildBSTWithCount([5, 3, 6, 2, 4, 1]);

console.log("第1小的元素(优化):", kthSmallestOptimized(bstWithCount, 1)); // 1
console.log("第3小的元素(优化):", kthSmallestOptimized(bstWithCount, 3)); // 3
console.log("第5小的元素(优化):", kthSmallestOptimized(bstWithCount, 5)); // 5
```

**时间复杂度比较**：


| 方法         | 时间复杂度        | 适用场景        |
| ------------ | ----------------- | --------------- |
| 递归中序遍历 | O(n)              | 一次性查询      |
| 迭代中序遍历 | O(n)              | 一次性查询      |
| 带节点计数   | O(h)，其中h是树高 | 频繁查询不同k值 |

在前端应用中，这种算法可用于：

- 分页数据的高效加载（如查找第k页的数据）
- 排序列表中的定位
- 数据可视化中的范围选择
- 大型数据集中找出特定排名的元素

### 6. 如何序列化和反序列化一棵二叉树？

**答**：
序列化和反序列化二叉树是将二叉树结构转换为字符串格式以便存储或传输，并能够从这个字符串恢复出原始二叉树结构的过程。这在前端开发中特别常见，例如将应用状态或DOM结构序列化后传输或持久化存储。

有多种方法可以实现二叉树的序列化和反序列化，以下是两种常见方法：

#### 1. 前序遍历方式（DFS）

```javascript
/**
 * @description 使用前序遍历序列化二叉树
 * @param {TreeNode} root - 二叉树根节点
 * @return {string} 序列化后的字符串
 */
function serialize(root) {
  if (!root) return 'X,'; // X表示null节点

  // 前序遍历：根-左-右
  const leftSerialized = serialize(root.left);
  const rightSerialized = serialize(root.right);

  return root.val + ',' + leftSerialized + rightSerialized;
}

/**
 * @description 反序列化二叉树
 * @param {string} data - 序列化后的字符串
 * @return {TreeNode} 反序列化后的二叉树根节点
 */
function deserialize(data) {
  const list = data.split(',');
  list.pop(); // 移除末尾空字符串

  function buildTree() {
    const val = list.shift();
    if (val === 'X') return null;

    const node = new TreeNode(parseInt(val));
    node.left = buildTree();
    node.right = buildTree();

    return node;
  }

  return buildTree();
}

// 创建一个测试树
//      1
//     / \
//    2   3
//       / \
//      4   5
const tree = new TreeNode(1);
tree.left = new TreeNode(2);
tree.right = new TreeNode(3);
tree.right.left = new TreeNode(4);
tree.right.right = new TreeNode(5);

// 序列化树
const serialized = serialize(tree);
console.log("序列化结果:", serialized);
// 输出类似: "1,2,X,X,3,4,X,X,5,X,X,"

// 反序列化回二叉树
const deserializedTree = deserialize(serialized);
console.log("反序列化后的前序遍历:", preOrderTraversal(deserializedTree));
// 输出: [1, 2, 3, 4, 5]

// 验证反序列化是否成功
console.log("原树前序遍历:", preOrderTraversal(tree));
// 输出: [1, 2, 3, 4, 5]
```

#### 2. 层序遍历方式（BFS）

```javascript
/**
 * @description 使用层序遍历序列化二叉树
 * @param {TreeNode} root - 二叉树根节点
 * @return {string} 序列化后的字符串
 */
function serializeBFS(root) {
  if (!root) return '[]';

  const queue = [root];
  const result = [];

  while (queue.length > 0) {
    const node = queue.shift();

    if (node) {
      result.push(node.val);
      queue.push(node.left || null);
      queue.push(node.right || null);
    } else {
      result.push('null');
    }
  }

  // 移除尾部多余的null
  while (result[result.length - 1] === 'null') {
    result.pop();
  }

  return '[' + result.join(',') + ']';
}

/**
 * @description 反序列化层序遍历的二叉树
 * @param {string} data - 序列化后的字符串
 * @return {TreeNode} 反序列化后的二叉树根节点
 */
function deserializeBFS(data) {
  if (data === '[]') return null;

  // 移除括号并分割
  const values = data.slice(1, -1).split(',');
  if (!values.length) return null;

  const root = new TreeNode(parseInt(values[0]));
  const queue = [root];
  let i = 1;

  while (queue.length > 0 && i < values.length) {
    const node = queue.shift();

    // 处理左子节点
    if (i < values.length && values[i] !== 'null') {
      node.left = new TreeNode(parseInt(values[i]));
      queue.push(node.left);
    }
    i++;

    // 处理右子节点
    if (i < values.length && values[i] !== 'null') {
      node.right = new TreeNode(parseInt(values[i]));
      queue.push(node.right);
    }
    i++;
  }

  return root;
}

// 测试层序遍历序列化和反序列化
const bfsSerialized = serializeBFS(tree);
console.log("BFS序列化结果:", bfsSerialized);
// 输出类似: "[1,2,3,null,null,4,5]"

const bfsDeserialized = deserializeBFS(bfsSerialized);
console.log("BFS反序列化后的前序遍历:", preOrderTraversal(bfsDeserialized));
// 输出: [1, 2, 3, 4, 5]
```

**两种方法的比较**：


| 方法          | 优点                   | 缺点                   | 适用场景     |
| ------------- | ---------------------- | ---------------------- | ------------ |
| 前序遍历(DFS) | 序列紧凑、实现简单     | 不直观，难以可视化     | 深度较大的树 |
| 层序遍历(BFS) | 直观，易于可视化和调试 | 可能包含较多null占位符 | 宽度较大的树 |

**前端应用场景**：

- JSON格式存储树状数据结构
- 组件树状态的持久化和恢复
- 将复杂UI结构传输到服务器
- Local Storage中存储树状应用状态
- 虚拟DOM树的序列化和传输

### 7. 如何判断两棵二叉树是否相同？

**答**：
判断两棵二叉树是否相同，需要比较它们的结构和每个节点的值。如果两棵树结构相同且对应位置的节点值也相同，则认为这两棵树相同。

```javascript
/**
 * @description 判断两棵二叉树是否相同
 * @param {TreeNode} p - 第一棵树的根节点
 * @param {TreeNode} q - 第二棵树的根节点
 * @return {boolean} 两棵树是否相同
 */
function isSameTree(p, q) {
  // 如果两个节点都为null，则相同
  if (!p && !q) return true;

  // 如果只有一个节点为null，则不同
  if (!p || !q) return false;

  // 如果当前节点值不同，则不同
  if (p.val !== q.val) return false;

  // 递归比较左右子树
  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}

// 创建测试树
const tree1 = new TreeNode(1);
tree1.left = new TreeNode(2);
tree1.right = new TreeNode(3);

const tree2 = new TreeNode(1);
tree2.left = new TreeNode(2);
tree2.right = new TreeNode(3);

const tree3 = new TreeNode(1);
tree3.left = new TreeNode(3);
tree3.right = new TreeNode(2);

console.log("树1和树2相同:", isSameTree(tree1, tree2)); // true
console.log("树1和树3相同:", isSameTree(tree1, tree3)); // false

// 执行过程分析（树1和树2）:
// 比较根节点: 1 === 1 ✓
// 递归比较左子树:
//   比较节点: 2 === 2 ✓
//   递归比较左子树: null === null ✓
//   递归比较右子树: null === null ✓
// 递归比较右子树:
//   比较节点: 3 === 3 ✓
//   递归比较左子树: null === null ✓
//   递归比较右子树: null === null ✓
// 所有比较都通过，返回true
```

**迭代方式实现**：

```javascript
/**
 * @description 使用迭代方式判断两棵二叉树是否相同
 * @param {TreeNode} p - 第一棵树的根节点
 * @param {TreeNode} q - 第二棵树的根节点
 * @return {boolean} 两棵树是否相同
 */
function isSameTreeIterative(p, q) {
  // 创建一个队列存储节点对
  const queue = [[p, q]];

  while (queue.length > 0) {
    const [node1, node2] = queue.shift();

    // 如果两个节点都为null，继续检查其他节点对
    if (!node1 && !node2) continue;

    // 如果只有一个节点为null或值不同，则不相同
    if (!node1 || !node2 || node1.val !== node2.val) return false;

    // 将左右子节点对加入队列
    queue.push([node1.left, node2.left]);
    queue.push([node1.right, node2.right]);
  }

  return true;
}

console.log("树1和树2相同(迭代):", isSameTreeIterative(tree1, tree2)); // true
console.log("树1和树3相同(迭代):", isSameTreeIterative(tree1, tree3)); // false
```

**前端应用场景**：

1. 比较两个DOM树结构是否相同
2. 比较虚拟DOM树以确定需要更新的部分
3. 判断组件树状态是否发生变化
4. 比较UI结构版本差异
5. 测试工具中验证渲染结果

### 8. 如何找到二叉树中两个节点的最近公共祖先？

**答**：
最近公共祖先(LCA)是两个节点在树中的共同祖先中，距离这两个节点最近的一个。例如，在一个家族树中，两个人的最近公共祖先可能是他们共同的父亲或祖父。

```javascript
/**
 * @description 找到二叉树中两个节点的最近公共祖先
 * @param {TreeNode} root - 二叉树根节点
 * @param {TreeNode} p - 第一个节点
 * @param {TreeNode} q - 第二个节点
 * @return {TreeNode} 最近公共祖先节点
 */
function lowestCommonAncestor(root, p, q) {
  // 基本情况：如果root为空或root就是p或q，则返回root
  if (!root || root === p || root === q) return root;

  // 在左子树中查找
  const left = lowestCommonAncestor(root.left, p, q);
  // 在右子树中查找
  const right = lowestCommonAncestor(root.right, p, q);

  // 如果p和q分别在左右子树中，则当前root就是LCA
  if (left && right) return root;

  // 如果p和q都在左子树中，返回左子树的结果
  // 如果p和q都在右子树中，返回右子树的结果
  return left ? left : right;
}

// 创建一个测试树
//       3
//      / \
//     5   1
//    / \ / \
//   6  2 0  8
//     / \
//    7   4
const lcaTree = new TreeNode(3);
lcaTree.left = new TreeNode(5);
lcaTree.right = new TreeNode(1);
lcaTree.left.left = new TreeNode(6);
lcaTree.left.right = new TreeNode(2);
lcaTree.right.left = new TreeNode(0);
lcaTree.right.right = new TreeNode(8);
lcaTree.left.right.left = new TreeNode(7);
lcaTree.left.right.right = new TreeNode(4);

// 查找节点5和节点1的LCA
const node5 = lcaTree.left;  // 值为5的节点
const node1 = lcaTree.right; // 值为1的节点
const lca1 = lowestCommonAncestor(lcaTree, node5, node1);
console.log("节点5和节点1的LCA值:", lca1.val); // 3

// 查找节点5和节点4的LCA
const node4 = lcaTree.left.right.right; // 值为4的节点
const lca2 = lowestCommonAncestor(lcaTree, node5, node4);
console.log("节点5和节点4的LCA值:", lca2.val); // 5

// 执行过程分析（节点5和节点1）:
// 调用LCA(节点3, 节点5, 节点1)
//   递归左子树: LCA(节点5, 节点5, 节点1)
//     节点5等于p，返回节点5
//   递归右子树: LCA(节点1, 节点5, 节点1)
//     节点1等于q，返回节点1
//   left=节点5, right=节点1，都非空，返回节点3
// 最终结果: 节点3
```

**前端实际应用**：

LCA算法在前端开发中有多种实际应用：

1. **DOM事件传播**：理解事件冒泡和捕获机制，找到共同处理事件的祖先元素

```javascript
// 简化版DOM事件冒泡模拟
function findCommonEventHandler(element1, element2, eventType) {
  // 从两个元素向上查找都注册了指定事件的最近公共祖先
  const ancestors1 = [];
  let current = element1;

  while (current) {
    if (current.hasEventListener(eventType)) {
      ancestors1.push(current);
    }
    current = current.parentElement;
  }

  current = element2;
  while (current) {
    if (current.hasEventListener(eventType) && ancestors1.includes(current)) {
      return current; // 找到最近的公共事件处理元素
    }
    current = current.parentElement;
  }

  return document; // 默认返回document
}
```

2. **组件树状态管理**：在React或Vue等框架中，找到需要重新渲染的最小公共祖先组件
3. **虚拟DOM diff算法**：比较两个树节点变化时，确定需要更新的最小子树
4. **UI组件结构分析**：分析UI层次结构中元素之间的关系
5. **路由嵌套关系**：处理路由嵌套关系时定位共享的父路由

```

### 9. 如何计算二叉树的最大深度和最小深度？

**答**：
二叉树的深度是从根节点到最远叶子节点的最长路径上的节点数量。而最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

#### 最大深度

```javascript
/**
 * @description 计算二叉树的最大深度
 * @param {TreeNode} root - 二叉树根节点
 * @return {number} 最大深度
 */
function maxDepth(root) {
  // 空树深度为0
  if (!root) return 0;

  // 递归计算左右子树的深度，取最大值加1
  const leftDepth = maxDepth(root.left);
  const rightDepth = maxDepth(root.right);

  return Math.max(leftDepth, rightDepth) + 1;
}

// 创建一个示例二叉树
//      3
//     / \
//    9  20
//      /  \
//     15   7
const depthTree = new TreeNode(3);
depthTree.left = new TreeNode(9);
depthTree.right = new TreeNode(20);
depthTree.right.left = new TreeNode(15);
depthTree.right.right = new TreeNode(7);

console.log("最大深度:", maxDepth(depthTree)); // 3

// 执行过程分析:
// 计算节点3的深度:
//   计算节点9的深度:
//     节点9无子节点，返回1
//   计算节点20的深度:
//     计算节点15的深度: 返回1
//     计算节点7的深度: 返回1
//     节点20的深度 = max(1, 1) + 1 = 2
//   节点3的深度 = max(1, 2) + 1 = 3
// 最大深度为3
```

#### 最小深度

```javascript
/**
 * @description 计算二叉树的最小深度
 * @param {TreeNode} root - 二叉树根节点
 * @return {number} 最小深度
 */
function minDepth(root) {
  // 空树深度为0
  if (!root) return 0;

  // 如果没有左子树，返回右子树的最小深度加1
  if (!root.left) return minDepth(root.right) + 1;

  // 如果没有右子树，返回左子树的最小深度加1
  if (!root.right) return minDepth(root.left) + 1;

  // 如果左右子树都存在，返回两者最小深度的较小值加1
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}

// 使用前面创建的示例二叉树
console.log("最小深度:", minDepth(depthTree)); // 2

// 创建一个不平衡的二叉树
//      1
//     /
//    2
//   /
//  3
// /
//4
const unbalancedTree = new TreeNode(1);
unbalancedTree.left = new TreeNode(2);
unbalancedTree.left.left = new TreeNode(3);
unbalancedTree.left.left.left = new TreeNode(4);

console.log("不平衡树的最大深度:", maxDepth(unbalancedTree)); // 4
console.log("不平衡树的最小深度:", minDepth(unbalancedTree)); // 4

// 执行过程分析(不平衡树的最小深度):
// 计算节点1的最小深度:
//   节点1没有右子树，返回左子树的最小深度+1
//   计算节点2的最小深度:
//     节点2没有右子树，返回左子树的最小深度+1
//     计算节点3的最小深度:
//       节点3没有右子树，返回左子树的最小深度+1
//       计算节点4的最小深度:
//         节点4无子节点，返回1
//       节点3的最小深度 = 1 + 1 = 2
//     节点2的最小深度 = 2 + 1 = 3
//   节点1的最小深度 = 3 + 1 = 4
// 最小深度为4
```

#### 使用BFS计算最小深度

BFS通常是计算最小深度的更高效方法，因为一旦找到第一个叶子节点，就可以立即返回其深度。

```javascript
/**
 * @description 使用BFS计算二叉树的最小深度
 * @param {TreeNode} root - 二叉树根节点
 * @return {number} 最小深度
 */
function minDepthBFS(root) {
  if (!root) return 0;

  const queue = [{ node: root, depth: 1 }];

  while (queue.length > 0) {
    const { node, depth } = queue.shift();

    // 如果是叶子节点，立即返回深度
    if (!node.left && !node.right) {
      return depth;
    }

    // 将子节点加入队列
    if (node.left) {
      queue.push({ node: node.left, depth: depth + 1 });
    }

    if (node.right) {
      queue.push({ node: node.right, depth: depth + 1 });
    }
  }

  return 0; // 应该不会到达这里，除非是空树
}

console.log("使用BFS计算最小深度:", minDepthBFS(depthTree)); // 2
console.log("不平衡树使用BFS计算最小深度:", minDepthBFS(unbalancedTree)); // 4
```

**最大深度和最小深度的应用**：

1. **性能优化**：通过最小深度优先遍历处理，可能提前找到结果
2. **页面渲染优化**：评估DOM树的复杂度，预测渲染性能
3. **组件树分析**：检测组件嵌套是否过深，可能导致性能问题
4. **UI自适应**：根据树的深度调整布局策略
5. **递归算法时间复杂度分析**：评估递归算法的执行时间与空间使用

### 10. 在前端开发中，树结构有哪些实际应用？

**答**：
树是前端开发中最常见且最重要的数据结构之一，应用广泛。理解树结构有助于更好地理解和构建前端应用。

#### 1. DOM树和操作

浏览器将HTML解析为DOM树，前端开发的基本任务就是操作这个树结构。

```javascript
// DOM树遍历示例
function traverseDOM(element, callback) {
  callback(element);

  const children = element.children;
  for (let i = 0; i < children.length; i++) {
    traverseDOM(children[i], callback);
  }
}

// 使用示例：计算页面中的所有元素数量
let count = 0;
traverseDOM(document.body, () => count++);
console.log(`页面中共有 ${count} 个元素`);

// 查找特定元素
function findElementsByCondition(root, condition) {
  const results = [];

  traverseDOM(root, (element) => {
    if (condition(element)) {
      results.push(element);
    }
  });

  return results;
}

// 使用示例：查找所有带有特定class的元素
const redElements = findElementsByCondition(
  document.body,
  el => el.classList.contains('red')
);
```

#### 2. 虚拟DOM

React、Vue等现代前端框架使用虚拟DOM技术优化渲染性能，其核心就是树结构。

```javascript
// 简化的虚拟DOM节点结构
class VNode {
  constructor(tag, props, children) {
    this.tag = tag;
    this.props = props;
    this.children = children;
  }
}

// 创建虚拟DOM树
function createElement(tag, props, ...children) {
  return new VNode(tag, props, children);
}

// 简单的JSX示例转换为虚拟DOM
const vdom = createElement('div', { className: 'container' },
  createElement('h1', null, 'Title'),
  createElement('ul', { className: 'list' },
    createElement('li', null, 'Item 1'),
    createElement('li', null, 'Item 2')
  )
);

// 虚拟DOM比较（Diffing）算法核心逻辑依赖于树的比较
function diffTree(oldNode, newNode) {
  // 树节点比较和最小更新集计算
  // ...
}
```

#### 3. 状态管理

Redux等状态管理库通常使用树结构存储应用状态。

```javascript
// 简化的状态树示例
const initialState = {
  user: {
    name: 'Alice',
    preferences: {
      theme: 'dark',
      notifications: {
        email: true,
        push: false
      }
    }
  },
  posts: [
    { id: 1, title: 'Post 1' },
    { id: 2, title: 'Post 2' }
  ]
};

// 使用不可变更新模式操作状态树
function updateState(state, path, value) {
  const newState = { ...state };
  let current = newState;

  // 遍历路径，直到倒数第二层
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    current[key] = { ...current[key] };
    current = current[key];
  }

  // 设置最后一层的值
  current[path[path.length - 1]] = value;

  return newState;
}

// 示例：更新用户的通知首选项
const updatedState = updateState(
  initialState,
  ['user', 'preferences', 'notifications', 'push'],
  true
);
```

#### 4. 组件树

所有现代前端框架中的组件都形成树状结构，通过props向下传递数据和向上传递事件。

```jsx
// React组件树示例
function App() {
  return (
    <div>
      <Header />
      <Main>
        <Sidebar>
          <Navigation />
          <Filter />
        </Sidebar>
        <Content>
          <Articles>
            <Article />
            <Article />
          </Articles>
          <Comments />
        </Content>
      </Main>
      <Footer />
    </div>
  );
}
```

#### 5. 抽象语法树（AST）

JavaScript解析器和编译器（如Babel、Webpack等）将代码解析为AST，然后进行转换和优化。

```javascript
// 简化的AST节点示例
class ASTNode {
  constructor(type, value, children = []) {
    this.type = type;
    this.value = value;
    this.children = children;
  }
}

// 一个简单表达式 "a + b * c" 的AST可能看起来像这样:
const ast = new ASTNode('BinaryExpression', '+', [
  new ASTNode('Identifier', 'a', []),
  new ASTNode('BinaryExpression', '*', [
    new ASTNode('Identifier', 'b', []),
    new ASTNode('Identifier', 'c', [])
  ])
]);

// 遍历AST
function traverseAST(node, visitors) {
  if (visitors[node.type]) {
    visitors[node.type](node);
  }

  node.children.forEach(child => traverseAST(child, visitors));
}

// 使用示例：计算表达式中的标识符数量
let identifierCount = 0;
traverseAST(ast, {
  Identifier: () => identifierCount++
});
console.log(`表达式中有 ${identifierCount} 个标识符`); // 3
```

#### 6. 路由系统

前端路由通常使用树结构组织路由配置，特别是嵌套路由。

```javascript
// 路由配置示例
const routes = [
  {
    path: '/',
    component: Home,
    children: [
      {
        path: 'user',
        component: UserLayout,
        children: [
          { path: 'profile', component: Profile },
          { path: 'settings', component: Settings }
        ]
      },
      {
        path: 'products',
        component: Products,
        children: [
          { path: ':id', component: ProductDetail }
        ]
      }
    ]
  }
];

// 路由匹配算法核心是树遍历
function matchRoute(routes, path) {
  // 树遍历匹配路径
  // ...
}
```

#### 7. UI组件库中的组件

树形控件、级联选择器、菜单等UI组件都依赖树结构。

```javascript
// 树形菜单数据结构示例
const menuData = [
  {
    label: '首页',
    key: 'home',
    children: []
  },
  {
    label: '产品',
    key: 'products',
    children: [
      { label: '电子产品', key: 'electronics' },
      {
        label: '服装',
        key: 'clothing',
        children: [
          { label: '男装', key: 'men' },
          { label: '女装', key: 'women' }
        ]
      }
    ]
  }
];

// 渲染树形菜单
function renderMenu(items, level = 0) {
  return items.map(item => `
    <div class="menu-item" style="padding-left: ${level * 20}px">
      ${item.label}
      ${item.children?.length ? renderMenu(item.children, level + 1) : ''}
    </div>
  `).join('');
}

// 懒加载树节点
async function lazyLoadTreeNode(nodeId) {
  const children = await fetchChildrenFromAPI(nodeId);
  updateTreeNode(nodeId, children);
}
```

#### 8. 文件系统操作

当处理文件上传、目录操作等功能时，也会使用树结构表示文件系统。

```javascript
// 文件系统树结构示例
const fileSystem = {
  name: 'root',
  type: 'directory',
  children: [
    {
      name: 'documents',
      type: 'directory',
      children: [
        { name: 'resume.pdf', type: 'file', size: 1024 },
        { name: 'notes.txt', type: 'file', size: 256 }
      ]
    },
    {
      name: 'images',
      type: 'directory',
      children: [
        { name: 'avatar.png', type: 'file', size: 2048 },
        { name: 'background.jpg', type: 'file', size: 4096 }
      ]
    }
  ]
};

// 计算文件系统总大小
function calculateSize(node) {
  if (node.type === 'file') {
    return node.size;
  }

  return node.children.reduce((total, child) => total + calculateSize(child), 0);
}

console.log(`文件系统总大小: ${calculateSize(fileSystem)} bytes`);
```

**总结**：树结构在前端开发中无处不在，从DOM操作到框架核心，从状态管理到UI组件。深入理解树数据结构及其算法，是成为高级前端开发者的必要条件。

## 学习资源

### 基础教程

- [JavaScript数据结构 - 树](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree) - GitHub上的JS实现
- [前端进阶之道 - 树](https://juejin.cn/post/6844903606226845710) - 前端视角的树结构讲解
- [JavaScript树实现详解](https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/) - FreeCodeCamp上的教程
- [MDN Web文档 - DOM树](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction) - 理解DOM树结构

### 算法练习

- [LeetCode树题集](https://leetcode.com/tag/tree/) - 相关算法练习
- [二叉树的经典问题](https://leetcode-cn.com/study-plan/binary-tree/) - LeetCode官方学习计划
- [CodeSignal - 树结构练习](https://app.codesignal.com/arcade) - 交互式编码平台

### 高级资源

- [React源码中的Fiber树](https://github.com/acdlite/react-fiber-architecture) - 了解React内部实现
- [深入理解虚拟DOM](https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060) - 虚拟DOM原理与实现
- [AST Explorer](https://astexplorer.net/) - 在线探索JavaScript代码的AST结构
- [走近Babel: AST与代码转换](https://juejin.cn/post/6844903956905197576) - Babel的工作原理

### 可视化工具

- [VisuAlgo - 树的可视化](https://visualgo.net/en/bst) - 交互式算法可视化
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/BST.html) - 树操作动画演示
- [Binary Tree Visualizer](https://binary-tree-visualizer.netlify.app/) - 自定义二叉树可视化工具

### 开源实现

- [Lodash的深度遍历](https://github.com/lodash/lodash/blob/master/cloneDeep.js) - 树结构的深拷贝实现
- [D3.js的树布局](https://github.com/d3/d3-hierarchy) - 树数据可视化库
- [Immutable.js](https://immutable-js.com/) - 高效不可变数据结构，包含树的实现

### 书籍推荐

- 《JavaScript数据结构与算法》- Loiane Groner 著
- 《算法（第4版）》- Robert Sedgewick 著
- 《学习JavaScript数据结构与算法（第3版）》- Loiane Groner 著

### 实践项目

1. 实现一个简单的文件浏览器，使用树结构表示目录
2. 创建一个自定义的树形组件，支持展开/折叠/选择等操作
3. 构建一个表达式计算器，使用AST解析表达式
4. 开发一个简化版的虚拟DOM渲染引擎
5. 实现一个组件树可视化工具，分析React或Vue应用的组件结构
