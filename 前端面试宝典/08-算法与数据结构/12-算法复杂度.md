# 算法复杂度

## 概念介绍

算法复杂度是衡量算法执行效率的重要指标，主要分为**时间复杂度**和**空间复杂度**：

- **时间复杂度**：表示算法执行时间随输入规模增长的变化趋势，不关注具体时间（受硬件影响），而是关注操作次数的增长规律。
- **空间复杂度**：表示算法执行过程中所需内存空间随输入规模增长的变化趋势，包括输入数据、临时变量、递归栈等占用的空间。

## 核心特性

### 大O表示法

大O表示法（Big O Notation）是描述复杂度的标准方式，定义为：当输入规模n趋近于无穷大时，算法时间/空间复杂度的上界。

**数学定义**：若存在正常数c和n₀，使得对于所有n≥n₀，有f(n) ≤ c·g(n)，则记f(n) = O(g(n))。

### 常见复杂度类型


| 复杂度     | 名称           | 典型场景               | 增长趋势（n→∞） |
| ---------- | -------------- | ---------------------- | ----------------- |
| O(1)       | 常数复杂度     | 数组随机访问、哈希查找 | 无增长            |
| O(log n)   | 对数复杂度     | 二分查找、平衡树操作   | 极缓慢增长        |
| O(n)       | 线性复杂度     | 数组遍历、单循环操作   | 线性增长          |
| O(n log n) | 线性对数复杂度 | 快速排序、归并排序     | 中等增长          |
| O(n²)     | 平方复杂度     | 冒泡排序、双重循环嵌套 | 快速增长          |
| O(2ⁿ)     | 指数复杂度     | 斐波那契递归（未优化） | 爆炸式增长        |

## 实战案例

### 1. 数组随机访问（O(1)）

#### 代码示例
```javascript
/**
 * @description 数组随机访问示例
 * @param {Array} arr - 输入数组
 * @param {number} index - 要访问的索引
 * @return {*} 索引对应的值
 */
function arrayRandomAccess(arr, index) {
    // 直接通过索引访问数组元素，JavaScript引擎可以在常数时间内计算内存地址并获取值
    // 计算方式：元素地址 = 数组起始地址 + (元素大小 × 索引值)
    // 这是O(1)复杂度的典型操作，无论数组多大，访问时间都相同
    return arr[index];
}

// 调用示例
const fruits = ['apple', 'banana', 'cherry', 'date']; // 创建包含4个水果名称的数组
console.log(arrayRandomAccess(fruits, 2)); // 输出: 'cherry'，访问索引2的元素（第3个元素）
```

#### 复杂度分析
- **时间复杂度**: O(1)
  数组通过索引访问时，计算内存地址的时间是常数级（地址 = 起始地址 + 元素大小 × 索引），与数组长度n无关。
- **空间复杂度**: O(1)
  仅使用固定大小的额外空间。

### 2. 二分查找（O(log n)）

#### 代码示例
```javascript
/**
 * @description 二分查找算法
 * @param {number[]} arr - 已排序的输入数组（升序）
 * @param {number} target - 目标值
 * @return {number} 目标值的索引（未找到返回-1）
 */
function binarySearch(arr, target) {
    // 初始化左右指针，定义搜索范围的边界
    // 时间复杂度：O(1) - 常数时间的初始化操作
    let left = 0; // 搜索范围的左边界，初始为数组第一个元素
    let right = arr.length - 1; // 搜索范围的右边界，初始为数组最后一个元素

    // 当左指针小于等于右指针时，搜索范围内还有元素，继续搜索
    // 循环最多执行log₂n次，因为每次迭代都将搜索范围缩小一半
    while (left <= right) {
        // 计算中间位置，使用Math.floor确保得到整数索引
        // 使用(left + right) / 2可能导致大数溢出，更安全的写法是：left + Math.floor((right - left) / 2)
        const mid = Math.floor((left + right) / 2);

        // 找到目标值，直接返回索引位置（最好情况：O(1)）
        if (arr[mid] === target) return mid;

        // 中间值小于目标值，说明目标在右半部分
        // 将左边界移到中间位置的右侧，缩小搜索范围为右半部分
        if (arr[mid] < target) {
            left = mid + 1; // 排除了mid及左侧的所有元素
        } else {
            // 中间值大于目标值，说明目标在左半部分
            // 将右边界移到中间位置的左侧，缩小搜索范围为左半部分
            right = mid - 1; // 排除了mid及右侧的所有元素
        }
    }

    // 搜索范围为空仍未找到目标值，返回-1表示不存在
    return -1;
}

// 调用示例
const sortedArr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]; // 创建一个已排序的数组
console.log(binarySearch(sortedArr, 23)); // 输出: 5，表示23在数组中的索引位置
console.log(binarySearch(sortedArr, 10)); // 输出: -1，表示10不在数组中
```

#### 复杂度分析
- **时间复杂度**: O(log n)
  每次迭代将搜索范围缩小一半，最多需要log₂n次迭代（n为数组长度）。
  - 最好情况: O(1)（目标值在中间位置）
  - 平均/最坏情况: O(log n)
- **空间复杂度**: O(1)
  仅使用left、right、mid等变量，无额外空间占用。

### 3. 数组遍历（O(n)）

#### 代码示例
```javascript
/**
 * @description 数组遍历并打印每个元素
 * @param {Array} arr - 输入数组
 */
function arrayTraversal(arr) {
    // 使用for循环遍历数组中的每个元素
    // 时间复杂度：O(n)，其中n是数组的长度
    // 循环执行次数与数组长度成正比，这是线性复杂度的典型特征
    for (let i = 0; i < arr.length; i++) {
        // 每次迭代访问一个数组元素并打印
        // 每次访问和打印操作的时间是常数O(1)，但总体复杂度由循环次数决定
        console.log(arr[i]); // 访问每个元素一次
    }
    // 整个函数的时间复杂度是O(n)，因为需要访问所有n个元素
    // 空间复杂度是O(1)，因为只使用了一个循环变量i，与输入大小无关
}

// 调用示例
const numbers = [10, 20, 30, 40, 50]; // 创建一个包含5个数字的数组
arrayTraversal(numbers); // 依次输出: 10, 20, 30, 40, 50，总共执行5次打印操作
```

#### 复杂度分析
- **时间复杂度**: O(n)
  需要访问数组中每个元素一次，执行次数与数组长度n成正比。
- **空间复杂度**: O(1)
  仅使用循环变量i，无额外空间。

### 4. 快速排序（O(n log n)）

#### 代码示例
```javascript
/**
 * @description 快速排序算法
 * @param {number[]} arr - 输入数组
 * @return {number[]} 排序后的数组
 */
function quickSort(arr) {
    // 基准情况：如果数组长度小于等于1，已经是排序状态，直接返回
    // 这是递归终止条件，确保算法最终会结束
    if (arr.length <= 1) return arr; // 基准情况：长度≤1直接返回

    // 选择中间元素作为基准值（pivot）
    // 选择策略影响算法效率，中间元素通常比首尾元素更平衡
    // 更好的做法是随机选择基准值，以避免最坏情况
    const pivot = arr[Math.floor(arr.length / 2)]; // 选择中间元素作为基准值

    // 创建三个数组，分别存储小于、等于和大于基准值的元素
    // 空间复杂度：O(n)，需要额外空间存储这些数组
    const left = [];   // 存储所有小于基准值的元素
    const middle = []; // 存储所有等于基准值的元素
    const right = [];  // 存储所有大于基准值的元素

    // 遍历原数组，将每个元素放入对应的分区
    // 时间复杂度：O(n)，需要遍历数组中的每个元素一次
    for (const num of arr) {
        // 根据元素与基准值的比较结果，将其放入对应数组
        // 每次比较和push操作的时间复杂度都是O(1)
        if (num < pivot) left.push(num);         // 小于基准值，放入left数组
        else if (num === pivot) middle.push(num); // 等于基准值，放入middle数组
        else right.push(num);                    // 大于基准值，放入right数组
    }

    // 递归地对left和right数组进行排序，并与middle数组合并
    // 这是分治算法的核心：将问题分解为更小的子问题，解决后合并结果
    // 时间复杂度：T(n) = 2T(n/2) + O(n)，根据主定理，解为O(n log n)
    // 最坏情况（如已排序数组）：T(n) = T(n-1) + O(n)，解为O(n²)
    return [...quickSort(left), ...middle, ...quickSort(right)];
}

// 调用示例
const unsortedArr = [34, 12, 45, 6, 89, 23]; // 创建一个未排序的数组
console.log(quickSort(unsortedArr)); // 输出: [6, 12, 23, 34, 45, 89]，展示排序后的结果
```

#### 复杂度分析
- **时间复杂度**: O(n log n)（平均/最好情况），O(n²)（最坏情况）
  - 平均/最好情况: 快速排序采用分治策略，将数组划分为左右两部分（左半部分元素≤基准值，右半部分≥基准值）。假设每次划分能将数组均分为两部分（理想情况），则递归深度为log₂n（因为每次规模减半，n/2 → n/4 → ... → 1，共log₂n层）。每层需要遍历整个数组进行划分操作（时间复杂度O(n)），因此总时间复杂度为层数×每层时间 = log₂n × O(n) = O(n log n)。
  - 最坏情况: 数组已有序（如升序），每次划分仅减少一个元素，递归深度为n，总时间O(n²)（可通过随机选择基准值优化）。
- **空间复杂度**: O(log n)（平均情况），O(n)（最坏情况）
  递归调用栈的深度取决于划分平衡度，平均为log n，最坏为n。

### 5. 冒泡排序（O(n²)）

#### 代码示例
```javascript
/**
 * @description 冒泡排序算法
 * @param {number[]} arr - 输入数组
 * @return {number[]} 排序后的数组
 */
function bubbleSort(arr) {
    // 获取数组长度，用于控制循环次数
    // 时间复杂度：O(1)，常数时间操作
    const len = arr.length;

    // 外层循环：控制排序轮数，最多需要n-1轮（n为数组长度）
    // 时间复杂度：O(n)，最多执行n-1次
    for (let i = 0; i < len - 1; i++) {
        // 优化标志：记录本轮是否发生交换，用于提前终止
        // 如果一轮中没有交换，说明数组已经有序
        let swapped = false;

        // 内层循环：比较并交换相邻元素
        // 每轮比较次数递减，因为每轮结束后最大的元素已经到达正确位置
        // 时间复杂度：O(n-i-1)，随着i增加而减少
        for (let j = 0; j < len - 1 - i; j++) {
            // 比较相邻元素，如果前一个大于后一个，则交换位置
            // 这确保较大的元素逐渐"冒泡"到数组末尾
            if (arr[j] > arr[j + 1]) {
                // 使用ES6解构赋值语法交换元素，无需临时变量
                // 时间复杂度：O(1)，常数时间操作
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 交换相邻元素
                swapped = true; // 标记本轮发生了交换
            }
        }

        // 优化：如果本轮没有发生交换，说明数组已经有序，可以提前终止
        // 最好情况下（已排序数组），时间复杂度降至O(n)
        if (!swapped) break; // 提前终止：若本轮无交换则已排序完成
    }

    // 返回排序后的数组（原地排序，返回原数组的引用）
    // 总体时间复杂度：O(n²)，因为有两层嵌套循环
    // 空间复杂度：O(1)，只使用了少量额外变量
    return arr;
}

// 调用示例
const messyArr = [5, 3, 8, 4, 6]; // 创建一个未排序的数组
console.log(bubbleSort(messyArr)); // 输出: [3, 4, 5, 6, 8]，展示排序后的结果
```

#### 复杂度分析
- **时间复杂度**: O(n²)
  - 最好情况: O(n)（数组已有序，通过swapped标志提前终止）
  - 平均/最坏情况: O(n²)（双重循环，外层n次，内层n-i次，总次数≈n²/2）。
- **空间复杂度**: O(1)
  仅使用固定大小的额外空间（交换变量）。

### 6. 斐波那契递归（O(2ⁿ)）

#### 代码示例
```javascript
/**
 * @description 未优化的斐波那契递归实现
 * @param {number} n - 斐波那契数列的项数（n≥0）
 * @return {number} 第n项的值（F(0)=0, F(1)=1）
 */
function fibonacci(n) {
    // 基准情况：F(0)=0, F(1)=1
    // 这是递归终止条件，防止无限递归
    // 时间复杂度：O(1)，常数时间操作
    if (n <= 1) return n;

    // 递归调用：F(n) = F(n-1) + F(n-2)
    // 这里产生了两个递归分支，导致指数级的时间复杂度
    // 时间复杂度：T(n) = T(n-1) + T(n-2) + O(1)，解为O(2ⁿ)
    // 这是因为递归树呈现出斐波那契树的结构，节点数量接近2ⁿ
    return fibonacci(n - 1) + fibonacci(n - 2); // 递归计算前两项

    // 注意：这种实现存在大量重复计算，如F(3)在计算F(5)时会被重复计算多次
    // 优化方法：使用记忆化（memoization）或动态规划可将复杂度降至O(n)
}

// 调用示例
console.log(fibonacci(5));  // 输出: 5（F(5)=F(4)+F(3)=3+2=5）
// 递归树：F(5) → F(4)+F(3) → [F(3)+F(2)]+[F(2)+F(1)] → ...
console.log(fibonacci(10)); // 输出: 55
// 注意：随着n增大，计算时间呈指数级增长，n=40时已经非常慢
```

#### 复杂度分析
- **时间复杂度**: O(2ⁿ)
  递归树的节点数呈指数增长（每个节点分裂为2个子节点），总计算次数≈2ⁿ。
- **空间复杂度**: O(n)
  递归调用栈的最大深度为n（每次递归减少n，直到n≤1）。

### 复杂度计算依据总结
复杂度计算的核心是统计算法中**关键操作的执行次数**（时间复杂度）或**额外占用的内存空间**（空间复杂度），并取最高阶项（忽略常数和低阶项）。例如：
- O(1)：操作次数与n无关（如数组索引访问）。
- O(log n)：操作次数随n增长呈对数级（如二分查找每次缩小一半范围）。
- O(n²)：双重循环嵌套（如冒泡排序的两层循环）。

## 面试常见问题

### 问题1：如何区分时间复杂度的最优、平均和最坏情况？

**解答**：

- 最优情况：输入数据对算法最有利时的复杂度（如冒泡排序中数组已排序，复杂度O(n)）。
- 最坏情况：输入数据对算法最不利时的复杂度（如冒泡排序中数组逆序，复杂度O(n²)）。
- 平均情况：所有可能输入的复杂度期望值（需结合概率分布计算，如快速排序平均复杂度O(n log n)）。

### 问题2：空间复杂度是否包括输入数据本身？

**解答**：
通常空间复杂度仅计算算法运行过程中**额外占用**的空间，输入数据本身的空间不计入（除非题目特别说明）。例如，计算一个数组的和时，输入数组的空间不算，仅计算临时变量的空间（O(1)）。

### 问题3：递归算法的空间复杂度如何计算？

**解答**：
递归算法的空间复杂度主要由**递归栈深度**决定。例如，计算n的阶乘的递归函数：

```javascript
/**
 * @description 计算n的阶乘的递归函数
 * @param {number} n - 非负整数
 * @return {number} n的阶乘值 n!
 */
function factorial(n) {
  // 基准情况：0的阶乘定义为1
  // 这是递归终止条件，防止无限递归
  // 时间复杂度：O(1)，常数时间操作
  if (n === 0) return 1;

  // 递归调用：n! = n × (n-1)!
  // 每次递归将问题规模减小1，形成线性递归链
  // 时间复杂度：T(n) = T(n-1) + O(1)，解为O(n)
  // 空间复杂度：O(n)，因为递归调用栈最大深度为n
  return n * factorial(n - 1); // 递归调用栈深度为n

  // 注意：与斐波那契递归不同，这里每个子问题只产生一个递归调用
  // 因此时间复杂度是线性的O(n)，而不是指数级的
}
```

其空间复杂度为O(n)（递归栈最多保存n层调用）。

## 扩展思考

1. 为什么快速排序的平均复杂度是O(n log n)，而最坏情况是O(n²)？如何避免最坏情况？
2. 空间复杂度为O(1)的算法是否一定比O(n)的算法更优？举例说明。
3. 如何用大O表示法分析嵌套循环的复杂度（如三层循环）？
