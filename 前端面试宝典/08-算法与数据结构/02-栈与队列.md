# 栈与队列

## 栈（Stack）

### 基本概念

栈是一种遵循后进先出（LIFO，Last In First Out）原则的有序集合。新元素的添加和移除都发生在同一端，称为栈顶，另一端称为栈底。最新添加的元素总是位于栈顶，最先被移除。

### 栈的基本操作

- **push(element)**：将元素添加到栈顶
- **pop()**：移除并返回栈顶元素
- **peek()**：返回栈顶元素但不移除
- **isEmpty()**：检查栈是否为空
- **size()**：返回栈中元素的数量
- **clear()**：清空栈

### JavaScript实现栈

#### 使用数组实现

```javascript
class Stack {
  constructor() {
    this.items = [];
  }

  push(element) {
    this.items.push(element);
  }

  pop() {
    if (this.isEmpty()) {
      return "栈为空";
    }
    return this.items.pop();
  }

  peek() {
    if (this.isEmpty()) {
      return "栈为空";
    }
    return this.items[this.items.length - 1];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}

// 使用示例
const stack = new Stack();
stack.push(10);
stack.push(20);
stack.push(30);
console.log(stack.peek()); // 30
console.log(stack.pop()); // 30
console.log(stack.size()); // 2
```

#### 使用对象实现（更高效）

```javascript
class Stack {
  constructor() {
    this.items = {};
    this.count = 0;
  }

  push(element) {
    this.items[this.count] = element;
    this.count++;
  }

  pop() {
    if (this.isEmpty()) {
      return undefined;
    }
    this.count--;
    const result = this.items[this.count];
    delete this.items[this.count];
    return result;
  }

  peek() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.count - 1];
  }

  isEmpty() {
    return this.count === 0;
  }

  size() {
    return this.count;
  }

  clear() {
    this.items = {};
    this.count = 0;
  }
}
```

### 栈的应用场景

1. **函数调用栈**：JavaScript引擎使用栈来管理函数调用
2. **表达式求值**：计算中缀、前缀和后缀表达式
3. **括号匹配**：检查括号是否匹配
4. **浏览器历史记录**：实现前进和后退功能
5. **撤销操作**：实现撤销/重做功能
6. **深度优先搜索**：图和树的遍历算法
7. **路径查找**：迷宫问题和路径查找算法

### 栈的时间复杂度

| 操作    | 时间复杂度 |
| ------- | ---------- |
| push    | O(1)       |
| pop     | O(1)       |
| peek    | O(1)       |
| isEmpty | O(1)       |
| size    | O(1)       |

## 队列（Queue）

### 基本概念

队列是一种遵循先进先出（FIFO，First In First Out）原则的有序集合。新元素的添加发生在一端，称为队尾，而元素的移除发生在另一端，称为队首。最先添加的元素总是最先被移除。

### 队列的基本操作

- **enqueue(element)**：将元素添加到队尾
- **dequeue()**：移除并返回队首元素
- **front()**：返回队首元素但不移除
- **isEmpty()**：检查队列是否为空
- **size()**：返回队列中元素的数量
- **clear()**：清空队列

### JavaScript实现队列

#### 使用数组实现

```javascript
class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(element) {
    this.items.push(element);
  }

  dequeue() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items.shift();
  }

  front() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items[0];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}

// 使用示例
const queue = new Queue();
queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
console.log(queue.front()); // 10
console.log(queue.dequeue()); // 10
console.log(queue.size()); // 2
```

#### 使用对象实现（更高效）

```javascript
class Queue {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  enqueue(element) {
    this.items[this.backIndex] = element;
    this.backIndex++;
  }

  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    const result = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    return result;
  }

  front() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.frontIndex];
  }

  isEmpty() {
    return this.backIndex - this.frontIndex === 0;
  }

  size() {
    return this.backIndex - this.frontIndex;
  }

  clear() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }
}
```

### 队列的变体

#### 1. 双端队列（Deque）

双端队列是一种允许在两端添加和移除元素的特殊队列。

```javascript
class Deque {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  addFront(element) {
    if (this.isEmpty()) {
      this.addBack(element);
    } else {
      this.frontIndex--;
      this.items[this.frontIndex] = element;
    }
  }

  addBack(element) {
    this.items[this.backIndex] = element;
    this.backIndex++;
  }

  removeFront() {
    if (this.isEmpty()) {
      return undefined;
    }

    const result = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    return result;
  }

  removeBack() {
    if (this.isEmpty()) {
      return undefined;
    }

    this.backIndex--;
    const result = this.items[this.backIndex];
    delete this.items[this.backIndex];
    return result;
  }

  peekFront() {
    if (this.isEmpty()) {
      return undefined;
    }

    return this.items[this.frontIndex];
  }

  peekBack() {
    if (this.isEmpty()) {
      return undefined;
    }

    return this.items[this.backIndex - 1];
  }

  isEmpty() {
    return this.backIndex - this.frontIndex === 0;
  }

  size() {
    return this.backIndex - this.frontIndex;
  }

  clear() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  toString() {
    if (this.isEmpty()) {
      return '';
    }

    let objString = `${this.items[this.frontIndex]}`;

    for (let i = this.frontIndex + 1; i < this.backIndex; i++) {
      objString = `${objString}, ${this.items[i]}`;
    }

    return objString;
  }
}

// 使用示例
const deque = new Deque();

// 入队操作
deque.addBack('John');
deque.addBack('Jack');
console.log(deque.toString()); // 输出: John, Jack

// 前端入队
deque.addFront('Camila');
console.log(deque.toString()); // 输出: Camila, John, Jack

// 查看两端元素
console.log(deque.peekFront()); // 输出: Camila
console.log(deque.peekBack());  // 输出: Jack

// 移除两端元素
console.log(deque.removeFront()); // 输出: Camila
console.log(deque.removeBack());  // 输出: Jack
console.log(deque.toString());    // 输出: John
```

#### 2. 优先队列（Priority Queue）

优先队列中的元素具有优先级，优先级高的元素先出队。

```javascript
class PriorityQueue {
  constructor() {
    this.items = [];
  }

  enqueue(element, priority) {
    const queueElement = { element, priority };
    let added = false;

    for (let i = 0; i < this.items.length; i++) {
      if (queueElement.priority < this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
        added = true;
        break;
      }
    }

    if (!added) {
      this.items.push(queueElement);
    }
  }

  dequeue() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items.shift().element;
  }

  front() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items[0].element;
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}

// 使用示例
const priorityQueue = new PriorityQueue();
priority.enqueue("普通任务", 2);
priority.enqueue("紧急任务", 1);
priority.enqueue("低优先级任务", 3);
priority.enqueue("最紧急任务", 0);
console.log(priorityQueue.dequeue()); // 输出: 最紧急任务
```

#### 3. 循环队列（Circular Queue）

循环队列是一种环形结构，当队尾到达数组末尾时，下一个元素会被放置在数组开头。

```javascript
class CircularQueue {
  constructor(capacity) {
    this.items = new Array(capacity);
    this.capacity = capacity;
    this.currentLength = 0;
    this.front = -1;
    this.rear = -1;
  }

  isFull() {
    return this.currentLength === this.capacity;
  }

  isEmpty() {
    return this.currentLength === 0;
  }

  enqueue(element) {
    if (this.isFull()) {
      return false;
    }

    this.rear = (this.rear + 1) % this.capacity;
    this.items[this.rear] = element;
    this.currentLength++;

    if (this.front === -1) {
      this.front = this.rear;
    }

    return true;
  }

  dequeue() {
    if (this.isEmpty()) {
      return null;
    }

    const item = this.items[this.front];
    this.items[this.front] = null;
    this.front = (this.front + 1) % this.capacity;
    this.currentLength--;

    if (this.isEmpty()) {
      this.front = -1;
      this.rear = -1;
    }

    return item;
  }

  peek() {
    if (this.isEmpty()) {
      return null;
    }

    return this.items[this.front];
  }

  size() {
    return this.currentLength;
  }

  print() {
    if (this.isEmpty()) {
      console.log('队列为空');
    } else {
      let i;
      let str = '';
      for (i = this.front; i !== this.rear; i = (i + 1) % this.capacity) {
        str += this.items[i] + ' ';
      }
      str += this.items[i];
      console.log(str);
    }
  }
}
```

### 队列的应用场景

1. **任务队列**：JavaScript事件循环中的任务队列
2. **消息队列**：处理异步消息和事件
3. **缓冲区管理**：管理数据流和缓冲区
4. **打印任务队列**：管理打印任务
5. **广度优先搜索**：图和树的遍历算法
6. **请求处理**：Web服务器中的请求处理
7. **线程池**：管理线程和进程

### 队列的时间复杂度

| 操作    | 数组实现 | 对象实现 |
| ------- | -------- | -------- |
| enqueue | O(1)     | O(1)     |
| dequeue | O(n)     | O(1)     |
| front   | O(1)     | O(1)     |
| isEmpty | O(1)     | O(1)     |
| size    | O(1)     | O(1)     |

## 栈与队列的比较

| 特性          | 栈                                 | 队列                             |
| ------------- | ---------------------------------- | -------------------------------- |
| 插入/删除原则 | LIFO（后进先出）                   | FIFO（先进先出）                 |
| 插入操作      | push（在栈顶）                     | enqueue（在队尾）                |
| 删除操作      | pop（从栈顶）                      | dequeue（从队首）                |
| 访问元素      | 只能访问栈顶元素                   | 只能访问队首元素                 |
| 应用场景      | 函数调用、表达式求值、深度优先搜索 | 任务调度、消息队列、广度优先搜索 |

## 前端应用场景

### 栈的前端应用

1. **路由历史管理**：实现浏览器的前进/后退功能
2. **撤销/重做功能**：在编辑器中实现操作历史
3. **括号匹配验证**：验证HTML/XML标签或JavaScript代码中的括号是否匹配
4. **表达式计算器**：实现简单的计算器功能
5. **调用栈可视化**：调试工具中的调用栈展示
6. **组件层级管理**：管理组件的嵌套层级

### 队列的前端应用

1. **异步任务队列**：管理异步操作和回调
2. **事件处理**：事件监听和处理机制
3. **动画效果队列**：按顺序执行动画效果
4. **请求限流**：控制API请求频率
5. **消息通知系统**：管理通知的显示和消失
6. **图片懒加载**：管理待加载的图片队列

## 常见算法题

### 1. 有效的括号（栈应用）

```javascript
/**
 * 判断括号是否有效匹配
 * @param {string} s 包含括号的字符串
 * @return {boolean} 是否有效
 */
function isValid(s) {
  const stack = [];
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  };

  for (let i = 0; i < s.length; i++) {
    const char = s[i];

    if (map[char]) { // 左括号
      stack.push(char);
    } else { // 右括号
      const top = stack.pop();

      if (map[top] !== char) {
        return false;
      }
    }
  }

  return stack.length === 0;
}

console.log(isValid("()[]{}")); // true
console.log(isValid("([)]")); // false
```

### 2. 如何使用两个栈实现一个队列？

**答**：
两个栈可以模拟队列的先进先出特性。一个栈用于入队操作(stackIn)，另一个栈用于出队操作(stackOut)。当需要出队时，将stackIn中的元素依次弹出并压入stackOut，这样stackOut的出栈顺序就是队列的出队顺序。

```javascript
/**
 * @description 使用两个栈实现队列
 */
class QueueUsingStacks {
  /**
   * 初始化两个栈
   */
  constructor() {
    this.stackIn = [];  // 用于入队操作
    this.stackOut = []; // 用于出队操作
  }

  /**
   * 入队操作 - 直接压入stackIn
   * @param {any} element - 入队元素
   */
  enqueue(element) {
    this.stackIn.push(element);
  }

  /**
   * 出队操作
   * @return {any} 队首元素
   */
  dequeue() {
    // 如果stackOut为空，将stackIn的所有元素转移到stackOut
    if (this.stackOut.length === 0) {
      this._transferElements();
    }

    // 如果stackOut仍为空，说明队列为空
    if (this.stackOut.length === 0) {
      return '队列为空';
    }

    return this.stackOut.pop();
  }

  /**
   * 查看队首元素
   * @return {any} 队首元素
   */
  peek() {
    if (this.stackOut.length === 0) {
      this._transferElements();
    }

    if (this.stackOut.length === 0) {
      return '队列为空';
    }

    return this.stackOut[this.stackOut.length - 1];
  }

  /**
   * 将stackIn的元素转移到stackOut
   * @private
   */
  _transferElements() {
    while (this.stackIn.length > 0) {
      this.stackOut.push(this.stackIn.pop());
    }
  }

  /**
   * 检查队列是否为空
   * @return {boolean} 是否为空
   */
  isEmpty() {
    return this.stackIn.length === 0 && this.stackOut.length === 0;
  }

  /**
   * 返回队列中的元素数量
   * @return {number} 元素数量
   */
  size() {
    return this.stackIn.length + this.stackOut.length;
  }
}

// 使用示例
const queue = new QueueUsingStacks();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
console.log(queue.peek());  // 输出: 1
console.log(queue.dequeue());  // 输出: 1
console.log(queue.dequeue());  // 输出: 2
queue.enqueue(4);
console.log(queue.dequeue());  // 输出: 3
console.log(queue.dequeue());  // 输出: 4
```

**算法分析**：

- 时间复杂度：
  - 入队操作(enqueue): O(1)
  - 出队操作(dequeue): 均摊O(1)，最坏情况O(n)
  - 查看队首(peek): 均摊O(1)，最坏情况O(n)
- 空间复杂度：O(n)，n为队列中元素数量

**关键点**：

1. 入队时只操作stackIn
2. 出队时优先从stackOut取，只有当stackOut为空时才将stackIn的元素转移到stackOut
3. 转移过程会颠倒元素顺序，使最早入队的元素位于stackOut的顶部

**实际应用**：
这种实现在处理需要缓冲区的场景中很有用，如实现消息队列或事件处理系统，特别是当入队和出队操作频率不同时。

### 3. 如何使用两个队列实现一个栈？

**答**：
可以使用两个队列实现栈的后进先出特性。主要思路是：将一个队列作为主队列(queue1)存储元素，另一个作为辅助队列(queue2)。在出栈时，将主队列中除最后一个元素外的所有元素移到辅助队列中，然后返回主队列中剩余的那个元素(即最后入栈的元素)。之后交换两个队列的角色。

```javascript
/**
 * @description 使用两个队列实现栈
 */
class StackUsingQueues {
  /**
   * 初始化两个队列
   */
  constructor() {
    this.queue1 = []; // 主队列
    this.queue2 = []; // 辅助队列
  }

  /**
   * 入栈操作
   * @param {any} element - 入栈元素
   */
  push(element) {
    // 始终向主队列中添加元素
    this.queue1.push(element);
  }

  /**
   * 出栈操作
   * @return {any} 栈顶元素
   */
  pop() {
    if (this.isEmpty()) {
      return '栈为空';
    }

    // 将queue1中除最后一个元素外的所有元素移到queue2
    while (this.queue1.length > 1) {
      this.queue2.push(this.queue1.shift());
    }

    // 此时queue1中只剩下最后一个元素，即栈顶元素
    const result = this.queue1.shift();

    // 交换两个队列的角色
    [this.queue1, this.queue2] = [this.queue2, this.queue1];

    return result;
  }

  /**
   * 查看栈顶元素
   * @return {any} 栈顶元素
   */
  top() {
    if (this.isEmpty()) {
      return '栈为空';
    }

    // 类似pop操作，但在完成后将栈顶元素放回queue1
    while (this.queue1.length > 1) {
      this.queue2.push(this.queue1.shift());
    }

    const result = this.queue1.shift();
    this.queue2.push(result); // 将栈顶元素也移到queue2

    // 交换两个队列的角色
    [this.queue1, this.queue2] = [this.queue2, this.queue1];

    return result;
  }

  /**
   * 检查栈是否为空
   * @return {boolean} 是否为空
   */
  isEmpty() {
    return this.queue1.length === 0;
  }

  /**
   * 返回栈中的元素数量
   * @return {number} 元素数量
   */
  size() {
    return this.queue1.length;
  }
}

// 使用示例
const stack = new StackUsingQueues();
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack.top());   // 输出: 3
console.log(stack.pop());   // 输出: 3
console.log(stack.pop());   // 输出: 2
stack.push(4);
console.log(stack.pop());   // 输出: 4
console.log(stack.pop());   // 输出: 1
```

**算法分析**：

- 时间复杂度：
  - 入栈操作(push): O(1)
  - 出栈操作(pop): O(n)，n为栈中元素数量
  - 查看栈顶(top): O(n)
- 空间复杂度：O(n)

**优化方案**：
可以通过使用单队列实现栈来优化空间复杂度：

```javascript
/**
 * @description 使用单队列实现栈的优化版本
 */
class StackUsingSingleQueue {
  constructor() {
    this.queue = [];
  }

  push(element) {
    this.queue.push(element);
  }

  pop() {
    if (this.isEmpty()) {
      return '栈为空';
    }

    // 将前n-1个元素依次出队并重新入队
    const size = this.queue.length;
    for (let i = 0; i < size - 1; i++) {
      this.queue.push(this.queue.shift());
    }

    // 返回最后一个元素
    return this.queue.shift();
  }

  top() {
    if (this.isEmpty()) {
      return '栈为空';
    }

    const size = this.queue.length;
    for (let i = 0; i < size - 1; i++) {
      this.queue.push(this.queue.shift());
    }

    const result = this.queue.shift();
    this.queue.push(result);

    return result;
  }

  isEmpty() {
    return this.queue.length === 0;
  }

  size() {
    return this.queue.length;
  }
}
```

**实际应用**：
虽然这种实现方式不如直接使用数组或对象实现栈高效，但它展示了数据结构之间的转换思想，在面试中是常见问题，也有助于理解队列和栈的本质区别。

### 4. 什么是优先队列？它与普通队列有什么区别？

**答**：
优先队列是一种特殊的队列，其中的元素都有一个优先级属性，元素出队的顺序不是先进先出，而是按照优先级决定，优先级高的元素优先出队。

**优先队列与普通队列的区别**：

```javascript
/**
 * @description 普通队列与优先队列的对比
 */
// 普通队列 - 先进先出
const normalQueue = [];
normalQueue.push("任务A");
normalQueue.push("任务B");
normalQueue.push("任务C");
console.log(normalQueue.shift()); // 输出: 任务A
console.log(normalQueue.shift()); // 输出: 任务B
console.log(normalQueue.shift()); // 输出: 任务C

// 优先队列 - 按优先级出队
class PQueue {
  constructor() {
    this.items = [];
  }

  // 入队时考虑优先级
  enqueue(element, priority) {
    const queueElement = { element, priority };

    // 找到合适的位置插入
    let added = false;
    for (let i = 0; i < this.items.length; i++) {
      if (priority < this.items[i].priority) {
        //即原 i 位置元素的前面
        this.items.splice(i, 0, queueElement);
        added = true;
        break;
      }
    }

    // 如果没有找到合适位置，添加到队尾
    if (!added) {
      this.items.push(queueElement);
    }
  }

  dequeue() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items.shift().element;
  }

  isEmpty() {
    return this.items.length === 0;
  }
}

// 优先队列示例 - 值越小优先级越高
const priorityQueue = new PQueue();
priorityQueue.enqueue("普通任务", 2);
priorityQueue.enqueue("紧急任务", 1);
priorityQueue.enqueue("低优先级任务", 3);
priorityQueue.enqueue("最紧急任务", 0);

console.log(priorityQueue.dequeue()); // 输出: 最紧急任务
console.log(priorityQueue.dequeue()); // 输出: 紧急任务
console.log(priorityQueue.dequeue()); // 输出: 普通任务
console.log(priorityQueue.dequeue()); // 输出: 低优先级任务
```

**优先队列的实现方式**：

1. **基于数组的简单实现**：如上例所示，每次入队时找到合适的位置插入。

   - 入队时间复杂度：O(n)
   - 出队时间复杂度：O(1)
2. **基于堆的高效实现**：使用二叉堆实现，通常是最小堆(最小优先队列)或最大堆(最大优先队列)。

   - 入队时间复杂度：O(log n)
   - 出队时间复杂度：O(log n)

```javascript
/**
 * @description 基于最小堆的优先队列实现
 */
class MinHeapPriorityQueue {
  constructor() {
    this.heap = [];
  }

  // 获取父节点索引
  getParentIndex(index) {
    return Math.floor((index - 1) / 2);
  }

  // 获取左子节点索引
  getLeftChildIndex(index) {
    return 2 * index + 1;
  }

  // 获取右子节点索引
  getRightChildIndex(index) {
    return 2 * index + 2;
  }

  // 交换两个节点
  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  // 向上调整
  heapifyUp() {
    let index = this.heap.length - 1;
    while (index > 0) {
      const parentIndex = this.getParentIndex(index);
      if (this.heap[parentIndex].priority <= this.heap[index].priority) {
        break;
      }
      this.swap(index, parentIndex);
      index = parentIndex;
    }
  }

  // 向下调整
  heapifyDown() {
    let index = 0;
    const length = this.heap.length;
    const element = this.heap[0];

    while (true) {
      const leftChildIndex = this.getLeftChildIndex(index);
      const rightChildIndex = this.getRightChildIndex(index);
      let smallestChildIndex = index;

      // 找到最小的子节点
      if (leftChildIndex < length &&
          this.heap[leftChildIndex].priority < this.heap[smallestChildIndex].priority) {
        smallestChildIndex = leftChildIndex;
      }

      if (rightChildIndex < length &&
          this.heap[rightChildIndex].priority < this.heap[smallestChildIndex].priority) {
        smallestChildIndex = rightChildIndex;
      }

      if (smallestChildIndex === index) {
        break;
      }

      this.swap(index, smallestChildIndex);
      index = smallestChildIndex;
    }
  }

  // 入队
  enqueue(element, priority) {
    this.heap.push({ element, priority });
    this.heapifyUp();
  }

  // 出队
  dequeue() {
    if (this.isEmpty()) {
      return "队列为空";
    }

    const min = this.heap[0].element;
    const last = this.heap.pop();

    if (this.heap.length > 0) {
      this.heap[0] = last;
      this.heapifyDown();
    }

    return min;
  }

  // 查看队首
  peek() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.heap[0].element;
  }

  isEmpty() {
    return this.heap.length === 0;
  }

  size() {
    return this.heap.length;
  }
}
```

**应用场景**：

1. **任务调度系统**：操作系统中的进程调度
2. **网络数据包处理**：根据优先级处理网络请求
3. **医院急诊室排队**：根据病情严重程度安排治疗
4. **事件处理系统**：按事件优先级处理事件
5. **前端中的请求优先级**：重要的API请求优先执行
6. **动画渲染队列**：重要的渲染任务优先处理

**比较优先队列不同实现方式的性能**：

| 实现方式   | 入队(Enqueue) | 出队(Dequeue) | 查看队首(Peek) |
| ---------- | ------------- | ------------- | -------------- |
| 数组排序   | O(n)          | O(1)          | O(1)           |
| 二叉堆     | O(log n)      | O(log n)      | O(1)           |
| 二叉搜索树 | O(log n)平均  | O(log n)平均  | O(1)           |
| 斐波那契堆 | O(1)平摊      | O(log n)平摊  | O(1)           |

**JavaScript中使用第三方库**：
在实际开发中，可以使用现有的优先队列库，如 `priorityqueuejs`或 `fastpriorityqueue`：

```javascript
// 使用priorityqueuejs示例
const PriorityQueue = require('priorityqueuejs');

const queue = new PriorityQueue((a, b) => {
  return a.priority - b.priority; // 小值优先
});

queue.enq({ task: '普通任务', priority: 2 });
queue.enq({ task: '紧急任务', priority: 1 });
queue.enq({ task: '低优先级任务', priority: 3 });

console.log(queue.deq().task); // 紧急任务
```

### 5. 如何实现一个支持获取最小元素的栈？

**答**：
最小栈是一种特殊的栈，除了支持常规的push、pop、top操作外，还支持在常数时间内获取栈中的最小元素。实现这一功能的关键是使用辅助栈(minStack)来跟踪每个状态下的最小值。

```javascript
/**
 * @description 最小栈的实现
 */
class MinStack {
  /**
   * 初始化数据栈和最小值栈
   */
  constructor() {
    this.stack = [];      // 主数据栈
    this.minStack = [];   // 辅助最小值栈
  }

  /**
   * 入栈操作
   * @param {number} val - 入栈的值
   */
  push(val) {
    this.stack.push(val);

    // 如果最小栈为空或新元素小于等于当前最小值，则将新元素也压入最小栈
    if (this.minStack.length === 0 || val <= this.getMin()) {
      this.minStack.push(val);
    }
  }

  /**
   * 出栈操作
   * @return {number} 栈顶元素
   */
  pop() {
    if (this.isEmpty()) {
      return "栈为空";
    }

    const val = this.stack.pop();

    // 如果出栈的是一个最小值，需要恢复之前的最小值
    if (val === this.getMin()) {
      this.minStack.pop();
    }

    return val;
  }

  /**
   * 查看栈顶元素
   * @return {number} 栈顶元素
   */
  top() {
    if (this.isEmpty()) {
      return "栈为空";
    }

    return this.stack[this.stack.length - 1];
  }

  /**
   * 获取栈中的最小元素
   * @return {number} 最小元素
   */
  getMin() {
    if (this.minStack.length === 0) {
      return "栈为空";
    }

    return this.minStack[this.minStack.length - 1];
  }

  /**
   * 检查栈是否为空
   * @return {boolean} 是否为空
   */
  isEmpty() {
    return this.stack.length === 0;
  }

  /**
   * 返回栈中的元素数量
   * @return {number} 元素数量
   */
  size() {
    return this.stack.length;
  }
}

// 使用示例
const minStack = new MinStack();
minStack.push(5);
console.log("当前最小值:", minStack.getMin()); // 输出: 5
minStack.push(2);
console.log("当前最小值:", minStack.getMin()); // 输出: 2
minStack.push(4);
console.log("当前最小值:", minStack.getMin()); // 输出: 2
minStack.push(1);
console.log("当前最小值:", minStack.getMin()); // 输出: 1
minStack.pop(); // 弹出1
console.log("当前最小值:", minStack.getMin()); // 输出: 2
minStack.pop(); // 弹出4
console.log("当前最小值:", minStack.getMin()); // 输出: 2
minStack.pop(); // 弹出2
console.log("当前最小值:", minStack.getMin()); // 输出: 5
```

**算法分析**：

- 时间复杂度：
  - push: O(1)
  - pop: O(1)
  - top: O(1)
  - getMin: O(1)
- 空间复杂度：O(n)，最坏情况下minStack也需要存储n个元素

**优化方案**：
为了节省空间，可以在minStack中只存储最小值的索引，而不是值本身。另一种优化是只存储元素与当前最小值的差值，这样可以进一步减少空间使用：

```javascript
/**
 * @description 空间优化的最小栈实现
 */
class OptimizedMinStack {
  constructor() {
    this.stack = [];
    this.minValue = Infinity;
  }

  push(val) {
    // 如果栈为空，直接入栈并更新最小值
    if (this.isEmpty()) {
      this.stack.push(0);
      this.minValue = val;
      return;
    }

    // 计算与当前最小值的差值
    const diff = val - this.minValue;

    // 入栈差值
    this.stack.push(diff);

    // 如果新元素更小，更新最小值
    if (diff < 0) {
      this.minValue = val;
    }
  }

  pop() {
    if (this.isEmpty()) {
      return "栈为空";
    }

    const diff = this.stack.pop();
    const prevMin = this.minValue;

    // 如果出栈的是一个最小值，需要恢复之前的最小值
    if (diff < 0) {
      this.minValue = prevMin - diff;
      return prevMin;
    }

    return prevMin + diff;
  }

  top() {
    if (this.isEmpty()) {
      return "栈为空";
    }

    const diff = this.stack[this.stack.length - 1];

    // 如果栈顶的差值小于0，栈顶元素就是最小值
    if (diff < 0) {
      return this.minValue;
    }

    // 否则，栈顶元素 = 最小值 + 差值
    return this.minValue + diff;
  }

  getMin() {
    if (this.isEmpty()) {
      return "栈为空";
    }

    return this.minValue;
  }

  isEmpty() {
    return this.stack.length === 0;
  }
}
```

**应用场景**：

1. **股票价格跟踪**：跟踪历史最低价格
2. **温度监控系统**：记录最低温度
3. **游戏中的分数记录**：记录最低分
4. **缓存淘汰算法**：实现LFU(最不经常使用)缓存策略
5. **开发工具中的表达式求值**：计算表达式中的最小值

**面试提示**：

- 理解辅助栈的作用是跟踪"当前状态下的最小值"
- 注意处理最小值出栈的情况
- 思考如何处理重复的最小值（如当前实现中使用了<=而不是<）
- 考虑空间优化的方法，如差值法或索引法

### 6. 描述一下JavaScript的事件循环中的任务队列机制。

**答**：
JavaScript的事件循环是一个基于队列的执行模型，它使用不同的任务队列来处理同步和异步操作。这个机制是JavaScript实现单线程非阻塞执行的关键。

**JavaScript事件循环的关键组成部分**：

```javascript
/**
 * @description JavaScript事件循环和任务队列的简化模型
 */

// 模拟JS执行环境
class JavaScriptRuntime {
  constructor() {
    this.callStack = [];           // 调用栈
    this.macroTaskQueue = [];      // 宏任务队列
    this.microTaskQueue = [];      // 微任务队列
    this.executing = false;
  }

  // 执行同步代码
  executeSync(fn) {
    this.callStack.push(fn);
    fn();
    this.callStack.pop();
  }

  // 添加宏任务(如setTimeout, setInterval, I/O, UI渲染等)
  addMacroTask(fn) {
    this.macroTaskQueue.push(fn);
  }

  // 添加微任务(如Promise回调, MutationObserver等)
  addMicroTask(fn) {
    this.microTaskQueue.push(fn);
  }

  // 运行事件循环
  startEventLoop() {
    if (this.executing) return;
    this.executing = true;

    console.log("事件循环开始");

    while (this.macroTaskQueue.length > 0 || this.microTaskQueue.length > 0) {
      // 1. 执行一个宏任务
      if (this.macroTaskQueue.length > 0) {
        const macroTask = this.macroTaskQueue.shift();
        console.log("执行宏任务");
        this.executeSync(macroTask);
      }

      // 2. 执行所有微任务
      while (this.microTaskQueue.length > 0) {
        const microTask = this.microTaskQueue.shift();
        console.log("执行微任务");
        this.executeSync(microTask);
      }

      // 3. 如果需要，执行UI渲染(此处简化，不实际执行)
      console.log("UI渲染(如果需要)");
    }

    console.log("事件循环结束");
    this.executing = false;
  }
}

// 使用示例
const jsRuntime = new JavaScriptRuntime();

// 同步代码
jsRuntime.executeSync(() => {
  console.log("同步代码1执行");

  // 添加宏任务(如setTimeout)
  jsRuntime.addMacroTask(() => {
    console.log("宏任务1执行");

    // 在宏任务中添加微任务
    jsRuntime.addMicroTask(() => {
      console.log("宏任务1中的微任务执行");
    });
  });

  // 添加微任务(如Promise.then)
  jsRuntime.addMicroTask(() => {
    console.log("微任务1执行");

    // 在微任务中添加宏任务
    jsRuntime.addMacroTask(() => {
      console.log("微任务1中的宏任务执行");
    });
  });

  console.log("同步代码2执行");
});

// 启动事件循环
jsRuntime.startEventLoop();

// 输出顺序:
// 同步代码1执行
// 同步代码2执行
// 事件循环开始
// 执行宏任务
// 宏任务1执行
// 执行微任务
// 微任务1执行
// 执行微任务
// 宏任务1中的微任务执行
// UI渲染(如果需要)
// 执行宏任务
// 微任务1中的宏任务执行
// UI渲染(如果需要)
// 事件循环结束
```

1. **调用栈(Call Stack)**：

   - 跟踪当前正在执行的函数
   - 函数调用形成一个栈结构
   - 栈为空时，事件循环才会处理任务队列
2. **任务队列(Task Queues)**：

   - **宏任务队列(Macro Task Queue)**：处理setTimeout、setInterval、I/O、UI渲染等
   - **微任务队列(Micro Task Queue)**：处理Promise回调、MutationObserver等
   - 微任务优先级高于宏任务
3. **事件循环(Event Loop)**：

   - 持续检查调用栈和任务队列
   - 当调用栈为空时，按顺序处理任务

**事件循环的执行过程**：

1. 执行同步代码(主线程代码)，同步代码进入调用栈立即执行
2. 执行一个宏任务(如果有)
3. 执行所有当前微任务
4. 如果需要，进行UI渲染
5. 回到步骤2，循环进行

**常见的宏任务和微任务**：

| 宏任务(Macro Task)    | 微任务(Micro Task)         |
| --------------------- | -------------------------- |
| setTimeout            | Promise.then/catch/finally |
| setInterval           | MutationObserver           |
| I/O操作               | queueMicrotask()           |
| requestAnimationFrame | process.nextTick (Node.js) |
| script标签整体代码    |                            |
| 事件回调函数          |                            |

**实际应用示例**：

```javascript
console.log('1. 同步代码开始');

setTimeout(() => {
  console.log('2. 第一个宏任务执行');

  new Promise(resolve => {
    console.log('3. 宏任务中的同步代码');
    resolve();
  }).then(() => {
    console.log('4. 宏任务产生的微任务');
  });
}, 0);

new Promise(resolve => {
  console.log('5. 同步代码中的Promise');
  resolve();
}).then(() => {
  console.log('6. 第一个微任务');

  setTimeout(() => {
    console.log('7. 微任务中注册的宏任务');
  }, 0);
}).then(() => {
  console.log('8. 第二个微任务');
});

console.log('9. 同步代码结束');

// 输出顺序:
// 1. 同步代码开始
// 5. 同步代码中的Promise
// 9. 同步代码结束
// 6. 第一个微任务
// 8. 第二个微任务
// 2. 第一个宏任务执行
// 3. 宏任务中的同步代码
// 4. 宏任务产生的微任务
// 7. 微任务中注册的宏任务
```

**在前端开发中的应用**：

1. **性能优化**：理解任务优先级，优化代码执行顺序
2. **防止页面卡顿**：将大计算量任务拆分为小任务，避免长时间占用主线程
3. **动画流畅度**：合理使用requestAnimationFrame实现流畅动画
4. **异步操作控制**：使用Promise和微任务控制异步操作的执行顺序

**浏览器与Node.js的事件循环差异**：
浏览器和Node.js的事件循环有一些实现差异，特别是在任务执行顺序上。Node.js在新版本中逐渐靠拢浏览器的实现。

## 面试常见问题

### 1. 栈和队列的主要区别是什么？

**答**：
栈和队列是两种基本的数据结构，它们的主要区别在于元素的插入和删除方式：

```javascript
/**
 * @description 栈和队列的区别演示
 */
// 栈 - 后进先出(LIFO)
const stack = [];
stack.push(1); // 入栈[1]
stack.push(2); // 入栈[1,2]
stack.push(3); // 入栈[1,2,3]
console.log(stack.pop()); // 出栈 3
console.log(stack.pop()); // 出栈 2
console.log(stack.pop()); // 出栈 1

// 队列 - 先进先出(FIFO)
const queue = [];
queue.push(1); // 入队[1]
queue.push(2); // 入队[1,2]
queue.push(3); // 入队[1,2,3]
console.log(queue.shift()); // 出队 1
console.log(queue.shift()); // 出队 2
console.log(queue.shift()); // 出队 3
```

**区别对比表**：

| 特性       | 栈                             | 队列                             |
| ---------- | ------------------------------ | -------------------------------- |
| 操作原则   | 后进先出(LIFO)                 | 先进先出(FIFO)                   |
| 添加位置   | 栈顶(顶部)                     | 队尾(尾部)                       |
| 删除位置   | 栈顶(顶部)                     | 队首(头部)                       |
| JS数组方法 | push/pop                       | push/shift 或 unshift/pop        |
| 访问限制   | 只能访问栈顶元素               | 只能访问队首元素                 |
| 内存分配   | 连续内存区域                   | 连续或非连续内存区域             |
| 常见应用   | 函数调用、表达式求值、撤销操作 | 消息队列、事件处理、广度优先搜索 |

**性能考量**：

- 栈的所有操作通常为O(1)时间复杂度
- 队列使用数组实现时，dequeue操作(shift)为O(n)，因为需要移动所有元素
- 使用链表或对象实现队列可以优化dequeue为O(1)

**实际应用对比**：
在前端开发中，栈常用于处理需要回溯的场景(如路由历史)，而队列常用于处理按顺序执行的任务(如事件循环)。

2. 如何使用两个队列实现一个栈？
3. 什么是优先队列？它与普通队列有什么区别？
4. 如何实现一个支持获取最小元素的栈？
5. 描述一下JavaScript的事件循环中的任务队列机制。
6. 如何使用栈来检查括号是否匹配？
7. 什么是双端队列？它有哪些应用场景？
8. 如何实现一个循环队列？
9. 在前端开发中，栈和队列有哪些实际应用？

## 学习资源

- [MDN Web Docs - Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) - 用于实现栈和队列的数组方法
- [JavaScript数据结构 - 栈与队列](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures) - GitHub上的JS实现
- [LeetCode栈题集](https://leetcode.com/tag/stack/) - 栈相关算法练习
- [LeetCode队列题集](https://leetcode.com/tag/queue/) - 队列相关算法练习
- [前端进阶之道 - 数据结构](https://juejin.cn/post/6844903919722692621) - 前端视角的栈和队列讲解
- [JavaScript事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop) - 理解JavaScript中的任务队列

### 7. 如何使用栈来检查括号是否匹配？

**答**：
括号匹配是栈的经典应用之一。基本思路是遍历字符串，遇到左括号时将其推入栈中，遇到右括号时检查栈顶元素是否是对应的左括号，如果是则弹出栈顶元素，否则返回不匹配。最后检查栈是否为空，如果为空则所有括号都匹配。

```javascript
/**
 * @description 使用栈检查括号是否匹配
 * @param {string} s - 包含括号的字符串
 * @return {boolean} 是否匹配
 */
function isValidParentheses(s) {
  // 创建一个存储左括号的栈
  const stack = [];

  // 创建括号映射
  const bracketMap = {
    '(': ')',
    '[': ']',
    '{': '}'
  };

  // 遍历字符串
  for (let i = 0; i < s.length; i++) {
    const char = s[i];

    // 如果是左括号，推入栈中
    if (bracketMap[char]) {
      stack.push(char);
    } else {
      // 如果是右括号，检查栈顶元素
      const topBracket = stack.pop();

      // 如果栈为空或栈顶括号与当前右括号不匹配，返回false
      if (bracketMap[topBracket] !== char) {
        return false;
      }
    }
  }

  // 最后检查栈是否为空，为空则所有括号都匹配
  return stack.length === 0;
}

// 测试用例
console.log(isValidParentheses("()")); // 输出: true
console.log(isValidParentheses("()[]{}")); // 输出: true
console.log(isValidParentheses("(]")); // 输出: false
console.log(isValidParentheses("([)]")); // 输出: false
console.log(isValidParentheses("{[]}")); // 输出: true
console.log(isValidParentheses("")); // 输出: true
console.log(isValidParentheses("(((")); // 输出: false

// 执行过程演示 "([])"：
// 1. 遇到'('，入栈 -> 栈:[']
// 2. 遇到'['，入栈 -> 栈:['(', '[']
// 3. 遇到']'，检查栈顶'['，匹配，出栈 -> 栈:['(']
// 4. 遇到')'，检查栈顶'('，匹配，出栈 -> 栈:[]
// 5. 字符串结束，栈为空，返回true
```

**算法分析**：

- 时间复杂度：O(n)，其中n是字符串长度，只需遍历一次字符串
- 空间复杂度：O(n)，最坏情况下，栈中可能存储近一半的字符串长度(全是左括号)

**扩展应用**：

1. **支持多种括号类型**

```javascript
/**
 * @description 支持多种括号类型的匹配检查
 * @param {string} s - 包含括号的字符串
 * @return {boolean} 是否匹配
 */
function isValidMultiBrackets(s) {
  const stack = [];
  const openBrackets = ['(', '[', '{', '<'];
  const closeBrackets = [')', ']', '}', '>'];

  for (let i = 0; i < s.length; i++) {
    const char = s[i];

    // 检查是否是左括号
    const openIndex = openBrackets.indexOf(char);
    if (openIndex !== -1) {
      stack.push(openIndex);
      continue;
    }

    // 检查是否是右括号
    const closeIndex = closeBrackets.indexOf(char);
    if (closeIndex !== -1) {
      // 如果栈为空或栈顶与当前右括号不匹配
      if (stack.length === 0 || stack.pop() !== closeIndex) {
        return false;
      }
    }
  }

  return stack.length === 0;
}
```

2. **检查HTML/XML标签是否匹配**

```javascript
/**
 * @description 简化版HTML标签匹配检查
 * @param {string} html - HTML字符串
 * @return {boolean} 是否匹配
 */
function isValidHTML(html) {
  const stack = [];
  const regex = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
  let match;

  while ((match = regex.exec(html)) !== null) {
    const tag = match[0];
    const tagName = match[1];

    // 检查是否是自闭合标签
    if (tag.indexOf('/>') > -1) {
      continue;
    }

    // 检查是否是闭合标签
    if (tag.indexOf('</') > -1) {
      // 检查栈顶标签是否匹配
      if (stack.length === 0 || stack.pop() !== tagName) {
        return false;
      }
    } else {
      // 开始标签，推入栈中
      stack.push(tagName);
    }
  }

  return stack.length === 0;
}

// 测试用例
const html = '<div><p>Hello <span>World</span></p></div>';
console.log(isValidHTML(html)); // 输出: true

const invalidHTML = '<div><p>Hello <span>World</div></p>';
console.log(isValidHTML(invalidHTML)); // 输出: false
```

3. **带有优先级的表达式检查**

```javascript
/**
 * @description 检查表达式的括号是否匹配并考虑优先级
 * @param {string} expression - 数学表达式
 * @return {object} 匹配结果和嵌套层级信息
 */
function checkExpressionBrackets(expression) {
  const stack = [];
  let maxDepth = 0;
  let currentDepth = 0;

  for (let i = 0; i < expression.length; i++) {
    const char = expression[i];

    if (char === '(') {
      stack.push(char);
      currentDepth++;
      maxDepth = Math.max(maxDepth, currentDepth);
    } else if (char === ')') {
      if (stack.length === 0 || stack.pop() !== '(') {
        return { isValid: false, maxDepth: 0 };
      }
      currentDepth--;
    }
  }

  return {
    isValid: stack.length === 0,
    maxDepth: maxDepth
  };
}

// 测试用例
console.log(checkExpressionBrackets("((1+2)*(3+4))"));
// 输出: { isValid: true, maxDepth: 2 }

console.log(checkExpressionBrackets("((1+2)*(3+4)"));
// 输出: { isValid: false, maxDepth: 2 }
```

**实际应用场景**：

1. **代码编辑器中的语法检查**：检查程序中的括号、引号是否配对
2. **HTML/XML解析器**：验证标签是否正确闭合
3. **数学表达式求值**：验证表达式的括号是否有效
4. **编译器的语法分析**：检查代码块的边界
5. **文本编辑器的自动补全**：输入左括号时自动添加右括号

**面试提示**：

- 理解栈如何用于跟踪"最近的未匹配元素"
- 考虑边界情况：空字符串、只有左括号或只有右括号的情况
- 检查是否掌握栈的基本操作：push、pop、peek
- 思考如何扩展到更复杂的场景，如HTML标签匹配

### 8. 什么是双端队列？它有哪些应用场景？

**答**：
双端队列(Deque，Double-Ended Queue)是一种允许在两端添加和删除元素的特殊队列。它结合了栈和队列的特性，既可以遵循先进先出(FIFO)原则，也可以遵循后进先出(LIFO)原则。

```javascript
/**
 * @description 双端队列的实现
 */
class Deque {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  /**
   * 在队首添加元素
   * @param {any} element - 要添加的元素
   */
  addFront(element) {
    // 如果队列为空，使用addBack方法添加
    if (this.isEmpty()) {
      this.addBack(element);
    } else {
      // 减少frontIndex并添加元素
      this.frontIndex--;
      this.items[this.frontIndex] = element;
    }
  }

  /**
   * 在队尾添加元素
   * @param {any} element - 要添加的元素
   */
  addBack(element) {
    this.items[this.backIndex] = element;
    this.backIndex++;
  }

  /**
   * 从队首移除元素
   * @return {any} 队首元素
   */
  removeFront() {
    if (this.isEmpty()) {
      return undefined;
    }

    const result = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    return result;
  }

  /**
   * 从队尾移除元素
   * @return {any} 队尾元素
   */
  removeBack() {
    if (this.isEmpty()) {
      return undefined;
    }

    this.backIndex--;
    const result = this.items[this.backIndex];
    delete this.items[this.backIndex];
    return result;
  }

  /**
   * 查看队首元素
   * @return {any} 队首元素
   */
  peekFront() {
    if (this.isEmpty()) {
      return undefined;
    }

    return this.items[this.frontIndex];
  }

  /**
   * 查看队尾元素
   * @return {any} 队尾元素
   */
  peekBack() {
    if (this.isEmpty()) {
      return undefined;
    }

    return this.items[this.backIndex - 1];
  }

  /**
   * 检查队列是否为空
   * @return {boolean} 是否为空
   */
  isEmpty() {
    return this.backIndex - this.frontIndex === 0;
  }

  /**
   * 返回队列中的元素数量
   * @return {number} 元素数量
   */
  size() {
    return this.backIndex - this.frontIndex;
  }

  /**
   * 清空队列
   */
  clear() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  /**
   * 将队列转为字符串
   * @return {string} 队列的字符串表示
   */
  toString() {
    if (this.isEmpty()) {
      return '';
    }

    let objString = `${this.items[this.frontIndex]}`;

    for (let i = this.frontIndex + 1; i < this.backIndex; i++) {
      objString = `${objString}, ${this.items[i]}`;
    }

    return objString;
  }
}

// 使用示例
const deque = new Deque();

// 入队操作
deque.addBack('John');
deque.addBack('Jack');
console.log(deque.toString()); // 输出: John, Jack

// 前端入队
deque.addFront('Camila');
console.log(deque.toString()); // 输出: Camila, John, Jack

// 查看两端元素
console.log(deque.peekFront()); // 输出: Camila
console.log(deque.peekBack());  // 输出: Jack

// 移除两端元素
console.log(deque.removeFront()); // 输出: Camila
console.log(deque.removeBack());  // 输出: Jack
console.log(deque.toString());    // 输出: John
```

**双端队列的特点**：

1. **灵活性**：同时兼具栈和队列的特性
2. **操作丰富**：支持在两端添加和删除元素
3. **多样性应用**：可用于需要从两端操作的场景
4. **实现高效**：使用对象实现的双端队列所有操作都是O(1)时间复杂度

**双端队列的应用场景**：

1. **浏览器历史**：同时支持前进和后退操作

   ```javascript
   class BrowserHistory {
     constructor(homepage) {
       this.history = new Deque();
       this.history.addBack(homepage);
       this.current = 0;
     }

     visit(url) {
       // 清除当前页面之后的所有历史
       while (this.history.size() > this.current + 1) {
         this.history.removeBack();
       }

       // 添加新页面
       this.history.addBack(url);
       this.current++;
     }

     back() {
       if (this.current > 0) {
         this.current--;
         return this.getCurrentPage();
       }
       return this.getCurrentPage();
     }

     forward() {
       if (this.current < this.history.size() - 1) {
         this.current++;
         return this.getCurrentPage();
       }
       return this.getCurrentPage();
     }

     getCurrentPage() {
       // 简化实现，实际需要更复杂的逻辑
       let i = 0;
       let page;
       const tempDeque = new Deque();

       while (i <= this.current) {
         page = this.history.removeFront();
         tempDeque.addBack(page);
         i++;
       }

       // 还原历史
       while (!tempDeque.isEmpty()) {
         this.history.addFront(tempDeque.removeBack());
       }

       return page;
     }
   }
   ```
2. **工作窃取算法(Work Stealing)**：多线程任务调度

   ```javascript
   // 简化的工作窃取调度器示例
   class WorkStealingScheduler {
     constructor(threadCount) {
       this.queues = Array(threadCount).fill().map(() => new Deque());
     }

     // 添加任务到线程的队列
     schedule(threadId, task) {
       this.queues[threadId].addBack(task);
     }

     // 线程执行任务
     executeTask(threadId) {
       // 优先从自己的队列前端取任务
       if (!this.queues[threadId].isEmpty()) {
         return this.queues[threadId].removeFront();
       }

       // 如果自己的队列为空，从其他线程的队列尾部"窃取"任务
       for (let i = 0; i < this.queues.length; i++) {
         if (i !== threadId && !this.queues[i].isEmpty()) {
           return this.queues[i].removeBack();
         }
       }

       return null; // 没有可执行的任务
     }
   }
   ```
3. **滑动窗口问题**：跟踪窗口内的最大/最小值

   ```javascript
   /**
    * @description 滑动窗口最大值
    * @param {number[]} nums - 数组
    * @param {number} k - 窗口大小
   ```

* @return {number[]} 每个窗口的最大值
  */
  function maxSlidingWindow(nums, k) {
  const result = [];
  const deque = []; // 存储索引

for (let i = 0; i < nums.length; i++) {
// 移除所有小于当前元素的值(从右侧/尾部移除)
while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
deque.pop();
}

// 添加当前元素索引到右侧/尾部
deque.push(i);

// 移除超出窗口范围的元素(从左侧/头部移除)
if (deque[0] <= i - k) {
deque.shift();
}

// 当窗口形成后，记录最大值
if (i >= k - 1) {
result.push(nums[deque[0]]);
}
}

return result;
}

// 测试
console.log(maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3));
// 输出: [3,3,5,5,6,7]

```

4. **回文字符串检查**：从两端向中间比较字符
```javascript
/**
 * @description 检查字符串是否为回文
 * @param {string} str - 输入字符串
 * @return {boolean} 是否为回文
 */
function isPalindrome(str) {
  const deque = new Deque();

  // 将所有字符放入双端队列
  for (let i = 0; i < str.length; i++) {
    deque.addBack(str[i]);
  }

  // 从两端比较字符
  while (deque.size() > 1) {
    if (deque.removeFront() !== deque.removeBack()) {
      return false;
    }
  }

  return true;
}

console.log(isPalindrome('racecar')); // 输出: true
console.log(isPalindrome('hello'));   // 输出: false
```

5. **任务调度**：支持优先执行和延迟执行
   ```javascript
   class TaskScheduler {
     constructor() {
       this.regularTasks = new Deque(); // 常规任务
       this.priorityTasks = new Deque(); // 优先任务
     }

     addTask(task, isPriority = false) {
       if (isPriority) {
         this.priorityTasks.addFront(task);
       } else {
         this.regularTasks.addBack(task);
       }
     }

     executeNext() {
       // 优先执行优先任务
       if (!this.priorityTasks.isEmpty()) {
         return this.priorityTasks.removeFront();
       }

       // 如果没有优先任务，执行常规任务
       if (!this.regularTasks.isEmpty()) {
         return this.regularTasks.removeFront();
       }

       return null; // 没有可执行的任务
     }
   }
   ```

**双端队列在JavaScript中的原生支持**：
JavaScript的Array类型本身就可以作为双端队列使用：

```javascript
const dequeUsingArray = [];

// 队尾操作
dequeUsingArray.push('A'); // 添加到队尾
dequeUsingArray.pop();     // 从队尾移除

// 队首操作
dequeUsingArray.unshift('B'); // 添加到队首
dequeUsingArray.shift();      // 从队首移除
```

但需要注意，数组的 `unshift`和 `shift`操作是O(n)时间复杂度，对于大型双端队列，使用自定义实现可能更高效。

**性能考虑**：

- 使用对象实现的双端队列所有操作都是O(1)时间复杂度
- 使用数组实现时，队首操作(unshift/shift)为O(n)
- 在需要频繁在两端操作的场景，双端队列比单向队列或栈更高效

### 9. 如何实现一个循环队列？

**答**：
循环队列是一种基于数组的队列实现，当队尾指针到达数组末尾时，会绕回到数组开头。这种设计可以有效利用数组空间，避免频繁的元素移动，使得所有操作的时间复杂度都为O(1)。

```javascript
/**
 * @description 循环队列的实现
 */
class CircularQueue {
  /**
   * 初始化循环队列
   * @param {number} capacity - 队列容量
   */
  constructor(capacity) {
    this.items = new Array(capacity);
    this.capacity = capacity;
    this.currentLength = 0;
    this.front = -1; // 队首指针
    this.rear = -1;  // 队尾指针
  }

  /**
   * 判断队列是否已满
   * @return {boolean} 是否已满
   */
  isFull() {
    return this.currentLength === this.capacity;
  }

  /**
   * 判断队列是否为空
   * @return {boolean} 是否为空
   */
  isEmpty() {
    return this.currentLength === 0;
  }

  /**
   * 入队操作
   * @param {any} element - 入队元素
   * @return {boolean} 是否成功入队
   */
  enqueue(element) {
    if (this.isFull()) {
      return false;
    }

    // 如果队列为空，初始化front指针
    if (this.isEmpty()) {
      this.front = 0;
    }

    // 更新rear指针，注意使用模运算实现循环
    this.rear = (this.rear + 1) % this.capacity;
    this.items[this.rear] = element;
    this.currentLength++;
    return true;
  }

  /**
   * 出队操作
   * @return {any} 出队元素
   */
  dequeue() {
    if (this.isEmpty()) {
      return null;
    }

    const item = this.items[this.front];
    this.items[this.front] = null; // 可选，用于GC
    this.front = (this.front + 1) % this.capacity;
    this.currentLength--;

    // 如果队列变为空，重置front和rear指针
    if (this.isEmpty()) {
      this.front = -1;
      this.rear = -1;
    }

    return item;
  }

  /**
   * 查看队首元素
   * @return {any} 队首元素
   */
  peek() {
    if (this.isEmpty()) {
      return null;
    }

    return this.items[this.front];
  }

  /**
   * 返回队列中的元素数量
   * @return {number} 元素数量
   */
  size() {
    return this.currentLength;
  }

  /**
   * 打印队列内容
   */
  print() {
    if (this.isEmpty()) {
      console.log('队列为空');
      return;
    }

    let i = this.front;
    let str = '';

    // 从front到rear遍历所有元素
    do {
      str += this.items[i] + ' ';
      i = (i + 1) % this.capacity;
    } while (i !== (this.rear + 1) % this.capacity);

    console.log(str.trim());
  }
}

// 使用示例
const circularQueue = new CircularQueue(5);

// 入队操作
console.log(circularQueue.enqueue(10)); // 输出: true
console.log(circularQueue.enqueue(20)); // 输出: true
console.log(circularQueue.enqueue(30)); // 输出: true
console.log(circularQueue.enqueue(40)); // 输出: true

// 打印队列内容
circularQueue.print(); // 输出: 10 20 30 40

// 出队操作
console.log(circularQueue.dequeue()); // 输出: 10
console.log(circularQueue.dequeue()); // 输出: 20

// 打印队列内容
circularQueue.print(); // 输出: 30 40

// 再次入队，测试循环特性
console.log(circularQueue.enqueue(50)); // 输出: true
console.log(circularQueue.enqueue(60)); // 输出: true
console.log(circularQueue.enqueue(70)); // 输出: false (队列已满)

// 打印最终队列内容
circularQueue.print(); // 输出: 30 40 50 60

// 演示循环使用数组空间
console.log(circularQueue.dequeue()); // 输出: 30
console.log(circularQueue.dequeue()); // 输出: 40
console.log(circularQueue.enqueue(80)); // 输出: true
console.log(circularQueue.enqueue(90)); // 输出: true

// 此时数组中的数据分布: [80, 90, _, 50, 60]
// front指向索引2，rear指向索引1
circularQueue.print(); // 输出: 50 60 80 90
```

**循环队列的工作原理和实现细节**：

1. **循环设计**：
   使用模运算(`%`)实现循环，当指针到达数组末尾时自动回到开头：

   ```javascript
   // 更新指针
   this.rear = (this.rear + 1) % this.capacity;
   this.front = (this.front + 1) % this.capacity;
   ```
2. **判满和判空**：

   - 方法一：使用一个 `currentLength`变量跟踪元素数量
   - 方法二：保持一个空位，当 `(rear + 1) % capacity === front`时队列已满
3. **指针管理**：

   - 初始状态：`front = rear = -1`
   - 队列为空时：`front = rear = -1`
   - 队列中有元素时：`front`指向队首，`rear`指向队尾
4. **元素访问**：

   - 队首元素：`items[front]`
   - 队尾元素：`items[rear]`

**算法分析**：

- **时间复杂度**：
  - enqueue: O(1)
  - dequeue: O(1)
  - peek: O(1)
  - isEmpty/isFull: O(1)

// ... existing code ...

### 10. 在前端开发中，栈和队列有哪些实际应用？

**答**：
栈和队列作为基础数据结构，在前端开发中有广泛的应用。它们不仅用于解决特定算法问题，也是许多前端功能和框架设计的核心部分。

#### 栈在前端开发中的应用

1. **路由历史管理**

```javascript
/**
 * @description 简化版的路由历史管理器
 */
class RouterHistory {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
  }

  /**
   * 导航到新页面
   * @param {string} path - 页面路径
   */
  push(path) {
    // 导航到新页面时，清除当前页面之后的所有历史
    if (this.currentIndex < this.history.length - 1) {
      this.history.splice(this.currentIndex + 1);
    }

    // 添加新页面到历史栈
    this.history.push(path);
    this.currentIndex++;

    // 实际应用中，这里会触发页面渲染
    console.log(`导航到: ${path}`);
  }

  /**
   * 回退到上一页
   * @return {string|null} 上一页路径或null
   */
  back() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      const path = this.history[this.currentIndex];

      // 实际应用中，这里会触发页面渲染
      console.log(`回退到: ${path}`);
      return path;
    }

    return null;
  }

  /**
   * 前进到下一页
   * @return {string|null} 下一页路径或null
   */
  forward() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      const path = this.history[this.currentIndex];

      // 实际应用中，这里会触发页面渲染
      console.log(`前进到: ${path}`);
      return path;
    }

    return null;
  }
}

// 使用示例
const router = new RouterHistory();
router.push('/home');
router.push('/about');
router.push('/contact');
router.back();      // 回退到 /about
router.back();      // 回退到 /home
router.forward();   // 前进到 /about
router.push('/products'); // 导航到 /products，此时历史为 ['/home', '/about', '/products']
```

2. **撤销/重做功能**

```javascript
/**
 * @description 编辑器撤销/重做管理器
 */
class UndoRedoManager {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
  }

  /**
   * 执行操作并记录
   * @param {Object} action - 操作对象
   */
  execute(action) {
    // 执行操作
    action.execute();

    // 记录操作到撤销栈
    this.undoStack.push(action);

    // 清空重做栈
    this.redoStack = [];
  }

  /**
   * 撤销上一次操作
   */
  undo() {
    if (this.undoStack.length === 0) {
      console.log('没有可撤销的操作');
      return;
    }

    // 从撤销栈中弹出最后一个操作
    const action = this.undoStack.pop();

    // 执行撤销
    action.undo();

    // 将操作添加到重做栈
    this.redoStack.push(action);
  }

  /**
   * 重做上一次被撤销的操作
   */
  redo() {
    if (this.redoStack.length === 0) {
      console.log('没有可重做的操作');
      return;
    }

    // 从重做栈中弹出最后一个操作
    const action = this.redoStack.pop();

    // 执行操作
    action.execute();

    // 将操作添加回撤销栈
    this.undoStack.push(action);
  }
}

// 文本编辑操作示例
class TextEditAction {
  constructor(editor, text, position) {
    this.editor = editor;
    this.text = text;
    this.position = position;
    this.oldText = editor.getTextAt(position, text.length);
  }

  execute() {
    this.editor.replaceText(this.position, this.text);
  }

  undo() {
    this.editor.replaceText(this.position, this.oldText);
  }
}

// 简化的编辑器
class Editor {
  constructor() {
    this.content = '';
    this.undoRedoManager = new UndoRedoManager();
  }

  getTextAt(position, length) {
    return this.content.substr(position, length);
  }

  replaceText(position, text) {
    this.content = this.content.substring(0, position) +
                   text +
                   this.content.substring(position + text.length);
    console.log(`编辑器内容: "${this.content}"`);
  }

  type(text, position) {
    const action = new TextEditAction(this, text, position);
    this.undoRedoManager.execute(action);
  }

  undo() {
    this.undoRedoManager.undo();
  }

  redo() {
    this.undoRedoManager.redo();
  }
}

// 使用示例
const editor = new Editor();
editor.type('Hello', 0);       // 编辑器内容: "Hello"
editor.type(' World', 5);      // 编辑器内容: "Hello World"
editor.undo();                 // 编辑器内容: "Hello"
editor.redo();                 // 编辑器内容: "Hello World"
editor.type('!', 11);          // 编辑器内容: "Hello World!"
editor.undo();                 // 编辑器内容: "Hello World"
```

3. **DOM节点遍历与操作**

```javascript
/**
 * @description 深度优先遍历DOM树
 * @param {HTMLElement} rootNode - 根节点
 * @param {Function} callback - 回调函数
 */
function traverseDOMWithStack(rootNode, callback) {
  const stack = [rootNode];

  while (stack.length > 0) {
    const currentNode = stack.pop();

    // 处理当前节点
    callback(currentNode);

    // 将子节点按倒序入栈，以便从左到右处理
    const children = currentNode.children;
    for (let i = children.length - 1; i >= 0; i--) {
      stack.push(children[i]);
    }
  }
}

// 使用示例
// traverseDOMWithStack(document.body, node => {
//   console.log(node.tagName);
// });
```

4. **浏览器调用栈可视化**

```javascript
/**
 * @description 简单的调用栈跟踪器
 */
class CallStackTracer {
  constructor() {
    this.stack = [];
  }

  /**
   * 函数进入调用栈
   * @param {string} functionName - 函数名
   */
  enterFunction(functionName) {
    this.stack.push({
      name: functionName,
      startTime: Date.now()
    });
    this.printStack();
  }

  /**
   * 函数离开调用栈
   * @return {Object} 函数执行信息
   */
  exitFunction() {
    if (this.stack.length === 0) {
      return null;
    }

    const functionInfo = this.stack.pop();
    functionInfo.endTime = Date.now();
    functionInfo.duration = functionInfo.endTime - functionInfo.startTime;

    this.printStack();
    return functionInfo;
  }

  /**
   * 获取当前调用栈
   * @return {Array} 调用栈
   */
  getStack() {
    return this.stack.slice();
  }

  /**
   * 打印当前调用栈
   */
  printStack() {
    console.log('当前调用栈:');
    for (let i = this.stack.length - 1; i >= 0; i--) {
      console.log(`- ${this.stack[i].name}`);
    }
  }
}

// 使用示例
const tracer = new CallStackTracer();

function functionA() {
  tracer.enterFunction('functionA');
  functionB();
  tracer.exitFunction();
}

function functionB() {
  tracer.enterFunction('functionB');
  functionC();
  tracer.exitFunction();
}

function functionC() {
  tracer.enterFunction('functionC');
  // 做一些工作
  tracer.exitFunction();
}

functionA();
```

#### 队列在前端开发中的应用

1. **任务队列与异步处理**

```javascript
/**
 * @description 简单的任务队列
 */
class TaskQueue {
  constructor() {
    this.queue = [];
    this.isProcessing = false;
  }

  /**
   * 添加任务到队列
   * @param {Function} task - 任务函数
   */
  enqueue(task) {
    this.queue.push(task);

    // 如果当前没有在处理任务，开始处理
    if (!this.isProcessing) {
      this.processQueue();
    }
  }

  /**
   * 处理队列中的任务
   */
  async processQueue() {
    if (this.isProcessing || this.queue.length === 0) {
      return;
    }

    this.isProcessing = true;

    try {
      // 取出队首任务
      const task = this.queue.shift();

      // 执行任务
      await task();

      // 继续处理下一个任务
      this.isProcessing = false;
      this.processQueue();
    } catch (error) {
      console.error('任务执行错误:', error);
      this.isProcessing = false;
      this.processQueue();
    }
  }
}

// 使用示例
const tasks = new TaskQueue();

// 添加异步任务
tasks.enqueue(async () => {
  console.log('开始任务1');
  await new Promise(resolve => setTimeout(resolve, 1000));
  console.log('完成任务1');
});

tasks.enqueue(async () => {
  console.log('开始任务2');
  await new Promise(resolve => setTimeout(resolve, 500));
  console.log('完成任务2');
});

tasks.enqueue(async () => {
  console.log('开始任务3');
  throw new Error('任务3失败');
});

tasks.enqueue(async () => {
  console.log('开始任务4');
  await new Promise(resolve => setTimeout(resolve, 800));
  console.log('完成任务4');
});
```

2. **请求限流器**

```javascript
/**
 * @description API请求限流器
 */
class RequestThrottler {
  /**
   * 创建限流器
   * @param {number} maxConcurrent - 最大并发请求数
   */
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent;
    this.runningRequests = 0;
    this.queue = [];
  }

  /**
   * 发送请求
   * @param {Function} requestFn - 请求函数
   * @return {Promise} 请求结果
   */
  async sendRequest(requestFn) {
    return new Promise((resolve, reject) => {
      // 创建一个包含请求信息的对象
      const requestInfo = {
        execute: async () => {
          this.runningRequests++;

          try {
            const result = await requestFn();
            resolve(result);
          } catch (error) {
            reject(error);
          } finally {
            this.runningRequests--;
            this.processQueue();
          }
        }
      };

      // 添加到队列
      this.queue.push(requestInfo);

      // 尝试处理队列
      this.processQueue();
    });
  }

  /**
   * 处理请求队列
   */
  processQueue() {
    // 当有空闲槽位且队列中有请求时，执行请求
    while (this.runningRequests < this.maxConcurrent && this.queue.length > 0) {
      const requestInfo = this.queue.shift();
      requestInfo.execute();
    }
  }
}

// 使用示例
const throttler = new RequestThrottler(2); // 最多同时执行2个请求

// 模拟API请求
function mockRequest(id, delay) {
  return () => {
    console.log(`开始请求${id}`);
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log(`完成请求${id}`);
        resolve(`请求${id}的结果`);
      }, delay);
    });
  };
}

// 发送多个请求
async function runExample() {
  const results = await Promise.all([
    throttler.sendRequest(mockRequest(1, 1000)),
    throttler.sendRequest(mockRequest(2, 2000)),
    throttler.sendRequest(mockRequest(3, 1500)),
    throttler.sendRequest(mockRequest(4, 800)),
    throttler.sendRequest(mockRequest(5, 1200))
  ]);

  console.log('所有请求完成:', results);
}

// 运行示例
// runExample();
```

3. **事件处理与动画**

```javascript
/**
 * @description 动画队列管理器
 */
class AnimationQueue {
  constructor() {
    this.queue = [];
    this.isAnimating = false;
  }

  /**
   * 添加动画到队列
   * @param {HTMLElement} element - DOM元素
   * @param {Object} properties - 动画属性
   * @param {number} duration - 动画时长(毫秒)
   */
  animate(element, properties, duration) {
    return new Promise((resolve) => {
      this.queue.push({
        element,
        properties,
        duration,
        resolve
      });

      if (!this.isAnimating) {
        this.processNextAnimation();
      }
    });
  }

  /**
   * 处理下一个动画
   */
  processNextAnimation() {
    if (this.queue.length === 0) {
      this.isAnimating = false;
      return;
    }

    this.isAnimating = true;
    const { element, properties, duration, resolve } = this.queue.shift();

    // 简化的动画实现
    console.log(`开始动画: ${JSON.stringify(properties)}, 持续${duration}ms`);

    // 在实际应用中，这里会使用CSS transitions或requestAnimationFrame
    setTimeout(() => {
      Object.assign(element.style, properties);
      console.log('动画完成');
      resolve();

      // 处理下一个动画
      this.processNextAnimation();
    }, duration);
  }
}

// 使用示例
// const animQueue = new AnimationQueue();
// const box = document.getElementById('animationBox');

// 连续执行多个动画
// async function runAnimations() {
//   await animQueue.animate(box, { left: '200px' }, 1000);
//   await animQueue.animate(box, { top: '200px' }, 800);
//   await animQueue.animate(box, { left: '0px' }, 1200);
//   await animQueue.animate(box, { top: '0px' }, 500);
//   console.log('所有动画完成');
// }
```

4. **消息通知系统**

```javascript
/**
 * @description 通知消息管理器
 */
class NotificationManager {
  constructor(maxVisible = 3, displayTime = 3000) {
    this.queue = [];
    this.activeNotifications = [];
    this.maxVisible = maxVisible;
    this.displayTime = displayTime;
  }

  /**
   * 显示通知
   * @param {string} message - 通知内容
   * @param {string} type - 通知类型(info, success, error等)
   */
  notify(message, type = 'info') {
    const notification = { message, type };

    // 如果当前显示的通知数量小于最大值，直接显示
    if (this.activeNotifications.length < this.maxVisible) {
      this.showNotification(notification);
    } else {
      // 否则加入队列
      this.queue.push(notification);
    }
  }

  /**
   * 显示通知
   * @param {Object} notification - 通知对象
   */
  showNotification(notification) {
    // 添加到活动通知列表
    this.activeNotifications.push(notification);

    console.log(`显示${notification.type}通知: ${notification.message}`);

    // 设置定时器，在指定时间后移除通知
    setTimeout(() => {
      this.removeNotification(notification);
    }, this.displayTime);
  }

  /**
   * 移除通知
   * @param {Object} notification - 通知对象
   */
  removeNotification(notification) {
    // 从活动通知列表中移除
    const index = this.activeNotifications.indexOf(notification);
    if (index !== -1) {
      this.activeNotifications.splice(index, 1);
      console.log(`移除通知: ${notification.message}`);

      // 处理队列中的下一个通知
      if (this.queue.length > 0) {
        const nextNotification = this.queue.shift();
        this.showNotification(nextNotification);
      }
    }
  }
}

// 使用示例
const notifications = new NotificationManager(2, 2000);

// 发送多个通知
notifications.notify('操作成功!', 'success');
notifications.notify('正在加载数据...', 'info');
notifications.notify('出现错误!', 'error');       // 进入队列
notifications.notify('请检查网络连接', 'warning'); // 进入队列
```

5. **广度优先搜索 (BFS)**

```javascript
/**
 * @description 使用队列实现的广度优先DOM遍历
 * @param {HTMLElement} rootNode - 根节点
 * @param {Function} callback - 回调函数
 */
function traverseDOMWithQueue(rootNode, callback) {
  const queue = [rootNode];

  while (queue.length > 0) {
    const currentNode = queue.shift();

    // 处理当前节点
    callback(currentNode);

    // 将子节点加入队列
    const children = currentNode.children;
    for (let i = 0; i < children.length; i++) {
      queue.push(children[i]);
    }
  }
}

// 使用示例
// traverseDOMWithQueue(document.body, node => {
//   console.log(node.tagName);
// });
```

**其他前端中常见的栈和队列应用**：

1. **虚拟DOM差异算法**：使用栈跟踪DOM树的遍历
2. **JavaScript事件循环**：任务队列和微任务队列
3. **组件树递归渲染**：使用栈管理组件渲染顺序
4. **拖放操作**：使用队列管理拖放事件序列
5. **网络请求管理**：使用队列管理并发和顺序请求
6. **富文本编辑器**：使用栈管理格式化命令
7. **多级菜单**：使用栈跟踪菜单打开层级
8. **用户行为跟踪**：记录用户操作序列

**技术框架中的应用**：

1. **React Fiber架构**：使用链表和栈实现异步可中断渲染
2. **Vue NextTick**：使用队列批量处理DOM更新
3. **Redux状态管理**：使用栈实现时间旅行功能
4. **Promise链**：使用队列管理异步操作的顺序执行

**性能和优化考虑**：

1. **渲染性能**：使用任务队列分割大型计算，避免阻塞主线程
2. **内存管理**：适当清理栈和队列，避免内存泄漏
3. **用户体验**：通过优先级队列处理重要的用户交互

**面试提示**：

- 除了提供常见应用外，还可以谈论如何在自己的项目中使用栈和队列解决实际问题
- 讨论实现栈和队列时的性能考量，如操作复杂度和内存使用
- 解释如何选择适合特定场景的数据结构，如何判断该用栈还是队列

## 学习资源

- [MDN Web Docs - Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) - 用于实现栈和队列的数组方法
- [JavaScript数据结构 - 栈与队列](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures) - GitHub上的JS实现
- [LeetCode栈题集](https://leetcode.com/tag/stack/) - 栈相关算法练习
- [LeetCode队列题集](https://leetcode.com/tag/queue/) - 队列相关算法练习
- [前端进阶之道 - 数据结构](https://juejin.cn/post/6844903919722692621) - 前端视角的栈和队列讲解
- [JavaScript事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop) - 理解JavaScript中的任务队列
