# 数组常用方法

数组是JavaScript中最常用的数据结构之一，提供了丰富的内置方法用于数据操作。掌握这些方法可以让我们更高效地处理数据，减少代码量，提高开发效率。

## 概念介绍

JavaScript数组是一种特殊的对象，用于存储多个值。与其他语言不同，JavaScript数组可以存储不同类型的元素，且数组长度是动态可变的。

```javascript
/**
 * JavaScript数组的基本创建方式
 */
// 字面量方式
const fruits = ['apple', 'banana', 'orange'];

// 构造函数方式
const numbers = new Array(1, 2, 3, 4, 5);

// 创建指定长度的空数组
const emptyArray = new Array(5); // 长度为5的空数组

// Array.of() - ES6方法，创建包含所有参数的数组
const mixedArray = Array.of(1, 'two', true, null);
console.log(mixedArray); // [1, 'two', true, null]

// Array.from() - ES6方法，从类数组对象或可迭代对象创建数组
const arrayLikeObj = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
const fromArray = Array.from(arrayLikeObj);
console.log(fromArray); // ['a', 'b', 'c']
```

## 数组基本操作方法

### 1. 添加/删除元素

#### push() - 末尾添加元素

```javascript
/**
 * @description 向数组末尾添加一个或多个元素，并返回新的长度
 * @param {...any} elements - 要添加的元素
 * @return {number} 数组的新长度
 */
const colors = ['red', 'blue'];
const newLength = colors.push('green', 'yellow');
console.log(colors); // ['red', 'blue', 'green', 'yellow']
console.log(newLength); // 4
```

#### pop() - 末尾删除元素

```javascript
/**
 * @description 移除数组最后一个元素并返回该元素
 * @return {any} 被移除的元素
 */
const plants = ['broccoli', 'cauliflower', 'cabbage', 'kale'];
const removedItem = plants.pop();
console.log(plants); // ['broccoli', 'cauliflower', 'cabbage']
console.log(removedItem); // 'kale'
```

#### unshift() - 开头添加元素

```javascript
/**
 * @description 向数组开头添加一个或多个元素，并返回新的长度
 * @param {...any} elements - 要添加的元素
 * @return {number} 数组的新长度
 */
const numbers = [3, 4, 5];
const newLength = numbers.unshift(1, 2);
console.log(numbers); // [1, 2, 3, 4, 5]
console.log(newLength); // 5
```

#### shift() - 开头删除元素

```javascript
/**
 * @description 移除数组第一个元素并返回该元素
 * @return {any} 被移除的元素
 */
const fruits = ['apple', 'banana', 'cherry'];
const firstFruit = fruits.shift();
console.log(fruits); // ['banana', 'cherry']
console.log(firstFruit); // 'apple'
```

#### splice() - 任意位置添加/删除元素

```javascript
/**
 * @description 通过删除、替换或添加元素来修改数组
 * @param {number} start - 修改的起始位置
 * @param {number} [deleteCount] - 要删除的元素数量
 * @param {...any} [items] - 要添加的新元素
 * @return {Array} 包含被删除元素的数组
 */
const months = ['Jan', 'March', 'April', 'June'];

// 在索引1处插入一个元素   在原索引之前插入一个元素
months.splice(1, 0, 'Feb');
console.log(months); // ['Jan', 'Feb', 'March', 'April', 'June']

// 替换索引4处的元素
months.splice(4, 1, 'May');
console.log(months); // ['Jan', 'Feb', 'March', 'April', 'May']

// 从索引2开始删除2个元素
const deleted = months.splice(2, 2);
console.log(months); // ['Jan', 'Feb', 'May']
console.log(deleted); // ['March', 'April']
```

### 2. 查找和访问元素

#### indexOf() - 查找元素位置

```javascript
/**
 * @description 返回数组中指定元素第一次出现的索引，未找到则返回-1
 * @param {any} searchElement - 要查找的元素
 * @param {number} [fromIndex=0] - 开始搜索的索引
 * @return {number} 元素的索引或-1
 */
const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];
console.log(beasts.indexOf('bison')); // 1
console.log(beasts.indexOf('bison', 2)); // 4 (从索引2开始搜索)
console.log(beasts.indexOf('giraffe')); // -1 (未找到)
```

#### lastIndexOf() - 从后向前查找

```javascript
/**
 * @description 返回数组中指定元素最后一次出现的索引，未找到则返回-1
 * @param {any} searchElement - 要查找的元素
 * @param {number} [fromIndex=array.length-1] - 开始搜索的索引（反向）
 * @return {number} 元素的索引或-1
 */
const numbers = [2, 5, 9, 2];
console.log(numbers.lastIndexOf(2)); // 3
console.log(numbers.lastIndexOf(7)); // -1
console.log(numbers.lastIndexOf(2, 2)); // 0 (从索引2开始反向搜索)
```

#### find() - 查找满足条件的元素

```javascript
/**
 * @description 返回数组中满足提供的测试函数的第一个元素的值
 * @param {Function} callbackFn - 测试函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {any} 找到的元素，否则返回undefined
 */
const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5}
];

const result = inventory.find(item => item.name === 'cherries');
console.log(result); // {name: 'cherries', quantity: 5}

// 未找到则返回undefined
const notFound = inventory.find(item => item.name === 'oranges');
console.log(notFound); // undefined
```

#### findIndex() - 查找满足条件的元素索引

```javascript
/**
 * @description 返回数组中满足提供的测试函数的第一个元素的索引
 * @param {Function} callbackFn - 测试函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {number} 找到的元素的索引，否则返回-1
 */
const grades = [
  {subject: 'Math', score: 90},
  {subject: 'Physics', score: 85},
  {subject: 'Chemistry', score: 78}
];

const lowScoreIndex = grades.findIndex(grade => grade.score < 80);
console.log(lowScoreIndex); // 2

// 未找到则返回-1
const highScoreIndex = grades.findIndex(grade => grade.score > 95);
console.log(highScoreIndex); // -1
```

#### includes() - 判断是否包含元素

```javascript
/**
 * @description 判断数组是否包含指定的元素
 * @param {any} searchElement - 要查找的元素
 * @param {number} [fromIndex=0] - 开始搜索的索引
 * @return {boolean} 如果包含则返回true，否则返回false
 */
const pets = ['cat', 'dog', 'bat'];
console.log(pets.includes('cat')); // true
console.log(pets.includes('at')); // false

// 从索引1开始搜索
console.log(pets.includes('cat', 1)); // false
```

#### slice() - 提取数组的一部分

```javascript
/**
 * @description 返回数组的一个浅拷贝，从开始到结束索引（不包括结束索引）
 * @param {number} [start=0] - 开始提取的索引
 * @param {number} [end=array.length] - 结束提取的索引
 * @return {Array} 提取的新数组
 */
const fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
const citrus = fruits.slice(1, 3);
console.log(citrus); // ['Orange', 'Lemon']

// 省略结束索引，则提取到数组末尾
const favorites = fruits.slice(3);
console.log(favorites); // ['Apple', 'Mango']

// 使用负索引，从数组末尾计算位置
const last = fruits.slice(-2);
console.log(last); // ['Apple', 'Mango']

// 创建数组的浅拷贝
const copy = fruits.slice();
console.log(copy); // ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
```

### 3. 遍历方法

#### forEach() - 遍历数组

```javascript
/**
 * @description 对数组的每个元素执行一次给定的函数
 * @param {Function} callbackFn - 为每个元素执行的函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {undefined} 此方法不返回值
 */
const numbers = [1, 2, 3, 4, 5];
numbers.forEach((num, index) => {
  console.log(`Element at index ${index} is ${num}`);
});
// 输出:
// Element at index 0 is 1
// Element at index 1 is 2
// Element at index 2 is 3
// Element at index 3 is 4
// Element at index 4 is 5

// 注意：forEach不能中断遍历，且没有返回值
```

#### map() - 映射数组

```javascript
/**
 * @description 创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数后的返回值
 * @param {Function} callbackFn - 为每个元素执行的函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {Array} 一个新数组，每个元素都是回调函数的结果
 */
const numbers = [1, 4, 9, 16];
const roots = numbers.map(num => Math.sqrt(num));
console.log(roots); // [1, 2, 3, 4]
console.log(numbers); // [1, 4, 9, 16] (原数组未改变)

// 对象数组的转换
const users = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 28 },
  { name: 'Bob', age: 35 }
];
const names = users.map(user => user.name);
console.log(names); // ['John', 'Jane', 'Bob']
```

#### filter() - 过滤数组

```javascript
/**
 * @description 创建一个新数组，其包含通过所提供函数测试的所有元素
 * @param {Function} callbackFn - 测试函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {Array} 一个新数组，包含所有通过测试的元素
 */
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
const longWords = words.filter(word => word.length > 6);
console.log(longWords); // ['exuberant', 'destruction', 'present']
console.log(words); // 原数组未改变

// 过滤对象数组
const products = [
  { id: 1, name: 'Laptop', price: 1200, inStock: true },
  { id: 2, name: 'Phone', price: 800, inStock: true },
  { id: 3, name: 'Tablet', price: 600, inStock: false },
  { id: 4, name: 'Watch', price: 300, inStock: true }
];
const availableProducts = products.filter(product => product.inStock && product.price < 1000);
console.log(availableProducts);
// [
//   { id: 2, name: 'Phone', price: 800, inStock: true },
//   { id: 4, name: 'Watch', price: 300, inStock: true }
// ]
```

#### reduce() - 累加器

### 基本语法

`Array.prototype.reduce()` 方法对数组中的每个元素执行一个由您提供的**reducer函数**，将其结果汇总为单个返回值。

```javascript
/**
 * @description 对数组中的每个元素执行reducer函数，汇总为单个返回值
 * @param {Function} callbackFn - 累加器函数（接收4个参数）
 * @param {Function} callbackFn.accumulator - 累计器，上一次调用的返回值（或初始值）
 * @param {any} callbackFn.currentValue - 当前处理的数组元素
 * @param {number} callbackFn.currentIndex - 当前元素的索引（可选）
 * @param {Array} callbackFn.array - 原数组（可选）
 * @param {any} [initialValue] - 初始累计值（可选，若未提供则使用数组第一个元素）
 * @return {any} 最终累计结果
 */
arr.reduce(callbackFn[, initialValue]);
```

### 核心特性

1. **参数详解**：

   - `callbackFn`：必须的累加函数，决定如何合并数组元素。
   - `initialValue`（可选）：作为第一次调用`callbackFn`时的`accumulator`值。若未提供，则使用数组第一个元素，且跳过第一个元素的遍历（从第二个元素开始）。
2. **执行流程**：

   - 若提供`initialValue`：从第一个元素开始遍历，`accumulator`初始为`initialValue`，`currentValue`为第一个元素。
   - 若未提供`initialValue`：`accumulator`初始为第一个元素，`currentValue`为第二个元素，从第二个元素开始遍历。

### 实战案例

#### 案例1：对象数组的多维度统计（分组+求和）

统计商品数组中各品类的总销量和平均价格：

```javascript
const products = [
  { category: '电子', name: '手机', price: 3000, sales: 100 },
  { category: '电子', name: '平板', price: 2000, sales: 80 },
  { category: '服饰', name: 'T恤', price: 100, sales: 200 },
  { category: '服饰', name: '裤子', price: 150, sales: 150 }
];

// 结果格式：{ 电子: { totalSales: 180, avgPrice: 2500 }, 服饰: { totalSales: 350, avgPrice: 125 } }
const stats = products.reduce((acc, curr) => {
  if (!acc[curr.category]) {
    acc[curr.category] = { totalSales: 0, avgPrice: 0, count: 0 };
  }
  acc[curr.category].totalSales += curr.sales;
  acc[curr.category].avgPrice += curr.price;
  acc[curr.category].count++;
  // 最后计算平均值（避免过程中浮点误差）
  acc[curr.category].avgPrice = Number((acc[curr.category].avgPrice / acc[curr.category].count).toFixed(2));
  return acc;
}, {});

console.log(stats);
```

#### 案例2：嵌套数组的深度展平（支持指定层级）

将多维数组展平为一维数组，支持指定展平深度（如`[1, [2, [3, [4]], 5]]`展平2层后为`[1, 2, [3, [4]], 5]`）：

```javascript
/**
 * @description 深度展平嵌套数组
 * @param {Array} arr - 待展平的嵌套数组
 * @param {number} [depth=1] - 展平深度（默认1层）
 * @return {Array} 展平后的数组
 */
function deepFlatten(arr, depth = 1) {
  return arr.reduce((acc, curr) => {
    if (Array.isArray(curr) && depth > 0) {
      // 递归展平当前元素，深度减1
      return acc.concat(deepFlatten(curr, depth - 1));
    }
    return acc.concat(curr);
  }, []);
}

// 调用示例
const nestedArr = [1, [2, [3, [4]], 5]];
console.log(deepFlatten(nestedArr)); // [1, 2, [3, [4]], 5]（默认展平1层）
console.log(deepFlatten(nestedArr, 2)); // [1, 2, 3, [4], 5]（展平2层）
console.log(deepFlatten(nestedArr, Infinity)); // [1, 2, 3, 4, 5]（完全展平）
```

### 面试常见问题

1. **Q：`reduce`没有初始值时，空数组会报错吗？**
   A：会。若数组为空且未提供`initialValue`，`reduce()`会抛出`TypeError`。因此处理可能为空的数组时，建议始终提供`initialValue`。
2. **Q：`reduce`与`for`循环相比有什么优势？**
   A：

   - 代码更简洁，声明式写法更易读；
   - 天然支持函数式编程，可以与`map`、`filter`链式调用；
   - 避免手动管理索引变量，减少出错概率。
3. **Q：如何用`reduce`实现`map`功能？**
   A：通过累加新数组实现：

```javascript
const arr = [1, 2, 3];
const mapped = arr.reduce((acc, curr) => {
  acc.push(curr * 2);
  return acc;
}, []);
console.log(mapped); // [2, 4, 6]
```

#### reduceRight() - 从右向左累加

```javascript
/**
 * @description 从右向左对数组中的每个元素执行reducer函数
 * @param {Function} callbackFn - 累加器函数
 * @param {any} [initialValue] - 初始值
 * @return {any} 累加的结果
 */
const array = [['1', '2'], ['3', '4'], ['5', '6']];
const flattened = array.reduceRight((acc, curr) => acc.concat(curr), []);
console.log(flattened); // ['5', '6', '3', '4', '1', '2']

// 和reduce最大的区别是处理顺序相反
```

#### some() - 判断是否存在符合条件的元素

```javascript
/**
 * @description 测试是否至少有一个元素通过了提供的函数测试
 * @param {Function} callbackFn - 测试函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {boolean} 如果有至少一个元素通过测试，则返回true，否则返回false
 */
const numbers = [1, 2, 3, 4, 5];
const hasEven = numbers.some(num => num % 2 === 0);
console.log(hasEven); // true

const greaterThan10 = numbers.some(num => num > 10);
console.log(greaterThan10); // false

// 空数组永远返回false
console.log([].some(x => x > 0)); // false
```

#### every() - 判断是否所有元素都符合条件

```javascript
/**
 * @description 测试是否所有元素都通过了提供的函数测试
 * @param {Function} callbackFn - 测试函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {boolean} 如果所有元素都通过测试，则返回true，否则返回false
 */
const numbers = [1, 2, 3, 4, 5];
const allPositive = numbers.every(num => num > 0);
console.log(allPositive); // true

const allEven = numbers.every(num => num % 2 === 0);
console.log(allEven); // false

// 空数组永远返回true
console.log([].every(x => x > 0)); // true
```

### 4. 排序和变形方法

#### sort() - 排序数组

```javascript
/**
 * @description 对数组的元素进行排序，并返回排序后的数组
 * @param {Function} [compareFn] - 定义排序顺序的函数
 * @return {Array} 排序后的数组（原数组被修改）
 */
// 简单排序（按字母顺序）
const fruits = ['banana', 'cherry', 'apple', 'peach'];
fruits.sort();
console.log(fruits); // ['apple', 'banana', 'cherry', 'peach']

// 数字排序（默认按字符串排序，需要比较函数）
const numbers = [40, 100, 1, 5, 25, 10];
numbers.sort(); // 默认排序
console.log(numbers); // [1, 10, 100, 25, 40, 5] (错误的数字排序)

// 正确的数字排序（升序）
numbers.sort((a, b) => a - b);
console.log(numbers); // [1, 5, 10, 25, 40, 100]

// 降序排序
numbers.sort((a, b) => b - a);
console.log(numbers); // [100, 40, 25, 10, 5, 1]

// 对象数组排序
const items = [
  { name: 'Edward', value: 21 },
  { name: 'Sharpe', value: 37 },
  { name: 'Alfred', value: 19 },
  { name: 'Thomas', value: 45 }
];

// 按对象的value属性排序
items.sort((a, b) => a.value - b.value);
console.log(items);
// [
//   { name: 'Alfred', value: 19 },
//   { name: 'Edward', value: 21 },
//   { name: 'Sharpe', value: 37 },
//   { name: 'Thomas', value: 45 }
// ]

// 按对象的name属性排序
items.sort((a, b) => {
  const nameA = a.name.toUpperCase(); // 不区分大小写
  const nameB = b.name.toUpperCase();
  if (nameA < nameB) return -1;
  if (nameA > nameB) return 1;
  return 0;
});
console.log(items);
// [
//   { name: 'Alfred', value: 19 },
//   { name: 'Edward', value: 21 },
//   { name: 'Sharpe', value: 37 },
//   { name: 'Thomas', value: 45 }
// ]
```

#### reverse() - 颠倒数组

```javascript
/**
 * @description 将数组中元素的位置颠倒，并返回该数组
 * @return {Array} 颠倒后的数组（原数组被修改）
 */
const array = [1, 2, 3, 4, 5];
array.reverse();
console.log(array); // [5, 4, 3, 2, 1]

// 字符串反转常用方法
const string = "Hello";
const reversedString = string.split('').reverse().join('');
console.log(reversedString); // "olleH"
```

#### concat() - 合并数组

```javascript
/**
 * @description 合并两个或多个数组，返回一个新数组
 * @param {...Array} arrays - 要合并的数组
 * @return {Array} 合并后的新数组
 */
const array1 = ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = [1, 2, 3];

const mergedArray = array1.concat(array2, array3);
console.log(mergedArray); // ['a', 'b', 'c', 'd', 'e', 'f', 1, 2, 3]
console.log(array1); // ['a', 'b', 'c'] (原数组未改变)

// 合并值和数组
const result = array1.concat('d', ['e', 'f'], [['g']]);
console.log(result); // ['a', 'b', 'c', 'd', 'e', 'f', ['g']]
```

#### join() - 数组转字符串

```javascript
/**
 * @description 将数组的所有元素连接成一个字符串并返回
 * @param {string} [separator=','] - 指定分隔符
 * @return {string} 连接后的字符串
 */
const elements = ['Fire', 'Air', 'Water'];

console.log(elements.join()); // "Fire,Air,Water" (默认用逗号分隔)
console.log(elements.join('')); // "FireAirWater" (无分隔符)
console.log(elements.join('-')); // "Fire-Air-Water" (自定义分隔符)

// 构建HTML列表
const items = ['Item 1', 'Item 2', 'Item 3'];
const htmlList = '<ul><li>' + items.join('</li><li>') + '</li></ul>';
console.log(htmlList); // "<ul><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>"
```

#### flat() - 数组扁平化

```javascript
/**
 * @description 按照指定深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组
 * @param {number} [depth=1] - 指定要提取嵌套数组的结构深度
 * @return {Array} 一个包含将数组与子数组中所有元素的新数组
 */
const arr1 = [0, 1, 2, [3, 4]];
console.log(arr1.flat()); // [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];
console.log(arr2.flat()); // [0, 1, 2, [[3, 4]]] (默认深度为1)
console.log(arr2.flat(2)); // [0, 1, 2, [3, 4]] (深度为2)
console.log(arr2.flat(Infinity)); // [0, 1, 2, 3, 4] (完全扁平化)

// 移除数组中的空项
const arr3 = [1, 2, , 4, 5];
console.log(arr3.flat()); // [1, 2, 4, 5]
```

#### flatMap() - 映射并扁平化

```javascript
/**
 * @description 首先使用映射函数映射每个元素，然后将结果压缩成一个新数组
 * @param {Function} callbackFn - 映射函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {Array} 一个新的数组，其中每个元素都是回调函数的结果
 */
const arr = [1, 2, 3, 4];

// 使用 map 和 flat
const result1 = arr.map(x => [x * 2]).flat();
console.log(result1); // [2, 4, 6, 8]

// 使用 flatMap (等效但更高效)
const result2 = arr.flatMap(x => [x * 2]);
console.log(result2); // [2, 4, 6, 8]

// flatMap 允许添加或移除项
const sentences = ['Hello world', 'How are you?'];
const words = sentences.flatMap(s => s.split(' '));
console.log(words); // ['Hello', 'world', 'How', 'are', 'you?']
```

#### fill() - 填充数组

```javascript
/**
 * @description 用一个固定值填充数组中从起始索引到终止索引内的全部元素
 * @param {any} value - 用来填充数组的值
 * @param {number} [start=0] - 起始索引
 * @param {number} [end=array.length] - 终止索引
 * @return {Array} 修改后的数组
 */
const array = [1, 2, 3, 4];

// 用5填充整个数组
console.log(array.fill(5)); // [5, 5, 5, 5]

// 创建数组并填充
console.log(Array(5).fill(0)); // [0, 0, 0, 0, 0]

// 指定起始和结束索引
const newArray = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(newArray.fill(0, 2, 5)); // [1, 2, 0, 0, 0, 6, 7, 8]
```

#### copyWithin() - 数组内复制

```javascript
/**
 * @description 在数组内复制一系列元素到另一个位置
 * @param {number} target - 目标起始索引
 * @param {number} [start=0] - 复制源起始索引
 * @param {number} [end=array.length] - 复制源结束索引
 * @return {Array} 修改后的数组
 */
const array = [1, 2, 3, 4, 5];

// 将索引3开始的元素复制到索引0的位置
console.log(array.copyWithin(0, 3)); // [4, 5, 3, 4, 5]

// 复制指定范围的元素到目标位置
const array2 = [1, 2, 3, 4, 5];
console.log(array2.copyWithin(0, 3, 4)); // [4, 2, 3, 4, 5]

// 负索引也是支持的
const array3 = [1, 2, 3, 4, 5];
console.log(array3.copyWithin(-2, -3, -1)); // [1, 2, 3, 3, 4]
```

### 5. 数组静态方法

#### Array.isArray() - 判断是否为数组

```javascript
/**
 * @description 用于确定传递的值是否是一个数组
 * @param {any} obj - 需要检测的值
 * @return {boolean} 如果值是数组，则为true；否则为false
 */
console.log(Array.isArray([1, 2, 3])); // true
console.log(Array.isArray({foo: 123})); // false
console.log(Array.isArray('foobar')); // false
console.log(Array.isArray(undefined)); // false

// 与 instanceof 的比较
const arr = [1, 2, 3];
console.log(arr instanceof Array); // true
console.log(Array.isArray(arr)); // true

// Array.isArray的优势在于可以检测跨iframe的数组
```

#### Array.from() - 类数组转数组

```javascript
/**
 * @description 从类数组对象或可迭代对象创建一个新的数组实例
 * @param {Object} arrayLike - 想要转换成数组的类数组对象或可迭代对象
 * @param {Function} [mapFn] - 可选的map函数，对每个元素执行
 * @param {Object} [thisArg] - 执行mapFn时用作this的值
 * @return {Array} 一个新的数组实例
 */
// 从字符串创建数组
console.log(Array.from('foo')); // ['f', 'o', 'o']

// 从 Set 创建数组
const set = new Set(['foo', 'bar', 'baz', 'foo']);
console.log(Array.from(set)); // ['foo', 'bar', 'baz']

// 从 Map 创建数组
const map = new Map([[1, 2], [2, 4], [4, 8]]);
console.log(Array.from(map)); // [[1, 2], [2, 4], [4, 8]]

// 从类数组对象（arguments）创建数组
function f() {
  return Array.from(arguments);
}
console.log(f(1, 2, 3)); // [1, 2, 3]

// 使用映射函数
console.log(Array.from([1, 2, 3], x => x * 2)); // [2, 4, 6]

// 生成数字序列
console.log(Array.from({length: 5}, (_, i) => i)); // [0, 1, 2, 3, 4]
```

#### Array.of() - 创建新数组

```javascript
/**
 * @description 创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型
 * @param {...any} elements - 用于创建数组的元素
 * @return {Array} 一个新的数组实例
 */
console.log(Array.of(7)); // [7]
console.log(Array.of(1, 2, 3)); // [1, 2, 3]
console.log(Array.of(undefined)); // [undefined]

// 与 Array 构造函数的区别
console.log(Array(7)); // 创建长度为7的空数组 [empty × 7]
console.log(Array(1, 2, 3)); // [1, 2, 3]
```

## 性能和操作性质比较

### 常用方法时间复杂度


| 方法                      | 时间复杂度 | 说明                                       |
| ------------------------- | ---------- | ------------------------------------------ |
| push/pop                  | O(1)       | 在数组末尾添加/删除元素，操作时间固定      |
| unshift/shift             | O(n)       | 在数组开头添加/删除元素，需要移动所有元素  |
| splice                    | O(n)       | 根据操作元素的位置，最差情况为O(n)         |
| concat                    | O(n)       | 需要创建新数组并复制所有元素               |
| slice                     | O(n)       | 需要创建新数组并复制部分元素               |
| indexOf/lastIndexOf       | O(n)       | 需要遍历数组进行比较                       |
| forEach/map/filter/reduce | O(n)       | 需要遍历整个数组                           |
| sort                      | O(n log n) | JavaScript引擎实现不同，但大多基于快速排序 |

### 修改原数组 vs 返回新数组

**修改原数组的方法**：

- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()
- fill()
- copyWithin()

**返回新数组的方法**：

- concat()
- slice()
- map()
- filter()
- reduce()
- reduceRight()
- flat()
- flatMap()

**返回其他值的方法**：

- forEach() - 返回undefined
- some() - 返回布尔值
- every() - 返回布尔值
- find() - 返回找到的元素或undefined
- findIndex() - 返回找到元素的索引或-1
- includes() - 返回布尔值
- indexOf()/lastIndexOf() - 返回索引或-1
- join() - 返回字符串

> 注意：了解哪些方法会修改原数组、哪些会返回新数组对于避免副作用和编写可预测的代码非常重要。

## 实战案例

### 数据处理工具函数

```javascript
/**
 * @description 数组去重函数
 * @param {Array} array - 需要去重的数组
 * @return {Array} 去重后的新数组
 */
function uniqueArray(array) {
  // 方法1：使用Set（最简洁，ES6+）
  return [...new Set(array)];

  // 方法2：使用filter
  // return array.filter((item, index) => array.indexOf(item) === index);

  // 方法3：使用reduce
  // return array.reduce((acc, curr) => acc.includes(curr) ? acc : [...acc, curr], []);
}

/**
 * @description 数组扁平化函数（递归实现）
 * @param {Array} array - 需要扁平化的数组
 * @param {number} [depth=Infinity] - 扁平化深度
 * @return {Array} 扁平化后的新数组
 */
function flattenArray(array, depth = Infinity) {
  // 方法1：使用flat（ES2019+）
  return array.flat(depth);

  // 方法2：使用reduce递归实现（兼容性更好）
  /*
  return depth > 0 ? array.reduce((acc, val) =>
    acc.concat(Array.isArray(val) ? flattenArray(val, depth - 1) : val), []
  ) : array.slice();
  */
}

/**
 * @description 数组分块函数
 * @param {Array} array - 源数组
 * @param {number} size - 每个分块的大小
 * @return {Array} 分块后的二维数组
 */
function chunkArray(array, size) {
  const chunked = [];
  for (let i = 0; i < array.length; i += size) {
    chunked.push(array.slice(i, i + size));
  }
  return chunked;
}

/**
 * @description 数组交集函数
 * @param {Array} array1 - 第一个数组
 * @param {Array} array2 - 第二个数组
 * @return {Array} 两个数组的交集
 */
function intersectArrays(array1, array2) {
  return array1.filter(item => array2.includes(item));
}

// 测试示例
const numbers = [1, 2, 2, 3, 4, 4, 5];
console.log(uniqueArray(numbers)); // [1, 2, 3, 4, 5]

const nestedArray = [1, [2, [3, 4], 5], 6];
console.log(flattenArray(nestedArray)); // [1, 2, 3, 4, 5, 6]

const data = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(chunkArray(data, 3)); // [[1, 2, 3], [4, 5, 6], [7, 8]]

const array1 = [1, 2, 3, 4, 5];
const array2 = [3, 4, 5, 6, 7];
console.log(intersectArrays(array1, array2)); // [3, 4, 5]
```

### 实际项目中的数组操作

```javascript
/**
 * @description 分页数据处理
 * @param {Array} data - 原始数据
 * @param {number} page - 当前页码
 * @param {number} pageSize - 每页大小
 * @return {Object} 分页结果
 */
function paginateData(data, page, pageSize) {
  const startIndex = (page - 1) * pageSize;
  const paginatedData = data.slice(startIndex, startIndex + pageSize);

  return {
    totalItems: data.length,
    totalPages: Math.ceil(data.length / pageSize),
    currentPage: page,
    pageSize: pageSize,
    data: paginatedData
  };
}

/**
 * @description 根据指定字段对数据进行分组
 * @param {Array} data - 对象数组
 * @param {string} key - 分组依据的字段名
 * @return {Object} 分组结果
 */
function groupBy(data, key) {
  return data.reduce((result, item) => {
    const groupKey = item[key];
    if (!result[groupKey]) {
      result[groupKey] = [];
    }
    result[groupKey].push(item);
    return result;
  }, {});
}

// 示例数据
const users = [
  { id: 1, name: 'Alice', department: 'Engineering', salary: 8000 },
  { id: 2, name: 'Bob', department: 'Marketing', salary: 7500 },
  { id: 3, name: 'Charlie', department: 'Engineering', salary: 8500 },
  { id: 4, name: 'David', department: 'Marketing', salary: 7000 },
  { id: 5, name: 'Eve', department: 'Engineering', salary: 9000 },
  { id: 6, name: 'Frank', department: 'HR', salary: 6500 },
  { id: 7, name: 'Grace', department: 'HR', salary: 6000 }
];

// 使用示例
console.log(paginateData(users, 2, 3));
// {
//   totalItems: 7,
//   totalPages: 3,
//   currentPage: 2,
//   pageSize: 3,
//   data: [
//     { id: 4, name: 'David', department: 'Marketing', salary: 7000 },
//     { id: 5, name: 'Eve', department: 'Engineering', salary: 9000 },
//     { id: 6, name: 'Frank', department: 'HR', salary: 6500 }
//   ]
// }

console.log(groupBy(users, 'department'));
// {
//   Engineering: [
//     { id: 1, name: 'Alice', department: 'Engineering', salary: 8000 },
//     { id: 3, name: 'Charlie', department: 'Engineering', salary: 8500 },
//     { id: 5, name: 'Eve', department: 'Engineering', salary: 9000 }
//   ],
//   Marketing: [
//     { id: 2, name: 'Bob', department: 'Marketing', salary: 7500 },
//     { id: 4, name: 'David', department: 'Marketing', salary: 7000 }
//   ],
//   HR: [
//     { id: 6, name: 'Frank', department: 'HR', salary: 6500 },
//     { id: 7, name: 'Grace', department: 'HR', salary: 6000 }
//   ]
// }
```

## 兼容性说明

大多数数组方法在现代浏览器中都得到了很好的支持，但在使用一些较新的方法时需要注意兼容性：


| 方法           | 引入版本      | IE支持   | 替代方案          |
| -------------- | ------------- | -------- | ----------------- |
| find/findIndex | ES6 (ES2015)  | IE不支持 | 使用filter加条件  |
| includes       | ES7 (ES2016)  | IE不支持 | 使用indexOf != -1 |
| flat/flatMap   | ES10 (ES2019) | IE不支持 | 使用递归+concat   |
| Array.from     | ES6 (ES2015)  | IE不支持 | 使用slice或循环   |
| Array.of       | ES6 (ES2015)  | IE不支持 | 使用字面量或slice |

对于需要支持旧版浏览器的项目，可以：

1. 使用Babel等工具转译
2. 使用polyfill提供这些功能
3. 使用替代方案实现相同功能

## 面试常见问题

### 问题1：数组去重有哪些方法？它们的性能如何？

**答**：

JavaScript中实现数组去重有多种方法，下面是几种常见的方法及其性能比较：

```javascript
const array = [1, 2, 2, 3, 4, 4, 5, 5, 6];

// 方法1：使用Set（ES6+）
function uniqueWithSet(arr) {
  return [...new Set(arr)];
}

// 方法2：使用filter
function uniqueWithFilter(arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}

// 方法3：使用reduce
function uniqueWithReduce(arr) {
  return arr.reduce((acc, curr) =>
    acc.includes(curr) ? acc : [...acc, curr], []);
}

// 方法4：使用对象键值
function uniqueWithObject(arr) {
  const obj = {};
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    obj[item] = item;
  }
  return Object.values(obj);
}

// 方法5：使用Map
function uniqueWithMap(arr) {
  const map = new Map();
  arr.forEach(item => map.set(item, item));
  return [...map.values()];
}

// 性能测试
console.time('uniqueWithSet');
uniqueWithSet(array);
console.timeEnd('uniqueWithSet');

console.time('uniqueWithFilter');
uniqueWithFilter(array);
console.timeEnd('uniqueWithFilter');

console.time('uniqueWithReduce');
uniqueWithReduce(array);
console.timeEnd('uniqueWithReduce');

console.time('uniqueWithObject');
uniqueWithObject(array);
console.timeEnd('uniqueWithObject');

console.time('uniqueWithMap');
uniqueWithMap(array);
console.timeEnd('uniqueWithMap');
```

**性能分析**：

1. 使用Set方法：时间复杂度O(n)，是最快的方法，代码最简洁。
2. 使用filter+indexOf：时间复杂度O(n²)，在大数组时性能较差。
3. 使用reduce+includes：时间复杂度O(n²)，性能与filter方法相似。
4. 使用对象键值：时间复杂度O(n)，性能好，但只适用于简单数据类型，且会将数字类型转为字符串。
5. 使用Map：时间复杂度O(n)，性能好，适用于各种数据类型。

**最佳实践**：

- 在现代浏览器环境下，首选Set方法，简洁高效。
- 对于复杂对象数组，可以使用Map或根据对象的特定属性进行过滤。
- 在需要支持旧版浏览器时，可以使用Object方法，并注意数据类型转换问题。

### 问题2：如何判断一个变量是否是数组？

**答**：

判断一个变量是否是数组有多种方法，每种方法都有其优缺点：

```javascript
const arr = [1, 2, 3];
const obj = { length: 3 };

// 方法1：Array.isArray() - ES5+
console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false

// 方法2：instanceof 运算符
console.log(arr instanceof Array); // true
console.log(obj instanceof Array); // false

// 方法3：Object.prototype.toString.call()
console.log(Object.prototype.toString.call(arr)); // "[object Array]"
console.log(Object.prototype.toString.call(obj)); // "[object Object]"
console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true

// 方法4：Array.prototype.isPrototypeOf()
console.log(Array.prototype.isPrototypeOf(arr)); // true
console.log(Array.prototype.isPrototypeOf(obj)); // false

// 方法5：构造函数（不推荐）
console.log(arr.constructor === Array); // true
console.log(obj.constructor === Array); // false
```

**方法比较**：


| 方法            | 优点                   | 缺点                          | 适用场景       |
| --------------- | ---------------------- | ----------------------------- | -------------- |
| Array.isArray() | 最可靠，处理跨框架问题 | ES5+，旧浏览器不支持          | 现代Web应用    |
| instanceof      | 简单直观               | 在多窗口/框架间传递对象时失效 | 单一环境应用   |
| toString        | 可靠，兼容所有环境     | 语法较长                      | 需要兼容的环境 |
| isPrototypeOf   | 检查原型链             | 可能受原型链修改影响          | 特定场景       |
| constructor     | 简单                   | 对象的constructor可能被改变   | 不建议使用     |

**最佳实践**：

```javascript
// 全面兼容的判断数组函数
function isArray(value) {
  // 优先使用原生方法
  if (Array.isArray) {
    return Array.isArray(value);
  }
  // 回退到可靠的toString方法
  return Object.prototype.toString.call(value) === '[object Array]';
}
```

### 问题3：forEach、map、filter、reduce的区别和使用场景是什么？

**答**：

这四个方法都是数组的高阶函数，用于遍历处理数组元素，但它们的用途和返回值不同：

```javascript
const numbers = [1, 2, 3, 4, 5];

// forEach：遍历数组，不返回值
console.log("--- forEach ---");
const forEachResult = numbers.forEach((num, index) => {
  console.log(`${index}: ${num * 2}`);
});
console.log(forEachResult); // undefined

// map：遍历数组，返回新数组，每个元素是回调结果
console.log("--- map ---");
const mapResult = numbers.map((num) => num * 2);
console.log(mapResult); // [2, 4, 6, 8, 10]

// filter：遍历数组，返回符合条件的元素组成的新数组
console.log("--- filter ---");
const filterResult = numbers.filter((num) => num > 3);
console.log(filterResult); // [4, 5]

// reduce：将数组减少为单个值，返回累计结果
console.log("--- reduce ---");
const reduceResult = numbers.reduce((total, num) => total + num, 0);
console.log(reduceResult); // 15
```

**主要区别**：


| 方法    | 返回值    | 会改变原数组？ | 可中断？ | 主要用途                   |
| ------- | --------- | -------------- | -------- | -------------------------- |
| forEach | undefined | 否             | 否       | 遍历执行操作，无返回值需求 |
| map     | 新数组    | 否             | 否       | 转换数组元素               |
| filter  | 新数组    | 否             | 否       | 筛选符合条件的元素         |
| reduce  | 单一值    | 否             | 否       | 累计计算，合并数据         |

**使用场景**：

- **forEach**：适用于需要遍历数组并执行副作用操作，不关心返回值的场景。如更新DOM、发送日志等。

  ```javascript
  document.querySelectorAll('button').forEach(button => {
    button.addEventListener('click', handleClick);
  });
  ```
- **map**：适用于需要基于原数组转换得到新数组的场景。如数据格式转换、计算派生值等。

  ```javascript
  const users = [{id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}];
  const userNames = users.map(user => user.name);
  ```
- **filter**：适用于需要筛选出符合特定条件元素的场景。如数据过滤、搜索结果等。

  ```javascript
  const tasks = [{id: 1, done: true}, {id: 2, done: false}];
  const completedTasks = tasks.filter(task => task.done);
  ```
- **reduce**：适用于需要将数组汇总为单个值的场景。如计算总和、构建对象、分组数据等。

  ```javascript
  const orders = [{price: 20}, {price: 30}, {price: 50}];
  const totalAmount = orders.reduce((sum, order) => sum + order.price, 0);
  ```

**高级应用**：这些方法可以链式调用，组合使用更强大：

```javascript
const products = [
  { id: 1, name: 'Laptop', price: 1200, category: 'Electronics' },
  { id: 2, name: 'Headphones', price: 100, category: 'Electronics' },
  { id: 3, name: 'Book', price: 20, category: 'Books' },
  { id: 4, name: 'Phone', price: 800, category: 'Electronics' }
];

// 计算电子产品的总价
const electronicsTotalPrice = products
  .filter(product => product.category === 'Electronics')
  .map(product => product.price)
  .reduce((total, price) => total + price, 0);

console.log(electronicsTotalPrice); // 2100
```

### 问题4：如何实现数组扁平化(flatten)？

**答**：

数组扁平化是将多维数组转换为一维数组的过程。实现方式有多种：

```javascript
const nestedArray = [1, [2, [3, 4], 5], 6];

// 方法1：使用flat方法（ES2019+）
function flattenWithFlat(arr, depth = Infinity) {
  return arr.flat(depth);
}
console.log(flattenWithFlat(nestedArray)); // [1, 2, 3, 4, 5, 6]

// 方法2：使用递归
function flattenWithRecursion(arr, result = []) {
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      flattenWithRecursion(arr[i], result);
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
console.log(flattenWithRecursion(nestedArray)); // [1, 2, 3, 4, 5, 6]

// 方法3：使用reduce和递归
function flattenWithReduce(arr) {
  return arr.reduce((acc, val) =>
    acc.concat(Array.isArray(val) ? flattenWithReduce(val) : val), []);
}
console.log(flattenWithReduce(nestedArray)); // [1, 2, 3, 4, 5, 6]

// 方法4：使用堆栈（非递归实现）
function flattenWithStack(arr) {
  const stack = [...arr];
  const result = [];

  while (stack.length) {
    const next = stack.pop();
    if (Array.isArray(next)) {
      stack.push(...next);
    } else {
      result.unshift(next);
    }
  }

  return result;
}
console.log(flattenWithStack(nestedArray)); // [1, 2, 3, 4, 5, 6]

// 方法5：使用Generator函数（ES6+）
function* flattenGenerator(arr) {
  for (const item of arr) {
    if (Array.isArray(item)) {
      yield* flattenGenerator(item);
    } else {
      yield item;
    }
  }
}
console.log([...flattenGenerator(nestedArray)]); // [1, 2, 3, 4, 5, 6]

// 方法6：使用toString和split（仅适用于数字数组）
function flattenWithToString(arr) {
  return arr.toString().split(',').map(Number);
}
console.log(flattenWithToString(nestedArray)); // [1, 2, 3, 4, 5, 6]
```

**方法比较**：


| 方法        | 优点                   | 缺点                               | 适用场景         |
| ----------- | ---------------------- | ---------------------------------- | ---------------- |
| flat        | 最简洁，原生方法       | ES2019+，旧浏览器不支持            | 现代环境         |
| 递归        | 容易理解，灵活         | 深层嵌套可能导致栈溢出             | 通用场景         |
| reduce+递归 | 函数式风格，简洁       | 性能略低于普通递归                 | 函数式编程       |
| 堆栈        | 避免递归栈溢出         | 代码较复杂                         | 深层嵌套数组     |
| Generator   | 内存效率高，可惰性计算 | ES6+，需要转换                     | 大型数组、流处理 |
| toString    | 极其简洁               | 只适用于数字数组，会丢失非数字类型 | 特定数字数组场景 |

**带深度控制的实现**：

```javascript
/**
 * @description 自定义数组扁平化函数，支持深度控制
 * @param {Array} arr - 要扁平化的数组
 * @param {number} [depth=Infinity] - 扁平化深度
 * @return {Array} 扁平化后的数组
 */
function flatten(arr, depth = Infinity) {
  if (depth === 0) return arr.slice();

  return arr.reduce((acc, val) => {
    return acc.concat(Array.isArray(val) && depth > 0
      ? flatten(val, depth - 1)
      : val);
  }, []);
}

console.log(flatten(nestedArray, 1)); // [1, 2, [3, 4], 5, 6]
console.log(flatten(nestedArray, 2)); // [1, 2, 3, 4, 5, 6]
console.log(flatten(nestedArray));    // [1, 2, 3, 4, 5, 6]
```

**性能考虑**：对于大型嵌套数组，非递归方法（如堆栈实现）通常更有效，因为它们避免了潜在的栈溢出问题。在现代浏览器中，原生的`flat()`方法性能最佳。

### 问题5：如何高效地查找数组中的最大值和最小值？

**答**：

查找数组中的最大值和最小值有多种方法，以下是常见的几种方法及其性能比较：

```javascript
const numbers = [5, 12, 8, 130, 44, 78, 0, -1, 32];

// 方法1：使用Math.max和Math.min（ES5+）
function findMaxMin1(arr) {
  return {
    max: Math.max(...arr),
    min: Math.min(...arr)
  };
}
console.log(findMaxMin1(numbers)); // {max: 130, min: -1}

// 方法2：使用apply（避免展开运算符）
function findMaxMin2(arr) {
  return {
    max: Math.max.apply(null, arr),
    min: Math.min.apply(null, arr)
  };
}
console.log(findMaxMin2(numbers)); // {max: 130, min: -1}

// 方法3：使用reduce
function findMaxMin3(arr) {
  return arr.reduce((result, val) => {
    return {
      max: val > result.max ? val : result.max,
      min: val < result.min ? val : result.min
    };
  }, { max: arr[0], min: arr[0] });
}
console.log(findMaxMin3(numbers)); // {max: 130, min: -1}

// 方法4：使用循环（最基础的方法）
function findMaxMin4(arr) {
  let max = arr[0];
  let min = arr[0];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) max = arr[i];
    if (arr[i] < min) min = arr[i];
  }

  return { max, min };
}
console.log(findMaxMin4(numbers)); // {max: 130, min: -1}

// 方法5：使用sort
function findMaxMin5(arr) {
  const sortedArr = [...arr].sort((a, b) => a - b);
  return {
    min: sortedArr[0],
    max: sortedArr[sortedArr.length - 1]
  };
}
console.log(findMaxMin5(numbers)); // {max: 130, min: -1}
```

**性能分析**：


| 方法                      | 时间复杂度 | 空间复杂度 | 优点                   | 缺点                         |
| ------------------------- | ---------- | ---------- | ---------------------- | ---------------------------- |
| Math.max/min + 展开运算符 | O(n)       | O(n)       | 简洁，易读             | 数组较大时可能栈溢出         |
| Math.max/min + apply      | O(n)       | O(1)       | 避免展开运算符的栈限制 | 在非常大的数组上仍可能有问题 |
| reduce                    | O(n)       | O(1)       | 函数式风格，单次遍历   | 代码略长                     |
| 循环                      | O(n)       | O(1)       | 最高效，无额外开销     | 代码稍长                     |
| sort                      | O(n log n) | O(n)       | 简单，可获取多个排序值 | 效率最低，修改数组（需克隆） |

**最佳实践**：

- 对于小到中等大小的数组，使用`Math.max/min + 展开运算符`或`reduce`方法简洁易读。
- 对于大型数组，使用循环方法效率最高。
- 避免使用排序方法查找最大/最小值，除非已经需要排序的数组。

**处理边界情况的改进版本**：

```javascript
/**
 * @description 健壮的数组最大最小值查找函数
 * @param {Array} arr - 数值数组
 * @return {Object} 包含最大值和最小值的对象
 */
function findMaxAndMin(arr) {
  if (!arr || arr.length === 0) {
    return { max: undefined, min: undefined };
  }

  // 筛选出有效数字
  const validNumbers = arr.filter(num => typeof num === 'number' && !isNaN(num));

  if (validNumbers.length === 0) {
    return { max: undefined, min: undefined };
  }

  let max = validNumbers[0];
  let min = validNumbers[0];

  for (let i = 1; i < validNumbers.length; i++) {
    if (validNumbers[i] > max) {
      max = validNumbers[i];
    }
    if (validNumbers[i] < min) {
      min = validNumbers[i];
    }
  }

  return { max, min };
}

// 测试边界情况
console.log(findMaxAndMin([5, 'abc', null, 10, NaN, 2])); // {max: 10, min: 2}
console.log(findMaxAndMin([])); // {max: undefined, min: undefined}
console.log(findMaxAndMin(['a', 'b', 'c'])); // {max: undefined, min: undefined}
```

这些补充内容涵盖了：

1. **数组方法的手写实现** - 深入理解底层原理
2. **类数组对象处理** - 实际开发中的常见场景
3. **异步数组操作** - 现代JavaScript开发的重要技能
4. **性能优化** - 大数据量处理的最佳实践
5. **函数式编程** - 现代JavaScript开发趋势
6. **错误处理** - 编写健壮代码的重要技能

这些内容应该能够显著提升您的数组方法文档的质量和实用性，使其更加贴近实际开发需求和面试要求。

## 数组方法的手写实现（Polyfill）

理解数组方法的底层实现原理对于面试和深入掌握JavaScript非常重要。以下是几个核心方法的手写实现：

### 手写map方法

```javascript
/**
 * @description 手写实现Array.prototype.map方法
 * @param {Function} callbackFn - 映射函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {Array} 映射后的新数组
 */
Array.prototype.myMap = function(callbackFn, thisArg) {
  // 类型检查
  if (this == null) {
    throw new TypeError('Array.prototype.map called on null or undefined');
  }
  if (typeof callbackFn !== 'function') {
    throw new TypeError(callbackFn + ' is not a function');
  }

  // 转换为对象
  const O = Object(this);
  // 获取数组长度
  const len = parseInt(O.length) || 0;
  // 创建新数组
  const A = new Array(len);

  // 遍历数组
  for (let k = 0; k < len; k++) {
    // 检查属性是否存在（处理稀疏数组）
    if (k in O) {
      // 调用回调函数并设置结果
      const kValue = O[k];
      const mappedValue = callbackFn.call(thisArg, kValue, k, O);
      A[k] = mappedValue;
    }
  }

  return A;
};

// 测试手写map方法
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.myMap(x => x * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
```

### 手写filter方法

```javascript
/**
 * @description 手写实现Array.prototype.filter方法
 * @param {Function} callbackFn - 测试函数
 * @param {Object} [thisArg] - 执行回调时用作this的值
 * @return {Array} 过滤后的新数组
 */
Array.prototype.myFilter = function(callbackFn, thisArg) {
  if (this == null) {
    throw new TypeError('Array.prototype.filter called on null or undefined');
  }
  if (typeof callbackFn !== 'function') {
    throw new TypeError(callbackFn + ' is not a function');
  }

  const O = Object(this);
  const len = parseInt(O.length) || 0;
  const A = [];

  for (let k = 0; k < len; k++) {
    if (k in O) {
      const kValue = O[k];
      // 如果回调函数返回true，则添加到结果数组
      if (callbackFn.call(thisArg, kValue, k, O)) {
        A.push(kValue);
      }
    }
  }

  return A;
};

// 测试手写filter方法
const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers = numbers.myFilter(x => x % 2 === 0);
console.log(evenNumbers); // [2, 4, 6]
```

### 手写reduce方法

```javascript
/**
 * @description 手写实现Array.prototype.reduce方法
 * @param {Function} callbackFn - 累加器函数
 * @param {any} [initialValue] - 初始值
 * @return {any} 累加的结果
 */
Array.prototype.myReduce = function(callbackFn, initialValue) {
  if (this == null) {
    throw new TypeError('Array.prototype.reduce called on null or undefined');
  }
  if (typeof callbackFn !== 'function') {
    throw new TypeError(callbackFn + ' is not a function');
  }

  const O = Object(this);
  const len = parseInt(O.length) || 0;

  let k = 0;
  let accumulator;

  // 处理初始值
  if (arguments.length >= 2) {
    accumulator = initialValue;
  } else {
    // 如果没有初始值，找到第一个有效元素作为初始值
    if (len === 0) {
      throw new TypeError('Reduce of empty array with no initial value');
    }

    let kPresent = false;
    while (!kPresent && k < len) {
      kPresent = k in O;
      if (kPresent) {
        accumulator = O[k];
      }
      k++;
    }

    if (!kPresent) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
  }

  // 执行累加操作
  while (k < len) {
    if (k in O) {
      accumulator = callbackFn(accumulator, O[k], k, O);
    }
    k++;
  }

  return accumulator;
};

// 测试手写reduce方法
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.myReduce((acc, curr) => acc + curr, 0);
console.log(sum); // 15
```

## 类数组对象处理

在实际开发中，经常需要处理类数组对象（如NodeList、arguments、HTMLCollection等），以下是常见的处理方法：

### 类数组对象转换为真正的数组

```javascript
/**
 * @description 演示各种类数组对象转数组的方法
 */

// 模拟类数组对象
const arrayLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
};

// 方法1：Array.from()（ES6+，推荐）
const arr1 = Array.from(arrayLike);
console.log(arr1); // ['a', 'b', 'c']

// 方法2：展开运算符（ES6+，适用于可迭代对象）
// const arr2 = [...arrayLike]; // 注意：这对普通类数组对象不起作用

// 方法3：Array.prototype.slice.call()
const arr3 = Array.prototype.slice.call(arrayLike);
console.log(arr3); // ['a', 'b', 'c']

// 方法4：Array.prototype.concat.apply()
const arr4 = Array.prototype.concat.apply([], arrayLike);
console.log(arr4); // ['a', 'b', 'c']

// 方法5：手动循环
function arrayLikeToArray(arrayLike) {
  const result = [];
  for (let i = 0; i < arrayLike.length; i++) {
    result.push(arrayLike[i]);
  }
  return result;
}
const arr5 = arrayLikeToArray(arrayLike);
console.log(arr5); // ['a', 'b', 'c']

// 实际应用场景
function demonstrateRealUsage() {
  // DOM NodeList转数组
  const divs = document.querySelectorAll('div');
  const divArray = Array.from(divs);

  // 现在可以使用数组方法
  divArray.forEach(div => {
    console.log(div.textContent);
  });

  // arguments对象转数组
  function exampleFunction() {
    const argsArray = Array.from(arguments);
    return argsArray.map(arg => typeof arg);
  }

  console.log(exampleFunction(1, 'hello', true)); // ['number', 'string', 'boolean']
}
```

### 类数组对象的直接操作

```javascript
/**
 * @description 在类数组对象上直接使用数组方法
 */

// 使用call/apply在类数组对象上调用数组方法
const arrayLike = {
  0: 10,
  1: 20,
  2: 30,
  length: 3
};

// 直接在类数组对象上使用forEach
Array.prototype.forEach.call(arrayLike, (item, index) => {
  console.log(`Index ${index}: ${item}`);
});

// 直接在类数组对象上使用map
const doubled = Array.prototype.map.call(arrayLike, item => item * 2);
console.log(doubled); // [20, 40, 60]

// 直接在类数组对象上使用filter
const filtered = Array.prototype.filter.call(arrayLike, item => item > 15);
console.log(filtered); // [20, 30]

// 创建通用的类数组操作函数
function createArrayLikeHelper(arrayLike) {
  return {
    forEach: function(callback, thisArg) {
      return Array.prototype.forEach.call(arrayLike, callback, thisArg);
    },
    map: function(callback, thisArg) {
      return Array.prototype.map.call(arrayLike, callback, thisArg);
    },
    filter: function(callback, thisArg) {
      return Array.prototype.filter.call(arrayLike, callback, thisArg);
    },
    reduce: function(callback, initialValue) {
      return Array.prototype.reduce.call(arrayLike, callback, initialValue);
    }
  };
}

// 使用示例
const helper = createArrayLikeHelper(arrayLike);
const result = helper.map(x => x * 3).filter(x => x > 30);
console.log(result); // [60, 90]
```

## 异步数组操作

在现代JavaScript开发中，经常需要处理异步数组操作，以下是常见的模式和最佳实践：

### 串行异步处理

```javascript
/**
 * @description 串行处理异步数组操作
 */

// 模拟异步操作
function asyncOperation(value, delay = 1000) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(value * 2);
    }, delay);
  });
}

// 方法1：使用reduce实现串行处理
async function processArraySerially(array) {
  const results = await array.reduce(async (promiseChain, currentValue) => {
    const accumulator = await promiseChain;
    const result = await asyncOperation(currentValue);
    return [...accumulator, result];
  }, Promise.resolve([]));

  return results;
}

// 方法2：使用for...of循环
async function processArraySeriallyWithLoop(array) {
  const results = [];
  for (const value of array) {
    const result = await asyncOperation(value);
    results.push(result);
  }
  return results;
}

// 使用示例
async function demonstrateSerialProcessing() {
  const numbers = [1, 2, 3, 4, 5];

  console.time('Serial Processing');
  const results = await processArraySerially(numbers);
  console.timeEnd('Serial Processing');
  console.log(results); // [2, 4, 6, 8, 10]
}
```

### 并行异步处理

```javascript
/**
 * @description 并行处理异步数组操作
 */

// 方法1：使用Promise.all + map
async function processArrayInParallel(array) {
  const promises = array.map(value => asyncOperation(value));
  return await Promise.all(promises);
}

// 方法2：使用Promise.allSettled处理可能失败的操作
async function processArrayWithErrorHandling(array) {
  const promises = array.map(async (value) => {
    try {
      return await asyncOperation(value);
    } catch (error) {
      return { error: error.message, value };
    }
  });

  return await Promise.allSettled(promises);
}

// 方法3：限制并发数量的并行处理
async function processArrayWithConcurrencyLimit(array, limit = 3) {
  const results = [];

  for (let i = 0; i < array.length; i += limit) {
    const batch = array.slice(i, i + limit);
    const batchPromises = batch.map(value => asyncOperation(value));
    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);
  }

  return results;
}

// 使用示例
async function demonstrateParallelProcessing() {
  const numbers = [1, 2, 3, 4, 5];

  console.time('Parallel Processing');
  const results = await processArrayInParallel(numbers);
  console.timeEnd('Parallel Processing');
  console.log(results); // [2, 4, 6, 8, 10]

  // 限制并发的处理
  console.time('Limited Concurrency');
  const limitedResults = await processArrayWithConcurrencyLimit(numbers, 2);
  console.timeEnd('Limited Concurrency');
  console.log(limitedResults); // [2, 4, 6, 8, 10]
}
```

### 异步数组方法的实现

```javascript
/**
 * @description 实现异步版本的数组方法
 */

// 异步map
Array.prototype.mapAsync = async function(asyncCallback, thisArg) {
  const promises = this.map((value, index, array) =>
    asyncCallback.call(thisArg, value, index, array)
  );
  return await Promise.all(promises);
};

// 异步filter
Array.prototype.filterAsync = async function(asyncCallback, thisArg) {
  const results = await this.mapAsync(asyncCallback, thisArg);
  return this.filter((_, index) => results[index]);
};

// 异步forEach
Array.prototype.forEachAsync = async function(asyncCallback, thisArg) {
  await this.mapAsync(asyncCallback, thisArg);
};

// 使用示例
async function demonstrateAsyncArrayMethods() {
  const numbers = [1, 2, 3, 4, 5];

  // 异步map
  const doubled = await numbers.mapAsync(async (num) => {
    await new Promise(resolve => setTimeout(resolve, 100));
    return num * 2;
  });
  console.log(doubled); // [2, 4, 6, 8, 10]

  // 异步filter
  const evenNumbers = await numbers.filterAsync(async (num) => {
    await new Promise(resolve => setTimeout(resolve, 100));
    return num % 2 === 0;
  });
  console.log(evenNumbers); // [2, 4]
}
```

## 性能优化与最佳实践

### 大数据量处理优化

```javascript
/**
 * @description 大数据量数组处理的性能优化技巧
 */

// 1. 使用生成器函数处理大数组，避免内存溢出
function* processLargeArray(array, batchSize = 1000) {
  for (let i = 0; i < array.length; i += batchSize) {
    const batch = array.slice(i, i + batchSize);
    yield batch.map(item => item * 2); // 处理逻辑
  }
}

// 使用示例
function demonstrateLargeArrayProcessing() {
  const largeArray = Array.from({ length: 1000000 }, (_, i) => i);

  // 分批处理，避免阻塞主线程
  const processor = processLargeArray(largeArray, 10000);

  function processNextBatch() {
    const { value, done } = processor.next();
    if (!done) {
      console.log(`Processed batch of ${value.length} items`);
      // 使用setTimeout避免阻塞主线程
      setTimeout(processNextBatch, 0);
    } else {
      console.log('All batches processed');
    }
  }

  processNextBatch();
}

// 2. 使用Web Workers处理CPU密集型数组操作
function processArrayInWorker(array, operation) {
  return new Promise((resolve, reject) => {
    const worker = new Worker(`
      self.onmessage = function(e) {
        const { array, operation } = e.data;
        try {
          const result = array.map(eval(operation));
          self.postMessage({ success: true, result });
        } catch (error) {
          self.postMessage({ success: false, error: error.message });
        }
      }
    `);

    worker.onmessage = function(e) {
      const { success, result, error } = e.data;
      worker.terminate();
      if (success) {
        resolve(result);
      } else {
        reject(new Error(error));
      }
    };

    worker.postMessage({ array, operation });
  });
}

// 3. 内存优化：避免创建不必要的中间数组
function optimizedChainedOperations(array) {
  // 不好的做法：创建多个中间数组
  // const result = array
  //   .map(x => x * 2)
  //   .filter(x => x > 10)
  //   .map(x => x + 1);

  // 好的做法：合并操作，减少中间数组
  const result = array.reduce((acc, x) => {
    const doubled = x * 2;
    if (doubled > 10) {
      acc.push(doubled + 1);
    }
    return acc;
  }, []);

  return result;
}

// 4. 使用TypedArray处理数值数组
function demonstrateTypedArrayPerformance() {
  const size = 1000000;

  // 普通数组
  console.time('Regular Array');
  const regularArray = new Array(size);
  for (let i = 0; i < size; i++) {
    regularArray[i] = Math.random();
  }
  console.timeEnd('Regular Array');

  // TypedArray
  console.time('Float32Array');
  const typedArray = new Float32Array(size);
  for (let i = 0; i < size; i++) {
    typedArray[i] = Math.random();
  }
  console.timeEnd('Float32Array');

  // TypedArray通常在数值计算中性能更好
  console.time('Regular Array Sum');
  const sum1 = regularArray.reduce((a, b) => a + b, 0);
  console.timeEnd('Regular Array Sum');

  console.time('TypedArray Sum');
  const sum2 = typedArray.reduce((a, b) => a + b, 0);
  console.timeEnd('TypedArray Sum');
}
```

### 函数式编程最佳实践

```javascript
/**
 * @description 函数式编程风格的数组操作最佳实践
 */

// 1. 组合函数：创建可复用的数组处理管道
const pipe = (...functions) => (value) => functions.reduce((acc, fn) => fn(acc), value);

const compose = (...functions) => (value) => functions.reduceRight((acc, fn) => fn(acc), value);

// 创建可复用的数组操作函数
const multiplyBy = (factor) => (array) => array.map(x => x * factor);
const filterGreaterThan = (threshold) => (array) => array.filter(x => x > threshold);
const sum = (array) => array.reduce((a, b) => a + b, 0);

// 使用管道组合操作
const processNumbers = pipe(
  multiplyBy(2),
  filterGreaterThan(10),
  sum
);

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const result = processNumbers(numbers);
console.log(result); // 70 (12 + 14 + 16 + 18 + 20)

// 2. 柯里化数组操作函数
const curry = (fn) => (...args) =>
  args.length >= fn.length ? fn(...args) : (...nextArgs) => curry(fn)(...args, ...nextArgs);

const curriedMap = curry((fn, array) => array.map(fn));
const curriedFilter = curry((predicate, array) => array.filter(predicate));

// 创建专用的操作函数
const double = curriedMap(x => x * 2);
const getEvens = curriedFilter(x => x % 2 === 0);

console.log(double([1, 2, 3, 4])); // [2, 4, 6, 8]
console.log(getEvens([1, 2, 3, 4, 5, 6])); // [2, 4, 6]

// 3. 不可变数据操作
const immutableArrayOperations = {
  // 不可变的添加元素
  append: (array, ...elements) => [...array, ...elements],

  // 不可变的删除元素
  remove: (array, index) => [
    ...array.slice(0, index),
    ...array.slice(index + 1)
  ],

  // 不可变的更新元素
  update: (array, index, newValue) => [
    ...array.slice(0, index),
    newValue,
    ...array.slice(index + 1)
  ],

  // 不可变的插入元素
  insert: (array, index, ...elements) => [
    ...array.slice(0, index),
    ...elements,
    ...array.slice(index)
  ]
};

// 使用示例
const originalArray = [1, 2, 3, 4, 5];
const newArray1 = immutableArrayOperations.append(originalArray, 6, 7);
const newArray2 = immutableArrayOperations.remove(newArray1, 2);
const newArray3 = immutableArrayOperations.update(newArray2, 1, 99);

console.log(originalArray); // [1, 2, 3, 4, 5] (未改变)
console.log(newArray3); // [1, 99, 4, 5, 6, 7]
```

## 错误处理和边界情况

### 健壮的数组操作函数

```javascript
/**
 * @description 处理各种边界情况的健壮数组操作
 */

// 安全的数组操作包装器
const safeArrayOperation = {
  /**
   * 安全的map操作
   */
  map: function(array, callback, thisArg) {
    // 输入验证
    if (!Array.isArray(array)) {
      throw new TypeError('First argument must be an array');
    }
    if (typeof callback !== 'function') {
      throw new TypeError('Callback must be a function');
    }

    // 处理空数组
    if (array.length === 0) {
      return [];
    }

    try {
      return array.map(callback, thisArg);
    } catch (error) {
      console.error('Error in map operation:', error);
      return [];
    }
  },

  /**
   * 安全的filter操作
   */
  filter: function(array, predicate, thisArg) {
    if (!Array.isArray(array)) {
      throw new TypeError('First argument must be an array');
    }
    if (typeof predicate !== 'function') {
      throw new TypeError('Predicate must be a function');
    }

    if (array.length === 0) {
      return [];
    }

    try {
      return array.filter(predicate, thisArg);
    } catch (error) {
      console.error('Error in filter operation:', error);
      return [];
    }
  },

  /**
   * 安全的reduce操作
   */
  reduce: function(array, reducer, initialValue) {
    if (!Array.isArray(array)) {
      throw new TypeError('First argument must be an array');
    }
    if (typeof reducer !== 'function') {
      throw new TypeError('Reducer must be a function');
    }

    if (array.length === 0) {
      if (arguments.length < 3) {
        throw new TypeError('Reduce of empty array with no initial value');
      }
      return initialValue;
    }

    try {
      return arguments.length >= 3
        ? array.reduce(reducer, initialValue)
        : array.reduce(reducer);
    } catch (error) {
      console.error('Error in reduce operation:', error);
      return arguments.length >= 3 ? initialValue : undefined;
    }
  }
};

// 处理稀疏数组的特殊情况
function handleSparseArrays() {
  // 稀疏数组示例
  const sparseArray = [1, , 3, , 5]; // 包含空槽的数组

  console.log('Original sparse array:', sparseArray);
  console.log('Length:', sparseArray.length); // 5

  // 不同方法对稀疏数组的处理
  console.log('forEach (skips empty slots):',
    sparseArray.forEach((val, i) => console.log(`${i}: ${val}`))
  );

  console.log('map (preserves empty slots):',
    sparseArray.map(x => x * 2)
  ); // [2, empty, 6, empty, 10]

  console.log('filter (removes empty slots):',
    sparseArray.filter(x => true)
  ); // [1, 3, 5]

  // 填充稀疏数组
  const denseArray = Array.from(sparseArray, x => x || 0);
  console.log('Dense array:', denseArray); // [1, 0, 3, 0, 5]
}

// 处理混合类型数组
function handleMixedTypeArrays() {
  const mixedArray = [1, 'abc', null, 10, NaN, {}, [], NaN];

  // 安全的数值操作
  const safeNumbers = mixedArray
    .filter(item => typeof item === 'number' && !isNaN(item))
    .map(num => num * 2);
  console.log('Safe numbers:', safeNumbers); // [2]

  // 安全的字符串操作
  const safeStrings = mixedArray
    .filter(item => typeof item === 'string')
    .map(str => str.toUpperCase());
  console.log('Safe strings:', safeStrings); // ['2']

  // 类型分组
  const typeGroups = mixedArray.reduce((groups, item) => {
    const type = item === null ? 'null' : typeof item;
    if (!groups[type]) {
      groups[type] = [];
    }
    groups[type].push(item);
    return groups;
  }, {});
  console.log('Type groups:', typeGroups);
}

// 使用示例
try {
  const numbers = [1, 2, 3, 4, 5];
  const doubled = safeArrayOperation.map(numbers, x => x * 2);
  console.log(doubled); // [2, 4, 6, 8, 10]

  // 测试错误处理
  const invalidResult = safeArrayOperation.map('not an array', x => x);
} catch (error) {
  console.error('Caught error:', error.message);
}

handleSparseArrays();
handleMixedTypeArrays();
```

这些补充内容涵盖了：

1. **数组方法的手写实现** - 深入理解底层原理
2. **类数组对象处理** - 实际开发中的常见场景
3. **异步数组操作** - 现代JavaScript开发的重要技能
4. **性能优化** - 大数据量处理的最佳实践
5. **函数式编程** - 现代JavaScript开发趋势
6. **错误处理** - 编写健壮代码的重要技能

这些内容应该能够显著提升您的数组方法文档的质量和实用性，使其更加贴近实际开发需求和面试要求。
