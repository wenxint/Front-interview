# 前端面试宝典 - JS代码查看器规则

## data.js 数据源规则

### 核心原则
- **数据源唯一性**: `data.js` 的所有代码内容必须且仅能来源于 `常看js.js` 文件
- **零二次加工**: 从 `常看js.js` 搬运代码时，不允许任何形式的修改、优化或重构
- **完整性保持**: 必须保持原始代码的完整性，包括但不限于：
  - 所有注释（单行注释 `//` 和多行注释 `/* */`）
  - 原始缩进和换行格式
  - 变量命名和函数命名
  - 代码逻辑和算法实现
  - 所有空行和空格

### 搬运规范

#### 1. 函数体严格保持规则
```javascript
// ✅ 正确示例：完全保持原始函数体
// 原始代码：
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    // 如果是基本类型或 null，直接返回
    return obj;
  }

  if (obj instanceof Date) {
    // 如果是 Date 对象，返回一个新的 Date
    return new Date(obj);
  }

  if (obj instanceof RegExp) {
    // 如果是正则表达式，返回一个新的 RegExp
    return new RegExp(obj);
  }

  // 如果是数组或对象，递归拷贝
  const clone = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key]); // 递归拷贝每个属性
    }
  }

  return clone;
}

// ❌ 错误示例：禁止添加任何处理逻辑
function deepClone(obj, visited = new WeakMap()) { // ❌ 禁止修改参数
  // 处理循环引用  ❌ 禁止添加原始代码中不存在的逻辑
  if (visited.has(obj)) {
    return visited.get(obj);
  }
  // ... 其他禁止添加的代码
}
```

#### 2. 调用案例补足规则
**仅当原始函数没有调用案例时，允许补足调用案例**

```javascript
// ✅ 允许的情况：原函数无调用案例时补足
// 原始代码只有函数定义，无调用示例：
function bubbleSort(arr) {
  // 原始函数体完全保持
}

// 允许补足的调用案例：
console.log(bubbleSort([3, 1, 4, 1, 5])); // 输出: [1, 1, 3, 4, 5]

// ❌ 禁止的情况：原函数已有调用案例时修改或添加
// 如果原始代码已包含测试用例，严禁修改或添加新的调用案例
```

#### 3. 代码块识别标准
- 以函数定义开始的完整代码块
- 以变量声明开始的完整逻辑单元
- 包含测试用例的完整示例
- 独立的算法实现片段

#### 4. 标题和描述生成规则
```javascript
// 标题生成：提取函数名或核心功能名
// 描述生成：简短描述功能，不超过20字
{
  title: "函数名称", // 直接使用函数名或算法名
  description: "简短功能描述" // 不添加技术细节
}
```

#### 5. 严格禁止的修改行为
- ❌ 修改函数参数（如添加 visited 参数）
- ❌ 添加原始代码中不存在的处理逻辑
- ❌ 修改函数体内的任何条件判断
- ❌ 添加原始代码中没有的变量声明
- ❌ 修改原始代码的算法实现方式
- ❌ 添加或修改任何注释
- ❌ 重新格式化代码缩进
- ❌ 修改变量名或函数名
- ❌ 优化算法逻辑
- ❌ 添加JSDoc注释
- ❌ 调整代码结构
- ❌ 添加类型注解
- ❌ 修改console.log输出内容

#### 6. 必须保持的内容
- ✅ 所有原始注释
- ✅ 原始代码格式和缩进
- ✅ 完整的函数实现
- ✅ 所有测试用例和示例
- ✅ 原始的变量命名
- ✅ 代码中的空行和换行
- ✅ 原始的console.log语句
- ✅ 函数的原始参数列表
- ✅ 函数体内的原始逻辑流程

#### 7. 调用案例补足的条件和标准
**仅在以下情况下允许补足调用案例：**
- 原始函数定义完整但缺少调用示例
- 原始代码中没有测试用例或使用示例
- 补足的调用案例必须简洁明了
- 调用案例应展示函数的基本用法
- 不得修改或删除原有的调用案例

**补足调用案例的格式：**
```javascript
// 使用示例：
const result = functionName(params);
console.log(result); // 输出: 预期结果

// 或者
functionName(params);
```

### 数据结构规范

```javascript
window.CODE_DATA = [
  {
    id: "uniqueIdentifier", // 唯一标识符，使用函数名或功能名
    title: "功能标题", // 直接使用函数名或算法名
    description: "功能描述", // 简短描述，不超过20字
    code: `// 从常看js.js直接复制的完整原始代码
// 包括所有注释、格式、逻辑
// 不允许任何修改
// 必要时可补足调用案例（仅当原代码无调用案例时）`
  }
];
```

### 质量检查清单

在搬运代码时，必须确认：
- [ ] 函数体与 `常看js.js` 中的源代码100%一致
- [ ] 函数参数列表完全一致
- [ ] 函数内部逻辑完全一致
- [ ] 保留了所有原始注释
- [ ] 保持了原始的代码格式和缩进
- [ ] 没有添加任何新的注释或说明
- [ ] 没有修改任何变量名或函数名
- [ ] 包含了完整的测试用例（如果原代码中有）
- [ ] 保持了原始的console.log输出
- [ ] 仅在原函数无调用案例时补足了调用示例

### 违规示例

以下行为严格禁止：
```javascript
// ❌ 修改函数参数
// 原始: function deepClone(obj)
// 禁止: function deepClone(obj, visited = new WeakMap())

// ❌ 添加原始代码中不存在的处理逻辑
// 禁止添加: 循环引用处理、额外的类型检查等

// ❌ 修改函数体内的条件判断
// 原始: if (obj === null || typeof obj !== "object")
// 禁止: if (obj === null || typeof obj !== 'object' || obj === undefined)

// ❌ 添加原始代码中没有的变量
// 禁止添加: const visited = new WeakMap();

// ❌ 修改已有的调用案例
// 如果原代码有调用案例，严禁修改
```

### 执行流程

1. **识别源代码**: 在 `常看js.js` 中定位目标代码块
2. **完整复制**: 使用 Ctrl+C/Ctrl+V 直接复制函数体，不允许手动重写
3. **格式检查**: 确认复制的代码格式与源文件完全一致
4. **调用案例评估**: 检查原函数是否有调用案例，仅在缺失时补足
5. **生成条目**: 按照数据结构规范创建JSON对象
6. **最终验证**: 对比源文件，确保函数体100%一致性

### 备注
此规则旨在确保 `data.js` 中的代码保持与原始 `常看js.js` 文件的完全一致性，避免在搬运过程中引入任何人为的修改或"优化"。特别强调函数体内容的绝对一致性，同时允许在原函数缺少调用案例时适当补足，以提高代码的可读性和实用性。