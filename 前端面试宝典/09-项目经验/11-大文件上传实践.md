# å¤§æ–‡ä»¶ä¸Šä¼ å®è·µ

> å¤§æ–‡ä»¶ä¸Šä¼ æ˜¯å‰ç«¯é¡¹ç›®ä¸­çš„å¸¸è§éœ€æ±‚ï¼Œæ¶‰åŠæ–‡ä»¶åˆ‡ç‰‡ã€æ–­ç‚¹ç»­ä¼ ã€è¿›åº¦ç›‘æ§ç­‰å¤šé¡¹æŠ€æœ¯ã€‚æœ¬æ–‡è¯¦ç»†ä»‹ç»å¤§æ–‡ä»¶ä¸Šä¼ çš„å®Œæ•´è§£å†³æ–¹æ¡ˆã€‚

## æ¦‚è¿°

å¤§æ–‡ä»¶ä¸Šä¼ åœ¨ç°ä»£Webåº”ç”¨ä¸­æ˜¯ä¸€ä¸ªé‡è¦çš„åŠŸèƒ½éœ€æ±‚ï¼Œç‰¹åˆ«æ˜¯åœ¨æ–‡æ¡£ç®¡ç†ã€è§†é¢‘ä¸Šä¼ ã€æ•°æ®å¯¼å…¥ç­‰åœºæ™¯ä¸­ã€‚ä¼ ç»Ÿçš„æ–‡ä»¶ä¸Šä¼ æ–¹å¼åœ¨å¤„ç†å¤§æ–‡ä»¶æ—¶ä¼šé‡åˆ°ä»¥ä¸‹é—®é¢˜ï¼š

- **è¶…æ—¶é—®é¢˜**ï¼šå¤§æ–‡ä»¶ä¼ è¾“æ—¶é—´é•¿ï¼Œå®¹æ˜“è¶…æ—¶
- **å†…å­˜å ç”¨**ï¼šä¸€æ¬¡æ€§ä¸Šä¼ å¤§æ–‡ä»¶ä¼šå ç”¨å¤§é‡å†…å­˜
- **ç½‘ç»œä¸ç¨³å®š**ï¼šç½‘ç»œä¸­æ–­ä¼šå¯¼è‡´é‡æ–°ä¸Šä¼ 
- **ç”¨æˆ·ä½“éªŒ**ï¼šæ— æ³•æ˜¾ç¤ºå‡†ç¡®çš„ä¸Šä¼ è¿›åº¦

## æ ¸å¿ƒæŠ€æœ¯æ–¹æ¡ˆ

### 1. æ–‡ä»¶åˆ‡ç‰‡ï¼ˆFile Chunkingï¼‰

å°†å¤§æ–‡ä»¶åˆ‡åˆ†ä¸ºå¤šä¸ªå°å—ï¼Œåˆ†åˆ«ä¸Šä¼ ï¼š

```javascript
/**
 * @description æ–‡ä»¶åˆ‡ç‰‡å·¥å…·ç±»
 */
class FileChunker {
  constructor(file, chunkSize = 2 * 1024 * 1024) {
    this.file = file;
    this.chunkSize = chunkSize;
    this.totalChunks = Math.ceil(file.size / chunkSize);
  }

  /**
   * @description åˆ›å»ºæ–‡ä»¶åˆ‡ç‰‡ï¼Œè¿”å›åˆ‡ç‰‡æ•°ç»„
   * æ¯ä¸ªåˆ‡ç‰‡åŒ…å«ç´¢å¼•ã€æ•°æ®ã€ä½ç½®ä¿¡æ¯ç­‰è¯¦ç»†ä¿¡æ¯
   */
  createChunks() {
    const chunks = [];                    // å­˜å‚¨æ‰€æœ‰åˆ‡ç‰‡çš„æ•°ç»„
    let start = 0;                       // å½“å‰åˆ‡ç‰‡çš„èµ·å§‹ä½ç½®

    for (let i = 0; i < this.totalChunks; i++) {
      const end = Math.min(start + this.chunkSize, this.file.size);  // è®¡ç®—åˆ‡ç‰‡ç»“æŸä½ç½®
      const chunk = this.file.slice(start, end);                     // ä½¿ç”¨File.slice()åˆ›å»ºåˆ‡ç‰‡

      chunks.push({
        index: i,          // åˆ‡ç‰‡ç´¢å¼•ï¼Œç”¨äºæ ‡è¯†åˆ‡ç‰‡é¡ºåº
        chunk: chunk,      // åˆ‡ç‰‡æ•°æ®å¯¹è±¡
        start: start,      // åˆ‡ç‰‡åœ¨åŸæ–‡ä»¶ä¸­çš„èµ·å§‹ä½ç½®
        end: end,          // åˆ‡ç‰‡åœ¨åŸæ–‡ä»¶ä¸­çš„ç»“æŸä½ç½®
        size: chunk.size,  // åˆ‡ç‰‡å¤§å°ï¼ˆå­—èŠ‚ï¼‰
        hash: null         // åˆ‡ç‰‡hashå€¼å ä½ç¬¦ï¼Œå¦‚éœ€è¦å¯åç»­è®¡ç®—
      });

      start = end;  // æ›´æ–°ä¸‹ä¸€ä¸ªåˆ‡ç‰‡çš„èµ·å§‹ä½ç½®
    }

    return chunks;
  }

  /**
   * @description è®¡ç®—æ•´ä¸ªæ–‡ä»¶çš„MD5 hashå€¼
   * æ³¨æ„ï¼šè¿™é‡Œè®¡ç®—çš„æ˜¯æ•´ä¸ªæ–‡ä»¶çš„hashï¼Œä¸æ˜¯å•ä¸ªåˆ‡ç‰‡çš„hash
   * ç”¨äºæ–‡ä»¶å”¯ä¸€æ ‡è¯†ã€å»é‡æ£€æµ‹ã€å®Œæ•´æ€§éªŒè¯ã€æ–­ç‚¹ç»­ä¼ ç­‰åŠŸèƒ½
   * ä½¿ç”¨Web Workerå¼‚æ­¥è®¡ç®—ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
   */
  async calculateFileHash() {
    return new Promise((resolve, reject) => {
      // åˆ›å»ºWeb Workeræ¥å¤„ç†hashè®¡ç®—ï¼Œé¿å…é˜»å¡UI
      const worker = new Worker('./js/hash-worker.js');

      // å‘Workerå‘é€æ–‡ä»¶å’Œåˆ‡ç‰‡ä¿¡æ¯
      worker.postMessage({
        file: this.file,
        chunks: this.createChunks()
      });

      // ç›‘å¬Workerè¿”å›çš„è®¡ç®—ç»“æœ
      worker.onmessage = function(e) {
        const { hash } = e.data;
        resolve(hash);      // è¿”å›è®¡ç®—å¾—åˆ°çš„æ–‡ä»¶hashå€¼
        worker.terminate(); // è®¡ç®—å®Œæˆåç»ˆæ­¢Worker
      };

      // å¤„ç†Workerè®¡ç®—è¿‡ç¨‹ä¸­çš„é”™è¯¯
      worker.onerror = function(error) {
        reject(error);
        worker.terminate();
      };
    });
  }

  // ========== åˆ†ç‰‡Hashè®¡ç®—æ–¹æ³• ==========

  /**
   * @description ä½¿ç”¨SparkMD5è®¡ç®—å•ä¸ªåˆ‡ç‰‡hashï¼ˆæ¨èæ–¹æ³•ï¼‰
   * ä¼˜ç‚¹ï¼šä¸“ä¸ºå¤§æ–‡ä»¶è®¾è®¡ï¼Œæ”¯æŒå¢é‡è®¡ç®—ï¼Œæ€§èƒ½æ›´å¥½ï¼Œä¸æ•´ä½“æ–‡ä»¶hashç®—æ³•ä¸€è‡´
   *
   * ä½¿ç”¨å‰éœ€è¦å¼•å…¥SparkMD5åº“ï¼š
   * <script src="https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.2/spark-md5.min.js"></script>
   */
  async calculateChunkHash(chunk) {
    if (typeof SparkMD5 === 'undefined') {
      console.error('âš ï¸ æœªæ£€æµ‹åˆ°SparkMD5åº“ï¼Œè¯·å…ˆå¼•å…¥:');
      console.error('<script src="https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.2/spark-md5.min.js"></script>');
      throw new Error('SparkMD5åº“æœªåŠ è½½');
    }

    return new Promise((resolve, reject) => {
      const reader = new FileReader();

      reader.onload = function(e) {
        try {
          const arrayBuffer = e.target.result;

          // ä½¿ç”¨SparkMD5çš„ArrayBufferæ–¹æ³•ï¼Œä¸æ–‡ä»¶hashè®¡ç®—ä¿æŒä¸€è‡´
          const spark = new SparkMD5.ArrayBuffer();
          spark.append(arrayBuffer);           // æ·»åŠ æ•°æ®åˆ°hashè®¡ç®—å™¨
          const hash = spark.end();            // å®Œæˆè®¡ç®—å¹¶è·å–ç»“æœ

          console.log(`SparkMD5åˆ‡ç‰‡hash: ${hash}`);
          resolve(hash);
        } catch (error) {
          reject(error);
        }
      };

      reader.onerror = reject;
      // å…³é”®ï¼šå¿…é¡»ä½¿ç”¨readAsArrayBufferè¯»å–åŸå§‹äºŒè¿›åˆ¶æ•°æ®
      reader.readAsArrayBuffer(chunk);
    });
  }

  /**
   * @description åˆ›å»ºåŒ…å«hashçš„åˆ‡ç‰‡æ•°ç»„ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
   * å¦‚æœéœ€è¦å¯¹æ¯ä¸ªåˆ‡ç‰‡è¿›è¡Œå®Œæ•´æ€§éªŒè¯ï¼Œå¯ä»¥ä½¿ç”¨æ­¤æ–¹æ³•
   * æ³¨æ„ï¼šè®¡ç®—æ‰€æœ‰åˆ‡ç‰‡çš„hashä¼šå¢åŠ å¤„ç†æ—¶é—´
   */
  async createChunksWithHash(useHash = false) {
    const chunks = this.createChunks();

    if (!useHash) {
      console.log('è·³è¿‡åˆ‡ç‰‡hashè®¡ç®—ï¼Œæå‡æ€§èƒ½');
      return chunks;
    }

    // æ£€æŸ¥SparkMD5æ˜¯å¦å¯ç”¨
    if (typeof SparkMD5 === 'undefined') {
      console.warn('âš ï¸ SparkMD5åº“æœªåŠ è½½ï¼Œè·³è¿‡åˆ‡ç‰‡hashè®¡ç®—');
      console.warn('å¦‚éœ€è®¡ç®—åˆ‡ç‰‡hashï¼Œè¯·å¼•å…¥: <script src="https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.2/spark-md5.min.js"></script>');
      return chunks;
    }

    console.log('å¼€å§‹ä½¿ç”¨SparkMD5è®¡ç®—æ‰€æœ‰åˆ‡ç‰‡çš„hashå€¼...');

    // å¹¶è¡Œè®¡ç®—æ‰€æœ‰åˆ‡ç‰‡çš„hashï¼ˆæ³¨æ„ï¼šå¯èƒ½å ç”¨å¤§é‡CPUèµ„æºï¼‰
    const chunksWithHash = await Promise.all(
      chunks.map(async (chunkData, index) => {
        try {
          // ä½¿ç”¨æ¨èçš„SparkMD5æ–¹æ³•è®¡ç®—åˆ‡ç‰‡hash
          const hash = await this.calculateChunkHash(chunkData.chunk);
          console.log(`åˆ‡ç‰‡${index}hashè®¡ç®—å®Œæˆ: ${hash}`);

          return {
            ...chunkData,
            hash: hash  // æ·»åŠ è®¡ç®—å¾—åˆ°çš„hashå€¼
          };
        } catch (error) {
          console.error(`åˆ‡ç‰‡${index}hashè®¡ç®—å¤±è´¥:`, error);
          return {
            ...chunkData,
            hash: null  // hashè®¡ç®—å¤±è´¥æ—¶è®¾ä¸ºnull
          };
        }
      })
    );

    console.log('æ‰€æœ‰åˆ‡ç‰‡hashè®¡ç®—å®Œæˆ');
    return chunksWithHash;
  }

  /**
   * @description éªŒè¯å‰åç«¯åˆ‡ç‰‡hashä¸€è‡´æ€§çš„æµ‹è¯•æ–¹æ³•
   * ç”¨äºè°ƒè¯•å’ŒéªŒè¯å‰åç«¯hashè®¡ç®—ç»“æœæ˜¯å¦ä¸€è‡´
   */
  async testChunkHashConsistency(chunkIndex = 0) {
    const chunks = this.createChunks();
    if (chunkIndex >= chunks.length) {
      throw new Error(`åˆ‡ç‰‡ç´¢å¼•${chunkIndex}è¶…å‡ºèŒƒå›´ï¼Œæ€»åˆ‡ç‰‡æ•°ï¼š${chunks.length}`);
    }

    const chunk = chunks[chunkIndex];

    try {
      // æ£€æŸ¥SparkMD5æ˜¯å¦å¯ç”¨
      if (typeof SparkMD5 === 'undefined') {
        throw new Error('SparkMD5åº“æœªåŠ è½½ï¼Œæ— æ³•è¿›è¡Œhashä¸€è‡´æ€§æµ‹è¯•');
      }

      // å‰ç«¯ä½¿ç”¨SparkMD5è®¡ç®—hash
      const frontendHash = await this.calculateChunkHash(chunk.chunk);
      console.log('å‰ç«¯SparkMD5è®¡ç®—çš„hash:', frontendHash);

      // æ¨¡æ‹Ÿä¸Šä¼ åˆ°åç«¯è¿›è¡ŒéªŒè¯
      const formData = new FormData();
      formData.append('chunk', chunk.chunk);
      formData.append('chunkIndex', chunkIndex);
      formData.append('expectedHash', frontendHash);
      formData.append('hashAlgorithm', 'md5'); // æ˜ç¡®æŒ‡å®šç®—æ³•ç±»å‹

      const response = await fetch('/api/test/chunk-hash', {
        method: 'POST',
        body: formData
      });

      const result = await response.json();

      console.log('åç«¯è®¡ç®—çš„hash:', result.backendHash);
      console.log('hashæ˜¯å¦ä¸€è‡´:', result.isConsistent);

      if (!result.isConsistent) {
        console.error('âš ï¸ å‰åç«¯hashä¸ä¸€è‡´ï¼Œå¯èƒ½çš„åŸå› :');
        console.error('1. å‰åç«¯ä½¿ç”¨äº†ä¸åŒçš„hashç®—æ³•');
        console.error('2. æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«ä¿®æ”¹');
        console.error('3. ç¼–ç æ–¹å¼ä¸åŒ');
        console.error('4. è¯»å–æ–¹å¼å·®å¼‚');
        console.error('5. åç«¯æœªä½¿ç”¨MD5ç®—æ³•');
        console.error('å‰ç«¯ç®—æ³•: SparkMD5 (MD5)');
        console.error('åç«¯ç®—æ³•:', result.algorithm || 'æœªçŸ¥');
      } else {
        console.log('âœ… å‰åç«¯hashä¸€è‡´ï¼Œåˆ‡ç‰‡å®Œæ•´æ€§éªŒè¯é€šè¿‡');
      }

      return result.isConsistent;
    } catch (error) {
      console.error('hashä¸€è‡´æ€§æµ‹è¯•å¤±è´¥:', error);
      return false;
    }
  }
}
```

### 2. Hashè®¡ç®—Worker

ä¸ºäº†ä¸é˜»å¡ä¸»çº¿ç¨‹ï¼Œä½¿ç”¨Web Workerè®¡ç®—æ–‡ä»¶hashï¼š

```javascript
// /public/workers/hash-worker.js
// æ³¨æ„ï¼šè¿™é‡Œè®¡ç®—çš„æ˜¯æ•´ä¸ªæ–‡ä»¶çš„MD5å“ˆå¸Œå€¼ï¼Œä¸æ˜¯å•ä¸ªåˆ‡ç‰‡çš„hash
// é€šè¿‡ä¾æ¬¡è¯»å–æ‰€æœ‰åˆ‡ç‰‡å†…å®¹ï¼Œå¢é‡è®¡ç®—æ•´ä¸ªæ–‡ä»¶çš„hashå€¼
importScripts('/libs/spark-md5.min.js');

self.onmessage = function(e) {
  const { file, chunks } = e.data;

  // åˆ›å»ºMD5è®¡ç®—å®ä¾‹ï¼Œç”¨äºå¢é‡è®¡ç®—æ•´ä¸ªæ–‡ä»¶çš„hash
  const spark = new SparkMD5.ArrayBuffer();
  const fileReader = new FileReader();
  let currentChunk = 0;

  /**
   * @description ä¾æ¬¡åŠ è½½æ¯ä¸ªåˆ‡ç‰‡è¿›è¡Œhashè®¡ç®—
   * è¿™æ˜¯ä¸€ä¸ªå¢é‡è®¡ç®—è¿‡ç¨‹ï¼šæ¯ä¸ªåˆ‡ç‰‡çš„å†…å®¹éƒ½ä¼šappendåˆ°åŒä¸€ä¸ªMD5è®¡ç®—å®ä¾‹ä¸­
   * æœ€ç»ˆå¾—åˆ°çš„æ˜¯æ•´ä¸ªæ–‡ä»¶çš„hashå€¼ï¼Œè€Œä¸æ˜¯å•ä¸ªåˆ‡ç‰‡çš„hash
   */
  function loadNext() {
    if (currentChunk < chunks.length) {
      // è¯»å–å½“å‰åˆ‡ç‰‡çš„å†…å®¹
      fileReader.readAsArrayBuffer(chunks[currentChunk].chunk);
    } else {
      // æ‰€æœ‰åˆ‡ç‰‡éƒ½å·²å¤„ç†å®Œæ¯•ï¼Œè®¡ç®—æœ€ç»ˆçš„æ–‡ä»¶hash
      const hash = spark.end();
      self.postMessage({ hash });
    }
  }

  fileReader.onload = function(e) {
    // å°†å½“å‰åˆ‡ç‰‡çš„å†…å®¹è¿½åŠ åˆ°MD5è®¡ç®—ä¸­
    // è¿™é‡Œæ˜¯å…³é”®ï¼šspark.append()æ˜¯å¢é‡è®¡ç®—ï¼Œä¼šå°†æ–°æ•°æ®æ·»åŠ åˆ°å·²æœ‰çš„è®¡ç®—ä¸­
    spark.append(e.target.result);
    currentChunk++;
    loadNext(); // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªåˆ‡ç‰‡
  };

  fileReader.onerror = function() {
    self.postMessage({ error: 'Hash calculation failed' });
  };

  loadNext(); // å¼€å§‹å¤„ç†ç¬¬ä¸€ä¸ªåˆ‡ç‰‡
};

/**
 * å·¥ä½œåŸç†è¯´æ˜ï¼š
 * 1. æ¥æ”¶æ–‡ä»¶çš„æ‰€æœ‰åˆ‡ç‰‡ä¿¡æ¯
 * 2. ä¾æ¬¡è¯»å–æ¯ä¸ªåˆ‡ç‰‡çš„äºŒè¿›åˆ¶å†…å®¹
 * 3. å°†æ¯ä¸ªåˆ‡ç‰‡çš„å†…å®¹è¿½åŠ åˆ°SparkMD5å®ä¾‹ä¸­è¿›è¡Œå¢é‡è®¡ç®—
 * 4. å¤„ç†å®Œæ‰€æœ‰åˆ‡ç‰‡åï¼Œå¾—åˆ°æ•´ä¸ªæ–‡ä»¶çš„MD5å“ˆå¸Œå€¼
 *
 * ä¼˜åŠ¿ï¼š
 * - é¿å…ä¸€æ¬¡æ€§åŠ è½½å¤§æ–‡ä»¶åˆ°å†…å­˜
 * - åœ¨Workerçº¿ç¨‹ä¸­è®¡ç®—ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
 * - å¢é‡è®¡ç®—ï¼Œå†…å­˜ä½¿ç”¨ç¨³å®š
 * - è®¡ç®—ç»“æœä¸ç›´æ¥å¯¹æ•´ä¸ªæ–‡ä»¶è®¡ç®—hashå®Œå…¨ç›¸åŒ
 */
```

### 3. ä¸Šä¼ ç®¡ç†å™¨

```javascript
/**
 * @description å¤§æ–‡ä»¶ä¸Šä¼ ç®¡ç†å™¨
 * è´Ÿè´£ç®¡ç†æ–‡ä»¶åˆ‡ç‰‡ã€ä¸Šä¼ é˜Ÿåˆ—ã€å¹¶å‘æ§åˆ¶ã€é”™è¯¯é‡è¯•ç­‰åŠŸèƒ½
 */
class LargeFileUploader {
  /**
   * @param {Object} options é…ç½®é€‰é¡¹
   * @param {string} options.baseURL ä¸Šä¼ æ¥å£åŸºç¡€URL
   * @param {number} options.chunkSize åˆ‡ç‰‡å¤§å°ï¼ˆå­—èŠ‚ï¼‰
   * @param {number} options.concurrency å¹¶å‘ä¸Šä¼ æ•°é‡
   * @param {number} options.retryTimes é‡è¯•æ¬¡æ•°
   * @param {Function} options.onProgress è¿›åº¦å›è°ƒå‡½æ•°
   * @param {Function} options.onError é”™è¯¯å›è°ƒå‡½æ•°
   * @param {Function} options.onSuccess æˆåŠŸå›è°ƒå‡½æ•°
   */
  constructor(options = {}) {
    // åŸºç¡€é…ç½®
    this.baseURL = options.baseURL || '/api/upload';              // ä¸Šä¼ APIçš„åŸºç¡€URL
    this.chunkSize = options.chunkSize || 2 * 1024 * 1024;       // é»˜è®¤åˆ‡ç‰‡å¤§å°ï¼š2MB
    this.concurrency = options.concurrency || 3;                 // é»˜è®¤å¹¶å‘æ•°ï¼š3ä¸ªåˆ‡ç‰‡åŒæ—¶ä¸Šä¼ 
    this.retryTimes = options.retryTimes || 3;                   // é»˜è®¤é‡è¯•æ¬¡æ•°ï¼š3æ¬¡

    // äº‹ä»¶å›è°ƒå‡½æ•°
    this.onProgress = options.onProgress || (() => {});          // ä¸Šä¼ è¿›åº¦å›è°ƒ
    this.onError = options.onError || (() => {});               // é”™è¯¯å¤„ç†å›è°ƒ
    this.onSuccess = options.onSuccess || (() => {});           // æˆåŠŸå®Œæˆå›è°ƒ

    // å†…éƒ¨çŠ¶æ€ç®¡ç†
    this.uploadQueue = [];           // å¾…ä¸Šä¼ åˆ‡ç‰‡çš„é˜Ÿåˆ—
    this.uploadingCount = 0;         // å½“å‰æ­£åœ¨ä¸Šä¼ çš„åˆ‡ç‰‡æ•°é‡
    this.uploadedChunks = new Set(); // å·²æˆåŠŸä¸Šä¼ çš„åˆ‡ç‰‡ç´¢å¼•é›†åˆ
    this.failedChunks = new Set();   // ä¸Šä¼ å¤±è´¥çš„åˆ‡ç‰‡ç´¢å¼•é›†åˆ
  }

  /**
   * @description ä¸Šä¼ æ–‡ä»¶çš„ä¸»æµç¨‹
   * åŒ…å«æ–‡ä»¶åˆ‡ç‰‡ã€ç§’ä¼ æ£€æµ‹ã€æ–­ç‚¹ç»­ä¼ ã€å¹¶å‘ä¸Šä¼ ã€æ–‡ä»¶åˆå¹¶ç­‰å®Œæ•´æµç¨‹
   * @param {File} file è¦ä¸Šä¼ çš„æ–‡ä»¶å¯¹è±¡
   * @param {Object} options ä¸Šä¼ é€‰é¡¹é…ç½®
   */
  async upload(file, options = {}) {
    try {
      // æ­¥éª¤1: åˆ›å»ºæ–‡ä»¶åˆ‡ç‰‡
      // å°†å¤§æ–‡ä»¶åˆ†å‰²æˆå¤šä¸ªå°çš„åˆ‡ç‰‡ï¼Œä¾¿äºåˆ†åˆ«ä¸Šä¼ å’Œç®¡ç†
      console.log('å¼€å§‹åˆ›å»ºæ–‡ä»¶åˆ‡ç‰‡...');
      const chunker = new FileChunker(file, this.chunkSize);
      const chunks = chunker.createChunks();
      console.log(`æ–‡ä»¶åˆ‡ç‰‡å®Œæˆï¼Œå…±ç”Ÿæˆ ${chunks.length} ä¸ªåˆ‡ç‰‡`);

      // æ­¥éª¤2: è®¡ç®—æ–‡ä»¶hashå€¼
      // é€šè¿‡è®¡ç®—æ•´ä¸ªæ–‡ä»¶çš„MD5å€¼æ¥å”¯ä¸€æ ‡è¯†æ–‡ä»¶ï¼Œç”¨äºå»é‡å’Œå®Œæ•´æ€§æ ¡éªŒ
      console.log('å¼€å§‹è®¡ç®—æ–‡ä»¶hash...');
      const fileHash = await chunker.calculateFileHash();
      console.log(`æ–‡ä»¶hashè®¡ç®—å®Œæˆ: ${fileHash}`);

      // æ­¥éª¤3: æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨ï¼ˆå®ç°ç§’ä¼ åŠŸèƒ½ï¼‰
      // å¦‚æœæœåŠ¡å™¨å·²æœ‰ç›¸åŒhashçš„æ–‡ä»¶ï¼Œåˆ™ç›´æ¥è¿”å›æˆåŠŸï¼Œæ— éœ€é‡æ–°ä¸Šä¼ 
      console.log('æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨...');
      const existsResult = await this.checkFileExists(fileHash, file.name);
      if (existsResult.exists) {
        console.log('æ–‡ä»¶å·²å­˜åœ¨ï¼Œæ‰§è¡Œç§’ä¼ ');
        this.onSuccess({
          fileHash,
          fileName: file.name,
          fileSize: file.size,
          message: 'æ–‡ä»¶ç§’ä¼ æˆåŠŸ'
        });
        return;
      }

      // æ­¥éª¤4: è·å–å·²ä¸Šä¼ çš„åˆ‡ç‰‡ä¿¡æ¯ï¼ˆå®ç°æ–­ç‚¹ç»­ä¼ åŠŸèƒ½ï¼‰
      // æŸ¥è¯¢æœåŠ¡å™¨ä¸Šå·²ç»ä¸Šä¼ æˆåŠŸçš„åˆ‡ç‰‡ï¼Œé¿å…é‡å¤ä¸Šä¼ 
      console.log('è·å–å·²ä¸Šä¼ çš„åˆ‡ç‰‡ä¿¡æ¯...');
      const uploadedChunks = await this.getUploadedChunks(fileHash);
      this.uploadedChunks = new Set(uploadedChunks);
      console.log(`å‘ç° ${uploadedChunks.length} ä¸ªå·²ä¸Šä¼ çš„åˆ‡ç‰‡`);

      // æ­¥éª¤5: å‡†å¤‡ä¸Šä¼ é˜Ÿåˆ—
      // è¿‡æ»¤æ‰å·²ä¸Šä¼ çš„åˆ‡ç‰‡ï¼Œåªä¸Šä¼ ç¼ºå¤±çš„éƒ¨åˆ†
      this.uploadQueue = chunks
        .filter(chunk => !this.uploadedChunks.has(chunk.index))  // è¿‡æ»¤å·²ä¸Šä¼ çš„åˆ‡ç‰‡
        .map(chunk => ({
          ...chunk,
          fileHash,                    // æ·»åŠ æ–‡ä»¶hashæ ‡è¯†
          fileName: file.name,         // æ·»åŠ æ–‡ä»¶å
          totalChunks: chunks.length,  // æ·»åŠ æ€»åˆ‡ç‰‡æ•°
          retryCount: 0               // åˆå§‹åŒ–é‡è¯•è®¡æ•°
        }));
      console.log(`å‡†å¤‡ä¸Šä¼  ${this.uploadQueue.length} ä¸ªåˆ‡ç‰‡`);

      // æ­¥éª¤6: å¼€å§‹å¹¶å‘ä¸Šä¼ åˆ‡ç‰‡
      // ä½¿ç”¨å¹¶å‘æ§åˆ¶æœºåˆ¶ä¸Šä¼ æ‰€æœ‰å¾…ä¸Šä¼ çš„åˆ‡ç‰‡
      console.log('å¼€å§‹ä¸Šä¼ åˆ‡ç‰‡...');
      await this.startUpload();
      console.log('æ‰€æœ‰åˆ‡ç‰‡ä¸Šä¼ å®Œæˆ');

      // æ­¥éª¤7: åˆå¹¶æ–‡ä»¶åˆ‡ç‰‡
      // åœ¨æœåŠ¡å™¨ç«¯å°†æ‰€æœ‰åˆ‡ç‰‡åˆå¹¶æˆå®Œæ•´çš„æ–‡ä»¶
      console.log('å¼€å§‹åˆå¹¶æ–‡ä»¶åˆ‡ç‰‡...');
      await this.mergeChunks(fileHash, file.name, chunks.length);
      console.log('æ–‡ä»¶åˆå¹¶å®Œæˆ');

      // ä¸Šä¼ æˆåŠŸï¼Œè§¦å‘æˆåŠŸå›è°ƒ
      this.onSuccess({
        fileHash,
        fileName: file.name,
        fileSize: file.size,
        message: 'æ–‡ä»¶ä¸Šä¼ æˆåŠŸ'
      });

    } catch (error) {
      // æ•è·å¹¶å¤„ç†ä¸Šä¼ è¿‡ç¨‹ä¸­çš„ä»»ä½•é”™è¯¯
      console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
      this.onError(error);
    }
  }

  /**
   * @description æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
   */
  async checkFileExists(fileHash, fileName) {
    const response = await fetch(`${this.baseURL}/check`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ fileHash, fileName })
    });
    return response.json();
  }

  /**
   * @description è·å–å·²ä¸Šä¼ çš„åˆ‡ç‰‡
   */
  async getUploadedChunks(fileHash) {
    const response = await fetch(`${this.baseURL}/chunks/${fileHash}`);
    const result = await response.json();
    return result.uploadedChunks || [];
  }

  /**
   * @description å¼€å§‹ä¸Šä¼ åˆ‡ç‰‡
   */
  async startUpload() {
    return new Promise((resolve, reject) => {
      this.resolveUpload = resolve;
      this.rejectUpload = reject;

      // å¯åŠ¨å¹¶å‘ä¸Šä¼ 
      for (let i = 0; i < this.concurrency; i++) {
        this.uploadNext();
      }
    });
  }

  /**
   * @description ä¸Šä¼ ä¸‹ä¸€ä¸ªåˆ‡ç‰‡
   */
  async uploadNext() {
    if (this.uploadQueue.length === 0) {
      this.uploadingCount--;
      if (this.uploadingCount === 0) {
        this.resolveUpload();
      }
      return;
    }

    const chunkData = this.uploadQueue.shift();
    this.uploadingCount++;

    try {
      await this.uploadChunk(chunkData);
      this.uploadedChunks.add(chunkData.index);
      this.updateProgress();
      this.uploadNext();
    } catch (error) {
      await this.handleChunkError(chunkData, error);
    }
  }

  /**
   * @description ä¸Šä¼ å•ä¸ªåˆ‡ç‰‡
   */
  async uploadChunk(chunkData) {
    const formData = new FormData();
    formData.append('chunk', chunkData.chunk);
    formData.append('fileHash', chunkData.fileHash);
    formData.append('fileName', chunkData.fileName);
    formData.append('chunkIndex', chunkData.index);
    formData.append('totalChunks', chunkData.totalChunks);

    const response = await fetch(`${this.baseURL}/chunk`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      throw new Error(`Upload failed: ${response.statusText}`);
    }

    return response.json();
  }

  /**
   * @description å¤„ç†åˆ‡ç‰‡ä¸Šä¼ é”™è¯¯
   */
  async handleChunkError(chunkData, error) {
    chunkData.retryCount++;

    if (chunkData.retryCount <= this.retryTimes) {
      // é‡è¯•
      await new Promise(resolve => setTimeout(resolve, 1000 * chunkData.retryCount));
      this.uploadQueue.unshift(chunkData);
    } else {
      // è¶…è¿‡é‡è¯•æ¬¡æ•°
      this.failedChunks.add(chunkData.index);
      this.rejectUpload(new Error(`Chunk ${chunkData.index} upload failed after ${this.retryTimes} retries`));
    }

    this.uploadNext();
  }

  /**
   * @description æ›´æ–°ä¸Šä¼ è¿›åº¦
   */
  updateProgress() {
    const totalChunks = this.uploadedChunks.size + this.uploadQueue.length + this.failedChunks.size;
    const uploadedChunks = this.uploadedChunks.size;
    const progress = (uploadedChunks / totalChunks) * 100;

    this.onProgress({
      progress,
      uploadedChunks,
      totalChunks,
      failedChunks: this.failedChunks.size
    });
  }

  /**
   * @description åˆå¹¶æ–‡ä»¶åˆ‡ç‰‡
   */
  async mergeChunks(fileHash, fileName, totalChunks) {
    const response = await fetch(`${this.baseURL}/merge`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        fileHash,
        fileName,
        totalChunks
      })
    });

    if (!response.ok) {
      throw new Error('File merge failed');
    }

    return response.json();
  }

  /**
   * @description æš‚åœä¸Šä¼ 
   */
  pause() {
    this.isPaused = true;
    this.uploadQueue = [];
  }

  /**
   * @description æ¢å¤ä¸Šä¼ 
   */
  resume() {
    this.isPaused = false;
    this.startUpload();
  }

  /**
   * @description å–æ¶ˆä¸Šä¼ 
   */
  cancel() {
    this.isPaused = true;
    this.uploadQueue = [];
    this.uploadedChunks.clear();
    this.failedChunks.clear();
  }
}
```

## ä½¿ç”¨ç¤ºä¾‹

### 1. åŸºç¡€ä½¿ç”¨

```javascript
// åˆ›å»ºä¸Šä¼ å™¨å®ä¾‹
const uploader = new LargeFileUploader({
  baseURL: '/api/upload',
  chunkSize: 2 * 1024 * 1024, // 2MB
  concurrency: 3,
  retryTimes: 3,
  onProgress: (progressInfo) => {
    console.log(`ä¸Šä¼ è¿›åº¦: ${progressInfo.progress.toFixed(2)}%`);
    updateProgressBar(progressInfo.progress);
  },
  onError: (error) => {
    console.error('ä¸Šä¼ å¤±è´¥:', error);
    showErrorMessage(error.message);
  },
  onSuccess: (result) => {
    console.log('ä¸Šä¼ æˆåŠŸ:', result);
    showSuccessMessage('æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼');
  }
});

// æ–‡ä»¶é€‰æ‹©å¤„ç†
document.getElementById('fileInput').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  // æ–‡ä»¶å¤§å°æ£€æŸ¥
  const maxSize = 500 * 1024 * 1024; // 500MB
  if (file.size > maxSize) {
    alert('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡500MB');
    return;
  }

  // å¼€å§‹ä¸Šä¼ 
  try {
    await uploader.upload(file);
  } catch (error) {
    console.error('ä¸Šä¼ è¿‡ç¨‹ä¸­å‡ºé”™:', error);
  }
});
```

### 2. Vueç»„ä»¶å®ç°

```vue
<template>
  <div class="large-file-uploader">
    <div class="upload-area" @click="selectFile" @drop="handleDrop" @dragover.prevent>
      <input ref="fileInput" type="file" @change="handleFileSelect" style="display: none">
      <div v-if="!uploading" class="upload-placeholder">
        <i class="upload-icon">ğŸ“</i>
        <p>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„</p>
        <p class="upload-tip">æ”¯æŒæœ€å¤§500MBçš„æ–‡ä»¶ä¸Šä¼ </p>
      </div>
      <div v-else class="upload-progress">
        <div class="progress-info">
          <h3>{{ currentFile.name }}</h3>
          <p>{{ formatFileSize(currentFile.size) }}</p>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" :style="{ width: progress + '%' }"></div>
        </div>
        <div class="progress-text">
          {{ progress.toFixed(1) }}% ({{ uploadedChunks }}/{{ totalChunks }})
        </div>
        <div class="upload-controls">
          <button @click="pauseUpload" v-if="!isPaused">æš‚åœ</button>
          <button @click="resumeUpload" v-if="isPaused">ç»§ç»­</button>
          <button @click="cancelUpload">å–æ¶ˆ</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { LargeFileUploader } from '@/utils/large-file-uploader';

export default {
  name: 'LargeFileUploader',
  data() {
    return {
      uploader: null,
      uploading: false,
      isPaused: false,
      progress: 0,
      uploadedChunks: 0,
      totalChunks: 0,
      currentFile: null
    };
  },
  mounted() {
    this.initUploader();
  },
  methods: {
    initUploader() {
      this.uploader = new LargeFileUploader({
        baseURL: '/api/upload',
        chunkSize: 2 * 1024 * 1024,
        concurrency: 3,
        retryTimes: 3,
        onProgress: this.handleProgress,
        onError: this.handleError,
        onSuccess: this.handleSuccess
      });
    },

    selectFile() {
      this.$refs.fileInput.click();
    },

    handleFileSelect(event) {
      const file = event.target.files[0];
      if (file) {
        this.startUpload(file);
      }
    },

    handleDrop(event) {
      event.preventDefault();
      const files = event.dataTransfer.files;
      if (files.length > 0) {
        this.startUpload(files[0]);
      }
    },

    async startUpload(file) {
      // æ–‡ä»¶éªŒè¯
      if (!this.validateFile(file)) {
        return;
      }

      this.currentFile = file;
      this.uploading = true;
      this.progress = 0;
      this.uploadedChunks = 0;
      this.totalChunks = 0;

      try {
        await this.uploader.upload(file);
      } catch (error) {
        console.error('ä¸Šä¼ å¤±è´¥:', error);
      }
    },

    validateFile(file) {
      const maxSize = 500 * 1024 * 1024; // 500MB
      const allowedTypes = [
        'video/mp4', 'video/avi', 'video/mov',
        'application/pdf', 'application/zip',
        'image/jpeg', 'image/png'
      ];

      if (file.size > maxSize) {
        this.$message.error('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡500MB');
        return false;
      }

      if (!allowedTypes.includes(file.type)) {
        this.$message.error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹');
        return false;
      }

      return true;
    },

    handleProgress(progressInfo) {
      this.progress = progressInfo.progress;
      this.uploadedChunks = progressInfo.uploadedChunks;
      this.totalChunks = progressInfo.totalChunks;
    },

    handleError(error) {
      this.uploading = false;
      this.$message.error(`ä¸Šä¼ å¤±è´¥: ${error.message}`);
    },

    handleSuccess(result) {
      this.uploading = false;
      this.$message.success('æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼');
      this.$emit('upload-success', result);
    },

    pauseUpload() {
      this.uploader.pause();
      this.isPaused = true;
    },

    resumeUpload() {
      this.uploader.resume();
      this.isPaused = false;
    },

    cancelUpload() {
      this.uploader.cancel();
      this.uploading = false;
      this.isPaused = false;
      this.currentFile = null;
    },

    formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
  }
};
</script>

<style scoped>
.large-file-uploader {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

.upload-area {
  border: 2px dashed #d9d9d9;
  border-radius: 8px;
  padding: 40px;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.3s;
}

.upload-area:hover {
  border-color: #1890ff;
}

.upload-placeholder .upload-icon {
  font-size: 48px;
  margin-bottom: 16px;
  display: block;
}

.upload-tip {
  color: #999;
  font-size: 14px;
  margin-top: 8px;
}

.upload-progress {
  text-align: left;
}

.progress-info h3 {
  margin: 0 0 8px 0;
  font-size: 16px;
}

.progress-info p {
  margin: 0;
  color: #666;
  font-size: 14px;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background-color: #f0f0f0;
  border-radius: 4px;
  margin: 16px 0;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background-color: #1890ff;
  transition: width 0.3s;
}

.progress-text {
  font-size: 14px;
  color: #666;
  margin-bottom: 16px;
}

.upload-controls button {
  margin-right: 8px;
  padding: 6px 16px;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  background: white;
  cursor: pointer;
}

.upload-controls button:hover {
  border-color: #1890ff;
  color: #1890ff;
}
</style>

## åç«¯å®ç°

### 1. Node.js + Express å®ç°

```javascript
/**
 * @description å¤§æ–‡ä»¶ä¸Šä¼ åç«¯å®ç°
 */
const express = require('express');
const multer = require('multer');
const fs = require('fs-extra');
const path = require('path');
const crypto = require('crypto');
const { promisify } = require('util');

const app = express();
const upload = multer({ dest: 'temp/' });

// é…ç½®
const config = {
  uploadDir: './uploads',
  tempDir: './temp',
  chunkDir: './chunks'
};

// ç¡®ä¿ç›®å½•å­˜åœ¨
fs.ensureDirSync(config.uploadDir);
fs.ensureDirSync(config.tempDir);
fs.ensureDirSync(config.chunkDir);

/**
 * @description æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨ï¼ˆç§’ä¼ ï¼‰
 */
app.post('/api/upload/check', async (req, res) => {
  try {
    const { fileHash, fileName } = req.body;
    const filePath = path.join(config.uploadDir, fileName);

    if (await fs.pathExists(filePath)) {
      // éªŒè¯æ–‡ä»¶hash
      const existingHash = await calculateFileHash(filePath);
      if (existingHash === fileHash) {
        return res.json({
          exists: true,
          message: 'æ–‡ä»¶å·²å­˜åœ¨ï¼Œæ”¯æŒç§’ä¼ '
        });
      }
    }

    res.json({ exists: false });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @description è·å–å·²ä¸Šä¼ çš„åˆ‡ç‰‡åˆ—è¡¨
 */
app.get('/api/upload/chunks/:fileHash', async (req, res) => {
  try {
    const { fileHash } = req.params;
    const chunkDir = path.join(config.chunkDir, fileHash);

    if (!(await fs.pathExists(chunkDir))) {
      return res.json({ uploadedChunks: [] });
    }

    const files = await fs.readdir(chunkDir);
    const uploadedChunks = files
      .filter(file => file.endsWith('.chunk'))
      .map(file => parseInt(file.split('.')[0]))
      .sort((a, b) => a - b);

    res.json({ uploadedChunks });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @description ä¸Šä¼ å•ä¸ªåˆ‡ç‰‡
 */
app.post('/api/upload/chunk', upload.single('chunk'), async (req, res) => {
  try {
    const { fileHash, fileName, chunkIndex, totalChunks, chunkHash } = req.body;
    const chunkFile = req.file;

    if (!chunkFile) {
      return res.status(400).json({ error: 'åˆ‡ç‰‡æ–‡ä»¶ç¼ºå¤±' });
    }

    // å¦‚æœå‰ç«¯æä¾›äº†åˆ‡ç‰‡hashï¼Œè¿›è¡ŒéªŒè¯
    if (chunkHash) {
      const calculatedHash = await calculateFileHash(chunkFile.path);
      if (calculatedHash !== chunkHash) {
        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        await fs.remove(chunkFile.path);
        return res.status(400).json({
          error: 'åˆ‡ç‰‡hashéªŒè¯å¤±è´¥',
          expected: chunkHash,
          actual: calculatedHash
        });
      }
      console.log(`åˆ‡ç‰‡${chunkIndex}hashéªŒè¯é€šè¿‡: ${calculatedHash}`);
    }

    // åˆ›å»ºåˆ‡ç‰‡å­˜å‚¨ç›®å½•
    const chunkDir = path.join(config.chunkDir, fileHash);
    await fs.ensureDir(chunkDir);

    // ä¿å­˜åˆ‡ç‰‡
    const chunkPath = path.join(chunkDir, `${chunkIndex}.chunk`);
    await fs.move(chunkFile.path, chunkPath);

    // è®°å½•åˆ‡ç‰‡ä¿¡æ¯
    const chunkInfo = {
      index: parseInt(chunkIndex),
      size: chunkFile.size,
      hash: chunkHash || null,          // ä¿å­˜åˆ‡ç‰‡hashï¼ˆå¦‚æœæœ‰ï¼‰
      uploadTime: new Date().toISOString()
    };

    const infoPath = path.join(chunkDir, `${chunkIndex}.info`);
    await fs.writeJson(infoPath, chunkInfo);

    res.json({
      success: true,
      chunkIndex: parseInt(chunkIndex),
      hash: chunkHash || null,
      message: 'åˆ‡ç‰‡ä¸Šä¼ æˆåŠŸ'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @description åˆå¹¶æ–‡ä»¶åˆ‡ç‰‡
 */
app.post('/api/upload/merge', async (req, res) => {
  try {
    const { fileHash, fileName, totalChunks } = req.body;
    const chunkDir = path.join(config.chunkDir, fileHash);
    const outputPath = path.join(config.uploadDir, fileName);

    // æ£€æŸ¥æ‰€æœ‰åˆ‡ç‰‡æ˜¯å¦å­˜åœ¨
    const missingChunks = [];
    for (let i = 0; i < totalChunks; i++) {
      const chunkPath = path.join(chunkDir, `${i}.chunk`);
      if (!(await fs.pathExists(chunkPath))) {
        missingChunks.push(i);
      }
    }

    if (missingChunks.length > 0) {
      return res.status(400).json({
        error: 'åˆ‡ç‰‡ä¸å®Œæ•´',
        missingChunks
      });
    }

    // åˆå¹¶æ–‡ä»¶
    const writeStream = fs.createWriteStream(outputPath);

    for (let i = 0; i < totalChunks; i++) {
      const chunkPath = path.join(chunkDir, `${i}.chunk`);
      const chunkBuffer = await fs.readFile(chunkPath);
      writeStream.write(chunkBuffer);
    }

    writeStream.end();

    // ç­‰å¾…å†™å…¥å®Œæˆ
    await new Promise((resolve, reject) => {
      writeStream.on('finish', resolve);
      writeStream.on('error', reject);
    });

    // éªŒè¯åˆå¹¶åçš„æ–‡ä»¶
    const mergedHash = await calculateFileHash(outputPath);
    if (mergedHash !== fileHash) {
      await fs.remove(outputPath);
      throw new Error('æ–‡ä»¶åˆå¹¶åhashä¸åŒ¹é…');
    }

    // æ¸…ç†åˆ‡ç‰‡æ–‡ä»¶
    await fs.remove(chunkDir);

    res.json({
      success: true,
      fileName,
      fileSize: (await fs.stat(outputPath)).size,
      fileHash: mergedHash,
      message: 'æ–‡ä»¶åˆå¹¶æˆåŠŸ'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * @description è®¡ç®—æ–‡ä»¶hashï¼ˆä¸SparkMD5ä¿æŒä¸€è‡´ï¼‰
 * ç¡®ä¿ä½¿ç”¨MD5ç®—æ³•ï¼Œä¸å‰ç«¯SparkMD5è®¡ç®—ç»“æœä¸€è‡´
 */
async function calculateFileHash(filePath) {
  // ä½¿ç”¨MD5ç®—æ³•ï¼Œç¡®ä¿ä¸å‰ç«¯SparkMD5ä¸€è‡´
  const hash = crypto.createHash('md5');
  const stream = fs.createReadStream(filePath);

  return new Promise((resolve, reject) => {
    stream.on('data', data => hash.update(data));
    stream.on('end', () => {
      const result = hash.digest('hex');
      console.log(`æ–‡ä»¶hashè®¡ç®—å®Œæˆ (MD5): ${result}`);
      resolve(result);
    });
    stream.on('error', reject);
  });
}

/**
 * @description æ¸…ç†è¿‡æœŸçš„ä¸´æ—¶æ–‡ä»¶
 */
async function cleanupExpiredFiles() {
  const expireTime = 24 * 60 * 60 * 1000; // 24å°æ—¶
  const now = Date.now();

  try {
    const chunkDirs = await fs.readdir(config.chunkDir);

    for (const dir of chunkDirs) {
      const dirPath = path.join(config.chunkDir, dir);
      const stat = await fs.stat(dirPath);

      if (now - stat.mtime.getTime() > expireTime) {
        await fs.remove(dirPath);
        console.log(`æ¸…ç†è¿‡æœŸç›®å½•: ${dirPath}`);
      }
    }
  } catch (error) {
    console.error('æ¸…ç†è¿‡æœŸæ–‡ä»¶å¤±è´¥:', error);
  }
}

// å®šæ—¶æ¸…ç†è¿‡æœŸæ–‡ä»¶
setInterval(cleanupExpiredFiles, 60 * 60 * 1000); // æ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡

app.listen(3000, () => {
  console.log('å¤§æ–‡ä»¶ä¸Šä¼ æœåŠ¡å¯åŠ¨åœ¨ç«¯å£ 3000');
});

/**
 * @description æµ‹è¯•åˆ‡ç‰‡hashä¸€è‡´æ€§çš„API
 * ç”¨äºéªŒè¯å‰åç«¯hashè®¡ç®—ç»“æœæ˜¯å¦ä¸€è‡´
 */
app.post('/api/test/chunk-hash', upload.single('chunk'), async (req, res) => {
  try {
    const { expectedHash, chunkIndex, hashAlgorithm = 'md5' } = req.body;
    const chunkFile = req.file;

    if (!chunkFile) {
      return res.status(400).json({ error: 'åˆ‡ç‰‡æ–‡ä»¶ç¼ºå¤±' });
    }

    // åç«¯è®¡ç®—åˆ‡ç‰‡hashï¼ˆç¡®ä¿ä½¿ç”¨ç›¸åŒçš„MD5ç®—æ³•ï¼‰
    const backendHash = await calculateFileHash(chunkFile.path);

    // æ¯”è¾ƒhashå€¼
    const isConsistent = backendHash === expectedHash;

    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    await fs.remove(chunkFile.path);

    res.json({
      isConsistent: isConsistent,
      frontendHash: expectedHash,
      backendHash: backendHash,
      algorithm: 'md5',
      chunkIndex: parseInt(chunkIndex),
      message: isConsistent ? 'Hashä¸€è‡´' : 'Hashä¸ä¸€è‡´'
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 2. Spring Boot å®ç°

```java
/**
 * @description å¤§æ–‡ä»¶ä¸Šä¼ æ§åˆ¶å™¨
 */
@RestController
@RequestMapping("/api/upload")
public class LargeFileUploadController {

    private final LargeFileUploadService uploadService;

    @Value("${upload.chunk.path}")
    private String chunkPath;

    @Value("${upload.file.path}")
    private String filePath;

    /**
     * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
     */
    @PostMapping("/check")
    public ResponseEntity<?> checkFile(@RequestBody CheckFileRequest request) {
        try {
            boolean exists = uploadService.checkFileExists(request.getFileHash(), request.getFileName());
            return ResponseEntity.ok(Map.of(
                "exists", exists,
                "message", exists ? "æ–‡ä»¶å·²å­˜åœ¨ï¼Œæ”¯æŒç§’ä¼ " : "æ–‡ä»¶ä¸å­˜åœ¨"
            ));
        } catch (Exception e) {
            return ResponseEntity.status(500).body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * è·å–å·²ä¸Šä¼ çš„åˆ‡ç‰‡
     */
    @GetMapping("/chunks/{fileHash}")
    public ResponseEntity<?> getUploadedChunks(@PathVariable String fileHash) {
        try {
            List<Integer> uploadedChunks = uploadService.getUploadedChunks(fileHash);
            return ResponseEntity.ok(Map.of("uploadedChunks", uploadedChunks));
        } catch (Exception e) {
            return ResponseEntity.status(500).body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * ä¸Šä¼ åˆ‡ç‰‡
     */
    @PostMapping("/chunk")
    public ResponseEntity<?> uploadChunk(
            @RequestParam("chunk") MultipartFile chunk,
            @RequestParam("fileHash") String fileHash,
            @RequestParam("fileName") String fileName,
            @RequestParam("chunkIndex") Integer chunkIndex,
            @RequestParam("totalChunks") Integer totalChunks) {
        try {
            uploadService.saveChunk(chunk, fileHash, chunkIndex);
            return ResponseEntity.ok(Map.of(
                "success", true,
                "chunkIndex", chunkIndex,
                "message", "åˆ‡ç‰‡ä¸Šä¼ æˆåŠŸ"
            ));
        } catch (Exception e) {
            return ResponseEntity.status(500).body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * åˆå¹¶æ–‡ä»¶
     */
    @PostMapping("/merge")
    public ResponseEntity<?> mergeFile(@RequestBody MergeFileRequest request) {
        try {
            String filePath = uploadService.mergeChunks(
                request.getFileHash(),
                request.getFileName(),
                request.getTotalChunks()
            );

            return ResponseEntity.ok(Map.of(
                "success", true,
                "fileName", request.getFileName(),
                "filePath", filePath,
                "message", "æ–‡ä»¶åˆå¹¶æˆåŠŸ"
            ));
        } catch (Exception e) {
            return ResponseEntity.status(500).body(Map.of("error", e.getMessage()));
        }
    }
}

/**
 * @description å¤§æ–‡ä»¶ä¸Šä¼ æœåŠ¡å®ç°
 */
@Service
public class LargeFileUploadService {

    @Value("${upload.chunk.path}")
    private String chunkBasePath;

    @Value("${upload.file.path}")
    private String fileBasePath;

    /**
     * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
     */
    public boolean checkFileExists(String fileHash, String fileName) throws IOException {
        Path filePath = Paths.get(fileBasePath, fileName);
        if (!Files.exists(filePath)) {
            return false;
        }

        // éªŒè¯æ–‡ä»¶hash
        String existingHash = calculateFileHash(filePath);
        return fileHash.equals(existingHash);
    }

    /**
     * è·å–å·²ä¸Šä¼ çš„åˆ‡ç‰‡åˆ—è¡¨
     */
    public List<Integer> getUploadedChunks(String fileHash) throws IOException {
        Path chunkDir = Paths.get(chunkBasePath, fileHash);
        if (!Files.exists(chunkDir)) {
            return Collections.emptyList();
        }

        return Files.list(chunkDir)
            .filter(path -> path.toString().endsWith(".chunk"))
            .map(path -> {
                String fileName = path.getFileName().toString();
                return Integer.parseInt(fileName.split("\\.")[0]);
            })
            .sorted()
            .collect(Collectors.toList());
    }

    /**
     * ä¿å­˜åˆ‡ç‰‡
     */
    public void saveChunk(MultipartFile chunk, String fileHash, Integer chunkIndex) throws IOException {
        Path chunkDir = Paths.get(chunkBasePath, fileHash);
        Files.createDirectories(chunkDir);

        Path chunkFile = chunkDir.resolve(chunkIndex + ".chunk");
        Files.copy(chunk.getInputStream(), chunkFile, StandardCopyOption.REPLACE_EXISTING);

        // ä¿å­˜åˆ‡ç‰‡ä¿¡æ¯
        ChunkInfo chunkInfo = new ChunkInfo();
        chunkInfo.setIndex(chunkIndex);
        chunkInfo.setSize(chunk.getSize());
        chunkInfo.setUploadTime(LocalDateTime.now());

        Path infoFile = chunkDir.resolve(chunkIndex + ".info");
        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(infoFile.toFile(), chunkInfo);
    }

    /**
     * åˆå¹¶æ–‡ä»¶åˆ‡ç‰‡
     */
    public String mergeChunks(String fileHash, String fileName, Integer totalChunks) throws IOException {
        Path chunkDir = Paths.get(chunkBasePath, fileHash);
        Path outputFile = Paths.get(fileBasePath, fileName);

        // æ£€æŸ¥åˆ‡ç‰‡å®Œæ•´æ€§
        List<Integer> missingChunks = new ArrayList<>();
        for (int i = 0; i < totalChunks; i++) {
            Path chunkFile = chunkDir.resolve(i + ".chunk");
            if (!Files.exists(chunkFile)) {
                missingChunks.add(i);
            }
        }

        if (!missingChunks.isEmpty()) {
            throw new RuntimeException("åˆ‡ç‰‡ä¸å®Œæ•´ï¼Œç¼ºå¤±: " + missingChunks);
        }

        // åˆå¹¶æ–‡ä»¶
        try (FileChannel outputChannel = FileChannel.open(outputFile,
                StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {

            for (int i = 0; i < totalChunks; i++) {
                Path chunkFile = chunkDir.resolve(i + ".chunk");
                try (FileChannel chunkChannel = FileChannel.open(chunkFile, StandardOpenOption.READ)) {
                    chunkChannel.transferTo(0, chunkChannel.size(), outputChannel);
                }
            }
        }

        // éªŒè¯åˆå¹¶åçš„æ–‡ä»¶
        String mergedHash = calculateFileHash(outputFile);
        if (!fileHash.equals(mergedHash)) {
            Files.deleteIfExists(outputFile);
            throw new RuntimeException("æ–‡ä»¶åˆå¹¶åhashä¸åŒ¹é…");
        }

        // æ¸…ç†åˆ‡ç‰‡æ–‡ä»¶
        deleteDirectory(chunkDir);

        return outputFile.toString();
    }

    /**
     * è®¡ç®—æ–‡ä»¶hash
     */
    private String calculateFileHash(Path filePath) throws IOException {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        try (InputStream is = Files.newInputStream(filePath)) {
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = is.read(buffer)) != -1) {
                md5.update(buffer, 0, bytesRead);
            }
        }

        byte[] hashBytes = md5.digest();
        return DatatypeConverter.printHexBinary(hashBytes).toLowerCase();
    }
}
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. åˆ‡ç‰‡å¤§å°ä¼˜åŒ–

```javascript
/**
 * @description åŠ¨æ€è®¡ç®—æœ€ä¼˜åˆ‡ç‰‡å¤§å°
 */
class OptimalChunkCalculator {
  constructor() {
    this.networkSpeed = 0; // KB/s
    this.avgLatency = 0; // ms
    this.concurrency = 3;
  }

  /**
   * @description æµ‹è¯•ç½‘ç»œé€Ÿåº¦
   */
  async measureNetworkSpeed() {
    const testSize = 100 * 1024; // 100KBæµ‹è¯•æ–‡ä»¶
    const iterations = 3;
    let totalSpeed = 0;
    let totalLatency = 0;

    for (let i = 0; i < iterations; i++) {
      const start = performance.now();

      try {
        const response = await fetch('/api/speed-test', {
          method: 'POST',
          body: new ArrayBuffer(testSize)
        });

        const end = performance.now();
        const latency = end - start;
        const speed = testSize / (latency / 1000) / 1024; // KB/s

        totalSpeed += speed;
        totalLatency += latency;
      } catch (error) {
        console.warn('ç½‘ç»œé€Ÿåº¦æµ‹è¯•å¤±è´¥:', error);
      }
    }

    this.networkSpeed = totalSpeed / iterations;
    this.avgLatency = totalLatency / iterations;
  }

  /**
   * @description è®¡ç®—æœ€ä¼˜åˆ‡ç‰‡å¤§å°
   */
  calculateOptimalChunkSize(fileSize) {
    // åŸºäºç½‘ç»œé€Ÿåº¦å’Œå»¶è¿Ÿè®¡ç®—
    const baseChunkSize = 1024 * 1024; // 1MBåŸºç¡€å¤§å°
    const maxChunkSize = 10 * 1024 * 1024; // 10MBæœ€å¤§
    const minChunkSize = 256 * 1024; // 256KBæœ€å°

    let optimalSize;

    if (this.networkSpeed > 1000) { // é«˜é€Ÿç½‘ç»œ > 1MB/s
      optimalSize = Math.min(maxChunkSize, fileSize / 50);
    } else if (this.networkSpeed > 100) { // ä¸­é€Ÿç½‘ç»œ 100KB/s - 1MB/s
      optimalSize = Math.min(5 * 1024 * 1024, fileSize / 100);
    } else { // ä½é€Ÿç½‘ç»œ < 100KB/s
      optimalSize = Math.min(2 * 1024 * 1024, fileSize / 200);
    }

    // å»¶è¿Ÿè°ƒæ•´
    if (this.avgLatency > 500) {
      optimalSize *= 1.5; // é«˜å»¶è¿Ÿæ—¶å¢å¤§åˆ‡ç‰‡
    } else if (this.avgLatency < 100) {
      optimalSize *= 0.8; // ä½å»¶è¿Ÿæ—¶å‡å°åˆ‡ç‰‡
    }

    return Math.max(minChunkSize, Math.min(maxChunkSize, optimalSize));
  }

  /**
   * @description åŠ¨æ€è°ƒæ•´å¹¶å‘æ•°
   */
  calculateOptimalConcurrency() {
    if (this.networkSpeed > 1000) {
      return Math.min(6, this.concurrency + 1);
    } else if (this.networkSpeed < 100) {
      return Math.max(1, this.concurrency - 1);
    }
    return this.concurrency;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const calculator = new OptimalChunkCalculator();
await calculator.measureNetworkSpeed();

const optimalChunkSize = calculator.calculateOptimalChunkSize(file.size);
const optimalConcurrency = calculator.calculateOptimalConcurrency();

console.log(`ç½‘ç»œé€Ÿåº¦: ${calculator.networkSpeed.toFixed(2)} KB/s`);
console.log(`å¹³å‡å»¶è¿Ÿ: ${calculator.avgLatency.toFixed(2)} ms`);
console.log(`æœ€ä¼˜åˆ‡ç‰‡å¤§å°: ${(optimalChunkSize / 1024 / 1024).toFixed(2)} MB`);
console.log(`æœ€ä¼˜å¹¶å‘æ•°: ${optimalConcurrency}`);
```

### 2. å†…å­˜ä½¿ç”¨ä¼˜åŒ–

```javascript
/**
 * @description å†…å­˜ä¼˜åŒ–çš„æ–‡ä»¶å¤„ç†å™¨
 */
class MemoryOptimizedFileProcessor {
  constructor(maxMemoryUsage = 100 * 1024 * 1024) { // 100MB
    this.maxMemoryUsage = maxMemoryUsage;
    this.currentMemoryUsage = 0;
    this.processingQueue = [];
    this.cache = new Map();
  }

  /**
   * @description æµå¼è¯»å–å¤§æ–‡ä»¶
   */
  async *readFileInChunks(file, chunkSize) {
    let offset = 0;

    while (offset < file.size) {
      // å†…å­˜ä½¿ç”¨æ£€æŸ¥
      await this.waitForMemoryAvailable(chunkSize);

      const end = Math.min(offset + chunkSize, file.size);
      const chunk = file.slice(offset, end);

      this.currentMemoryUsage += chunk.size;

      yield {
        chunk,
        index: Math.floor(offset / chunkSize),
        start: offset,
        end: end,
        isLast: end === file.size
      };

      offset = end;
    }
  }

  /**
   * @description ç­‰å¾…å†…å­˜å¯ç”¨
   */
  async waitForMemoryAvailable(requiredSize) {
    while (this.currentMemoryUsage + requiredSize > this.maxMemoryUsage) {
      await new Promise(resolve => setTimeout(resolve, 100));
      this.cleanupMemory();
    }
  }

  /**
   * @description æ¸…ç†å†…å­˜
   */
  cleanupMemory() {
    // æ¸…ç†ç¼“å­˜
    if (this.cache.size > 50) {
      const oldestKeys = Array.from(this.cache.keys()).slice(0, 10);
      oldestKeys.forEach(key => {
        const item = this.cache.get(key);
        this.currentMemoryUsage -= item.size;
        this.cache.delete(key);
      });
    }

    // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (window.gc) {
      window.gc();
    }
  }

  /**
   * @description é‡Šæ”¾åˆ‡ç‰‡å†…å­˜
   */
  releaseChunkMemory(chunk) {
    this.currentMemoryUsage -= chunk.size;
  }

  /**
   * @description è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
   */
  getMemoryInfo() {
    return {
      current: this.currentMemoryUsage,
      max: this.maxMemoryUsage,
      usage: (this.currentMemoryUsage / this.maxMemoryUsage * 100).toFixed(2) + '%',
      available: this.maxMemoryUsage - this.currentMemoryUsage
    };
  }
}
```

### 3. ç½‘ç»œé‡è¯•ç­–ç•¥

```javascript
/**
 * @description æ™ºèƒ½é‡è¯•ç­–ç•¥
 */
class SmartRetryStrategy {
  constructor(options = {}) {
    this.maxRetries = options.maxRetries || 3;
    this.baseDelay = options.baseDelay || 1000;
    this.maxDelay = options.maxDelay || 30000;
    this.backoffFactor = options.backoffFactor || 2;
    this.jitterMax = options.jitterMax || 1000;
  }

  /**
   * @description æ‰§è¡Œå¸¦é‡è¯•çš„è¯·æ±‚
   */
  async executeWithRetry(requestFn, context = {}) {
    let lastError;

    for (let attempt = 1; attempt <= this.maxRetries + 1; attempt++) {
      try {
        return await requestFn();
      } catch (error) {
        lastError = error;

        if (attempt > this.maxRetries) {
          throw error;
        }

        // åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•
        if (!this.shouldRetry(error, attempt)) {
          throw error;
        }

        // è®¡ç®—å»¶è¿Ÿæ—¶é—´
        const delay = this.calculateDelay(attempt, error);
        console.log(`è¯·æ±‚å¤±è´¥ï¼Œ${delay}msåé‡è¯• (${attempt}/${this.maxRetries}):`, error.message);

        await this.delay(delay);
      }
    }

    throw lastError;
  }

  /**
   * @description åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
   */
  shouldRetry(error, attempt) {
    // ç½‘ç»œé”™è¯¯æˆ–æœåŠ¡å™¨é”™è¯¯æ‰é‡è¯•
    const retryableErrors = [
      'NetworkError',
      'TimeoutError',
      'AbortError'
    ];

    const retryableStatus = [408, 429, 500, 502, 503, 504];

    // æ£€æŸ¥é”™è¯¯ç±»å‹
    if (retryableErrors.includes(error.name)) {
      return true;
    }

    // æ£€æŸ¥HTTPçŠ¶æ€ç 
    if (error.status && retryableStatus.includes(error.status)) {
      return true;
    }

    // æ£€æŸ¥ç½‘ç»œè¿æ¥
    if (!navigator.onLine) {
      return true;
    }

    return false;
  }

  /**
   * @description è®¡ç®—é‡è¯•å»¶è¿Ÿ
   */
  calculateDelay(attempt, error) {
    // åŸºç¡€æŒ‡æ•°é€€é¿
    let delay = this.baseDelay * Math.pow(this.backoffFactor, attempt - 1);

    // æ ¹æ®é”™è¯¯ç±»å‹è°ƒæ•´
    if (error.status === 429) { // é™æµ
      delay *= 2;
    } else if (error.status >= 500) { // æœåŠ¡å™¨é”™è¯¯
      delay *= 1.5;
    }

    // æ·»åŠ éšæœºæŠ–åŠ¨
    const jitter = Math.random() * this.jitterMax;
    delay += jitter;

    return Math.min(delay, this.maxDelay);
  }

  /**
   * @description å»¶è¿Ÿå‡½æ•°
   */
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const retryStrategy = new SmartRetryStrategy({
  maxRetries: 3,
  baseDelay: 1000,
  backoffFactor: 2
});

// åœ¨ä¸Šä¼ å™¨ä¸­ä½¿ç”¨
async function uploadChunkWithRetry(chunkData) {
  return retryStrategy.executeWithRetry(async () => {
    const formData = new FormData();
    formData.append('chunk', chunkData.chunk);
    formData.append('fileHash', chunkData.fileHash);
    formData.append('chunkIndex', chunkData.index);

    const response = await fetch('/api/upload/chunk', {
      method: 'POST',
      body: formData,
      signal: AbortSignal.timeout(30000) // 30ç§’è¶…æ—¶
    });

    if (!response.ok) {
      const error = new Error(`Upload failed: ${response.statusText}`);
      error.status = response.status;
      throw error;
    }

    return response.json();
  });
}
```

## å¸¸è§é¢è¯•é—®é¢˜

### 1. å¤§æ–‡ä»¶ä¸Šä¼ çš„æŠ€æœ¯éš¾ç‚¹æœ‰å“ªäº›ï¼Ÿå¦‚ä½•è§£å†³ï¼Ÿ

**ç­”**ï¼š
å¤§æ–‡ä»¶ä¸Šä¼ çš„ä¸»è¦æŠ€æœ¯éš¾ç‚¹åŒ…æ‹¬ï¼š

1. **è¶…æ—¶é—®é¢˜**ï¼š
   - é—®é¢˜ï¼šå¤§æ–‡ä»¶ä¼ è¾“æ—¶é—´é•¿ï¼Œå®¹æ˜“è¶…æ—¶
   - è§£å†³ï¼šæ–‡ä»¶åˆ‡ç‰‡ï¼Œåˆ†å—ä¸Šä¼ ï¼Œæ¯ä¸ªåˆ‡ç‰‡ç‹¬ç«‹å¤„ç†

2. **å†…å­˜å ç”¨**ï¼š
   - é—®é¢˜ï¼šä¸€æ¬¡æ€§è¯»å–å¤§æ–‡ä»¶ä¼šå ç”¨å¤§é‡å†…å­˜
   - è§£å†³ï¼šæµå¼è¯»å–ï¼Œåˆ†ç‰‡å¤„ç†ï¼ŒåŠæ—¶é‡Šæ”¾å†…å­˜

3. **ç½‘ç»œä¸­æ–­**ï¼š
   - é—®é¢˜ï¼šç½‘ç»œä¸ç¨³å®šå¯¼è‡´ä¸Šä¼ å¤±è´¥
   - è§£å†³ï¼šæ–­ç‚¹ç»­ä¼ ï¼Œè®°å½•ä¸Šä¼ è¿›åº¦ï¼Œæ”¯æŒé‡æ–°ä¸Šä¼ 

4. **å¹¶å‘æ§åˆ¶**ï¼š
   - é—®é¢˜ï¼šè¿‡å¤šå¹¶å‘è¯·æ±‚å¯èƒ½å¯¼è‡´æœåŠ¡å™¨å‹åŠ›
   - è§£å†³ï¼šæ§åˆ¶å¹¶å‘æ•°é‡ï¼Œé˜Ÿåˆ—ç®¡ç†

```javascript
// è§£å†³æ–¹æ¡ˆç¤ºä¾‹
const uploadConfig = {
  chunkSize: 2 * 1024 * 1024,    // 2MBåˆ‡ç‰‡
  concurrency: 3,                // å¹¶å‘æ•°æ§åˆ¶
  retryTimes: 3,                // é‡è¯•æ¬¡æ•°
  timeout: 30000                 // è¶…æ—¶æ—¶é—´
};

// å†…å­˜ä¼˜åŒ–
const memoryManager = {
  maxUsage: 100 * 1024 * 1024,  // æœ€å¤§å†…å­˜100MB
  cleanup() {
    // å®šæœŸæ¸…ç†ä¸ç”¨çš„åˆ‡ç‰‡ç¼“å­˜
  }
};
```

### 2. å¦‚ä½•å®ç°æ–­ç‚¹ç»­ä¼ åŠŸèƒ½ï¼Ÿ

**ç­”**ï¼š
æ–­ç‚¹ç»­ä¼ çš„æ ¸å¿ƒæ˜¯è®°å½•å’Œæ¢å¤ä¸Šä¼ è¿›åº¦ï¼š

1. **è¿›åº¦è®°å½•**ï¼š
   - å‰ç«¯ï¼šä½¿ç”¨localStorageè®°å½•å·²ä¸Šä¼ çš„åˆ‡ç‰‡ä¿¡æ¯
   - åç«¯ï¼šåœ¨æœåŠ¡å™¨ä¿å­˜åˆ‡ç‰‡ä¸Šä¼ çŠ¶æ€

2. **çŠ¶æ€æŸ¥è¯¢**ï¼š
   - ä¸Šä¼ å‰æŸ¥è¯¢å·²ä¸Šä¼ çš„åˆ‡ç‰‡åˆ—è¡¨
   - è·³è¿‡å·²ä¸Šä¼ çš„åˆ‡ç‰‡ï¼Œåªä¸Šä¼ ç¼ºå¤±éƒ¨åˆ†

3. **æ–‡ä»¶æ ‡è¯†**ï¼š
   - ä½¿ç”¨æ–‡ä»¶hashä½œä¸ºå”¯ä¸€æ ‡è¯†
   - ç¡®ä¿åŒä¸€æ–‡ä»¶åœ¨ä¸åŒæ—¶é—´ä¸Šä¼ æ—¶èƒ½æ­£ç¡®è¯†åˆ«

```javascript
// æ–­ç‚¹ç»­ä¼ å®ç°
class ResumeableUploader {
  async resumeUpload(file) {
    // 1. è®¡ç®—æ–‡ä»¶hash
    const fileHash = await this.calculateHash(file);

    // 2. æŸ¥è¯¢å·²ä¸Šä¼ åˆ‡ç‰‡
    const uploadedChunks = await this.getUploadedChunks(fileHash);

    // 3. åˆ›å»ºåˆ‡ç‰‡åˆ—è¡¨
    const allChunks = this.createChunks(file);

    // 4. è¿‡æ»¤å·²ä¸Šä¼ çš„åˆ‡ç‰‡
    const pendingChunks = allChunks.filter(
      chunk => !uploadedChunks.includes(chunk.index)
    );

    // 5. ä¸Šä¼ å‰©ä½™åˆ‡ç‰‡
    await this.uploadChunks(pendingChunks);

    // 6. åˆå¹¶æ–‡ä»¶
    await this.mergeFile(fileHash, file.name);
  }

  // æœ¬åœ°çŠ¶æ€ç®¡ç†
  saveProgress(fileHash, chunkIndex) {
    const key = `upload_${fileHash}`;
    const progress = JSON.parse(localStorage.getItem(key) || '[]');
    progress.push(chunkIndex);
    localStorage.setItem(key, JSON.stringify(progress));
  }

  getLocalProgress(fileHash) {
    const key = `upload_${fileHash}`;
    return JSON.parse(localStorage.getItem(key) || '[]');
  }
}
```

### 3. å¦‚ä½•ä¼˜åŒ–å¤§æ–‡ä»¶ä¸Šä¼ çš„æ€§èƒ½ï¼Ÿ

**ç­”**ï¼š
æ€§èƒ½ä¼˜åŒ–å¯ä»¥ä»å¤šä¸ªç»´åº¦è¿›è¡Œï¼š

1. **åˆ‡ç‰‡å¤§å°ä¼˜åŒ–**ï¼š
   - æ ¹æ®ç½‘ç»œé€Ÿåº¦åŠ¨æ€è°ƒæ•´åˆ‡ç‰‡å¤§å°
   - é«˜é€Ÿç½‘ç»œä½¿ç”¨å¤§åˆ‡ç‰‡ï¼Œä½é€Ÿç½‘ç»œä½¿ç”¨å°åˆ‡ç‰‡

2. **å¹¶å‘æ§åˆ¶**ï¼š
   - åˆç†è®¾ç½®å¹¶å‘æ•°ï¼Œé¿å…è¿‡å¤šå¹¶å‘å¯¼è‡´æœåŠ¡å™¨å‹åŠ›
   - æ ¹æ®ç½‘ç»œçŠ¶å†µåŠ¨æ€è°ƒæ•´å¹¶å‘æ•°

3. **ç¼“å­˜ç­–ç•¥**ï¼š
   - å®¢æˆ·ç«¯ç¼“å­˜å·²è®¡ç®—çš„æ–‡ä»¶hash
   - æœåŠ¡ç«¯ç¼“å­˜åˆ‡ç‰‡çŠ¶æ€ä¿¡æ¯

4. **å‹ç¼©ä¼˜åŒ–**ï¼š
   - å¯¹å¯å‹ç¼©æ–‡ä»¶è¿›è¡Œå‹ç¼©ä¼ è¾“
   - ä½¿ç”¨gzipæˆ–brotliå‹ç¼©

```javascript
// æ€§èƒ½ä¼˜åŒ–é…ç½®
const performanceConfig = {
  // åŠ¨æ€åˆ‡ç‰‡å¤§å°
  calculateChunkSize(networkSpeed) {
    if (networkSpeed > 1000) return 5 * 1024 * 1024; // 5MB
    if (networkSpeed > 100) return 2 * 1024 * 1024;  // 2MB
    return 1024 * 1024; // 1MB
  },

  // åŠ¨æ€å¹¶å‘æ•°
  calculateConcurrency(networkSpeed, serverLoad) {
    let concurrency = Math.min(6, Math.max(1, Math.floor(networkSpeed / 200)));
    if (serverLoad > 0.8) concurrency = Math.max(1, concurrency - 2);
    return concurrency;
  },

  // æ™ºèƒ½é‡è¯•
  retryStrategy: {
    maxRetries: 3,
    backoffFactor: 1.5,
    maxDelay: 30000
  }
};

// ç½‘ç»œçŠ¶å†µç›‘æ§
class NetworkMonitor {
  constructor() {
    this.speed = 0;
    this.latency = 0;
  }

  async measureSpeed() {
    const start = performance.now();
    const response = await fetch('/api/ping');
    const end = performance.now();

    this.latency = end - start;
    // æ ¹æ®å“åº”æ—¶é—´ä¼°ç®—ç½‘ç»œé€Ÿåº¦
    this.speed = this.estimateSpeed(this.latency);
  }

  estimateSpeed(latency) {
    // åŸºäºå»¶è¿Ÿä¼°ç®—é€Ÿåº¦çš„ç®€å•ç®—æ³•
    if (latency < 50) return 1000; // é«˜é€Ÿ
    if (latency < 200) return 500; // ä¸­é€Ÿ
    return 100; // ä½é€Ÿ
  }
}
```

### 4. å¤§æ–‡ä»¶ä¸Šä¼ çš„å®‰å…¨æ€§å¦‚ä½•ä¿è¯ï¼Ÿ

**ç­”**ï¼š
å¤§æ–‡ä»¶ä¸Šä¼ çš„å®‰å…¨æ€§éœ€è¦ä»å¤šä¸ªæ–¹é¢è€ƒè™‘ï¼š

1. **æ–‡ä»¶ç±»å‹éªŒè¯**ï¼š
   - å‰ç«¯å’Œåç«¯åŒé‡éªŒè¯æ–‡ä»¶ç±»å‹
   - ä½¿ç”¨æ–‡ä»¶å¤´ä¿¡æ¯éªŒè¯ï¼Œä¸ä»…ä¾èµ–æ‰©å±•å

2. **æ–‡ä»¶å¤§å°é™åˆ¶**ï¼š
   - è®¾ç½®å•æ–‡ä»¶å’Œæ€»ä¸Šä¼ å¤§å°é™åˆ¶
   - é˜²æ­¢æ¶æ„å¤§æ–‡ä»¶æ”»å‡»

3. **ç—…æ¯’æ‰«æ**ï¼š
   - ä¸Šä¼ å®Œæˆåè¿›è¡Œç—…æ¯’æ‰«æ
   - é›†æˆç¬¬ä¸‰æ–¹å®‰å…¨æœåŠ¡

4. **è®¿é—®æ§åˆ¶**ï¼š
   - ç”¨æˆ·èº«ä»½éªŒè¯å’Œæˆæƒ
   - ä¸Šä¼ ä»¤ç‰ŒéªŒè¯

```javascript
// å®‰å…¨éªŒè¯å®ç°
class SecurityValidator {
  // æ–‡ä»¶ç±»å‹éªŒè¯
  validateFileType(file, allowedTypes) {
    // 1. æ‰©å±•åæ£€æŸ¥
    const extension = file.name.split('.').pop().toLowerCase();
    if (!allowedTypes.extensions.includes(extension)) {
      throw new Error('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹');
    }

    // 2. MIMEç±»å‹æ£€æŸ¥
    if (!allowedTypes.mimeTypes.includes(file.type)) {
      throw new Error('MIMEç±»å‹ä¸åŒ¹é…');
    }

    // 3. æ–‡ä»¶å¤´æ£€æŸ¥
    return this.validateFileHeader(file, extension);
  }

  // æ–‡ä»¶å¤´éªŒè¯
  async validateFileHeader(file, extension) {
    const headerMap = {
      'jpg': [0xFF, 0xD8, 0xFF],
      'png': [0x89, 0x50, 0x4E, 0x47],
      'pdf': [0x25, 0x50, 0x44, 0x46]
    };

    const expectedHeader = headerMap[extension];
    if (!expectedHeader) return true;

    const header = await this.readFileHeader(file, expectedHeader.length);
    return this.compareHeaders(header, expectedHeader);
  }

  // å¤§å°é™åˆ¶éªŒè¯
  validateFileSize(file, maxSize) {
    if (file.size > maxSize) {
      throw new Error(`æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶ ${this.formatSize(maxSize)}`);
    }
  }

  // æ¶æ„æ–‡ä»¶æ£€æµ‹
  async scanForMalware(fileHash) {
    const response = await fetch('/api/security/scan', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ fileHash })
    });

    const result = await response.json();
    if (result.threat) {
      throw new Error('æ£€æµ‹åˆ°æ¶æ„æ–‡ä»¶');
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const validator = new SecurityValidator();

// ä¸Šä¼ å‰éªŒè¯
const allowedTypes = {
  extensions: ['jpg', 'png', 'pdf', 'mp4'],
  mimeTypes: ['image/jpeg', 'image/png', 'application/pdf', 'video/mp4']
};

try {
  validator.validateFileType(file, allowedTypes);
  validator.validateFileSize(file, 500 * 1024 * 1024); // 500MB

  // ä¸Šä¼ åæ‰«æ
  await validator.scanForMalware(fileHash);
} catch (error) {
  console.error('å®‰å…¨éªŒè¯å¤±è´¥:', error.message);
}
```

### 5. å¦‚ä½•ç›‘æ§å’Œåˆ†æå¤§æ–‡ä»¶ä¸Šä¼ çš„æ€§èƒ½ï¼Ÿ

**ç­”**ï¼š
æ€§èƒ½ç›‘æ§éœ€è¦æ”¶é›†å…³é”®æŒ‡æ ‡å¹¶è¿›è¡Œåˆ†æï¼š

1. **å…³é”®æŒ‡æ ‡**ï¼š
   - ä¸Šä¼ é€Ÿåº¦ã€æˆåŠŸç‡ã€é”™è¯¯ç‡
   - åˆ‡ç‰‡ä¸Šä¼ æ—¶é—´ã€é‡è¯•æ¬¡æ•°
   - æœåŠ¡å™¨å“åº”æ—¶é—´ã€èµ„æºä½¿ç”¨ç‡

2. **æ•°æ®æ”¶é›†**ï¼š
   - å‰ç«¯åŸ‹ç‚¹æ”¶é›†ç”¨æˆ·è¡Œä¸ºæ•°æ®
   - åç«¯æ—¥å¿—è®°å½•è¯¦ç»†çš„æ“ä½œä¿¡æ¯

3. **å®æ—¶ç›‘æ§**ï¼š
   - å®æ—¶æ˜¾ç¤ºä¸Šä¼ è¿›åº¦å’ŒçŠ¶æ€
   - é”™è¯¯é¢„è­¦å’Œè‡ªåŠ¨é‡è¯•

```javascript
// æ€§èƒ½ç›‘æ§å®ç°
class UploadMonitor {
  constructor() {
    this.metrics = {
      startTime: 0,
      endTime: 0,
      totalSize: 0,
      uploadedSize: 0,
      chunkTimes: [],
      errorCount: 0,
      retryCount: 0
    };
  }

  // å¼€å§‹ç›‘æ§
  startMonitoring(file) {
    this.metrics.startTime = performance.now();
    this.metrics.totalSize = file.size;
    this.sendMetric('upload_start', {
      fileName: file.name,
      fileSize: file.size,
      timestamp: Date.now()
    });
  }

  // è®°å½•åˆ‡ç‰‡æ€§èƒ½
  recordChunkUpload(chunkIndex, size, duration, success) {
    this.metrics.chunkTimes.push({
      index: chunkIndex,
      size: size,
      duration: duration,
      success: success,
      speed: size / (duration / 1000) // bytes/second
    });

    if (success) {
      this.metrics.uploadedSize += size;
    } else {
      this.metrics.errorCount++;
    }

    // å‘é€å®æ—¶æ•°æ®
    this.sendMetric('chunk_upload', {
      chunkIndex,
      size,
      duration,
      success,
      timestamp: Date.now()
    });
  }

  // è®°å½•é‡è¯•
  recordRetry(chunkIndex) {
    this.metrics.retryCount++;
    this.sendMetric('chunk_retry', {
      chunkIndex,
      timestamp: Date.now()
    });
  }

  // å®Œæˆç›‘æ§
  endMonitoring(success) {
    this.metrics.endTime = performance.now();
    const totalDuration = this.metrics.endTime - this.metrics.startTime;
    const averageSpeed = this.metrics.totalSize / (totalDuration / 1000);

    const summary = {
      success: success,
      totalDuration: totalDuration,
      averageSpeed: averageSpeed,
      successRate: (this.metrics.uploadedSize / this.metrics.totalSize) * 100,
      errorRate: (this.metrics.errorCount / this.metrics.chunkTimes.length) * 100,
      retryCount: this.metrics.retryCount
    };

    this.sendMetric('upload_complete', summary);
    return summary;
  }

  // å‘é€ç›‘æ§æ•°æ®
  sendMetric(eventType, data) {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    fetch('/api/metrics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        event: eventType,
        data: data,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      })
    }).catch(error => {
      console.warn('ç›‘æ§æ•°æ®å‘é€å¤±è´¥:', error);
    });
  }

  // è·å–å®æ—¶ç»Ÿè®¡
  getRealTimeStats() {
    const successfulChunks = this.metrics.chunkTimes.filter(c => c.success);
    const avgSpeed = successfulChunks.length > 0
      ? successfulChunks.reduce((sum, c) => sum + c.speed, 0) / successfulChunks.length
      : 0;

    return {
      progress: (this.metrics.uploadedSize / this.metrics.totalSize) * 100,
      averageSpeed: avgSpeed,
      estimatedTimeRemaining: this.calculateETA(avgSpeed),
      errorRate: (this.metrics.errorCount / this.metrics.chunkTimes.length) * 100,
      currentSpeed: this.getCurrentSpeed()
    };
  }

  // è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
  calculateETA(avgSpeed) {
    const remainingSize = this.metrics.totalSize - this.metrics.uploadedSize;
    return avgSpeed > 0 ? remainingSize / avgSpeed : 0;
  }

  // è·å–å½“å‰é€Ÿåº¦ï¼ˆæœ€è¿‘5ä¸ªåˆ‡ç‰‡çš„å¹³å‡é€Ÿåº¦ï¼‰
  getCurrentSpeed() {
    const recentChunks = this.metrics.chunkTimes.slice(-5).filter(c => c.success);
    if (recentChunks.length === 0) return 0;

    return recentChunks.reduce((sum, c) => sum + c.speed, 0) / recentChunks.length;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new UploadMonitor();

// åœ¨ä¸Šä¼ å™¨ä¸­é›†æˆç›‘æ§
class MonitoredUploader extends LargeFileUploader {
  async upload(file, options = {}) {
    monitor.startMonitoring(file);

    try {
      const result = await super.upload(file, options);
      monitor.endMonitoring(true);
      return result;
    } catch (error) {
      monitor.endMonitoring(false);
      throw error;
    }
  }

  async uploadChunk(chunkData) {
    const startTime = performance.now();

    try {
      const result = await super.uploadChunk(chunkData);
      const duration = performance.now() - startTime;
      monitor.recordChunkUpload(chunkData.index, chunkData.chunk.size, duration, true);
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      monitor.recordChunkUpload(chunkData.index, chunkData.chunk.size, duration, false);
      monitor.recordRetry(chunkData.index);
      throw error;
    }
  }
}
```

## æ€»ç»“

å¤§æ–‡ä»¶ä¸Šä¼ æ˜¯ä¸€ä¸ªå¤æ‚çš„æŠ€æœ¯æŒ‘æˆ˜ï¼Œéœ€è¦ç»¼åˆè€ƒè™‘æ€§èƒ½ã€ç¨³å®šæ€§ã€å®‰å…¨æ€§ç­‰å¤šä¸ªæ–¹é¢ã€‚æ ¸å¿ƒæŠ€æœ¯åŒ…æ‹¬æ–‡ä»¶åˆ‡ç‰‡ã€æ–­ç‚¹ç»­ä¼ ã€å¹¶å‘æ§åˆ¶ç­‰ã€‚åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿˜éœ€è¦æ ¹æ®å…·ä½“çš„ä¸šåŠ¡åœºæ™¯å’ŒæŠ€æœ¯æ ˆè¿›è¡Œä¼˜åŒ–å’Œè°ƒæ•´ã€‚

å…³é”®è¦ç‚¹ï¼š
1. **æ–‡ä»¶åˆ‡ç‰‡**ï¼šå°†å¤§æ–‡ä»¶åˆ†å‰²ä¸ºå°å—ï¼Œåˆ†åˆ«å¤„ç†
2. **æ–­ç‚¹ç»­ä¼ **ï¼šè®°å½•ä¸Šä¼ è¿›åº¦ï¼Œæ”¯æŒä¸­æ–­åç»§ç»­
3. **å¹¶å‘æ§åˆ¶**ï¼šåˆç†æ§åˆ¶å¹¶å‘æ•°ï¼Œå¹³è¡¡æ€§èƒ½å’Œèµ„æº
4. **é”™è¯¯å¤„ç†**ï¼šæ™ºèƒ½é‡è¯•ç­–ç•¥ï¼Œæé«˜æˆåŠŸç‡
5. **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶ç›‘æ§ä¸Šä¼ çŠ¶æ€ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
6. **å®‰å…¨é˜²æŠ¤**ï¼šå¤šå±‚éªŒè¯ï¼Œç¡®ä¿æ–‡ä»¶å®‰å…¨æ€§